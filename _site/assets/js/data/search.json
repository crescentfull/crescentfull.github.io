[
  
  {
    "title": "Jekyll로 블로그 시작하기: 테스트 포스팅",
    "url": "/posts/jekyll/",
    "categories": "Blogging, Jekyll",
    "tags": "jekyll, blogging, tutorial",
    "date": "2023-10-15 10:00:00 +0900",
    





    
    "snippet": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게...",
    "content": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게 글을 작성할 수 있습니다.  빠른 속도: 정적 사이트이기 때문에 로딩 속도가 빠릅니다.테스트 포스팅 작성하기이 포스팅은 Jekyll을 사용하여 작성한 테스트 포스팅입니다. Jekyll의 기본적인 사용법을 익히고, 블로그를 시작하는 데 도움이 되기를 바랍니다.1. 파일 생성먼저 _posts 디렉토리에 새로운 파일을 생성합니다. 파일명은 YYYY-MM-DD-title.md 형식으로 작성합니다.2. Front Matter 설정파일의 맨 위에 YAML 형식의 Front Matter를 추가하여 포스트의 메타데이터를 설정합니다.---title: \"Jekyll로 블로그 시작하기: 테스트 포스팅\"date: 2023-10-15 10:00:00 +0900categories: [Blogging, Jekyll]tags: [jekyll, blogging, tutorial]---3. 포스트 내용 작성Markdown을 사용하여 포스트의 내용을 작성합니다. 예를 들어, Jekyll의 장점이나 사용법에 대해 설명할 수 있습니다.결론Jekyll을 사용하면 블로그를 쉽게 시작할 수 있습니다. 이 포스팅이 Jekyll을 이해하는 데 도움이 되었기를 바랍니다. 앞으로 더 많은 포스팅을 통해 Jekyll의 다양한 기능을 탐구해보세요!"
  },
  
  {
    "title": "Kream 사이트 클론 프로젝트",
    "url": "/posts/kream_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-06 10:00:00 +0900",
    





    
    "snippet": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 ...",
    "content": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 서비스 수준으로 개발할 수 있도록 2주간 고군분투 하였습니다.프로젝트 선정이유  조사결과, 해당 사이트의 경매 입찰 기능과 결제 플로우, 차트 구현, 상품리스트 필터 구현 등 배울 점이 많다고 판단하여 선정하게 되었습니다.📅 개발 기간 및 개발 인원  개발 기간 : 2021/10/18 ~ 2021/10/29  개발 인원  👨‍👧‍👦 Front-End 4명 : 김현진, 박산성, 이선호, 하상영 👨‍👧‍👦 Back-End 3명 : 박치훈, 양가현, 송영록  Back-end github 링크🎬 프로젝트 구현 영상  🔗 [구현영상] : https://youtu.be/N63MUdDmDFI⛓️ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia⚙️ 데이터베이스 Diagram💻 구현 기능Endpoint documentation - Postman APIBACKEND  로그인 구현import jwtimport requestsfrom json.decoder import JSONDecodeErrorfrom django.http  import JsonResponsefrom django.views import Viewfrom users.models import Userfrom my_settings  import SECRET_KEY, ALGORITHMSclass KakaoLogin(View):    def get(self, request):        try:             token = request.headers.get('Authorization')            if token == None:                return JsonResponse({'messsage': 'INVALID_TOKEN'}, status=401)            kakao_account = requests.get('https://kapi.kakao.com/v2/user/me', headers = {'Authorization': f'Bearer {token}'}).json()            print('::::kakao_account:', kakao_account)            if not User.objects.filter(kakao_id=kakao_account['id']).exists():                user = User.objects.create(                    kakao_id = kakao_account['id'],                    email    = kakao_account['kakao_account']['email'],                    name     = kakao_account['kakao_account']['profile']['nickname']                )            user = User.objects.get(kakao_id=kakao_account['id'])            access_token = jwt.encode({'user_id': user.id}, SECRET_KEY, algorithm=ALGORITHMS)            return JsonResponse({'access_token': access_token}, status=201)        except KeyError:            return JsonResponse({'message': 'KEY_ERROR'}, status=400)                except JSONDecodeError:            return JsonResponse({'message': 'JSON_DECODE_ERROR'}, status=400)        except jwt.DecodeError:            return JsonResponse({'message': 'JWT_DECODE_ERROR'}, status=400)        except ConnectionError:            return JsonResponse({'message': 'CONNECTION_ERROR'}, status=400)  카카오 연동 로그인 구현  Authorization 헤더에서 카카오 엑세스 토큰을 받아옴  request.get() 함수를 통해 카카오 API 엔드포인트로 사용자 정보 요청, json 형식으로 받아옴  카카오 아이디로 사용자 조회, 없으면 새로운 유저 생성  사용자 정보에서 user모델의 id를 이용하여 jwt 토큰 발급  jwt.encode()함수에 SECRET_KEY와 ALGORITHMS를 활용하여 JWT 토큰 생성 후 반환  프론트엔드에 발상할 오류의 종류를 예외처리하여 명확히 명시  로그인 데코레이터 구현import jsonimport jwtfrom django.http  import JsonResponsefrom my_settings  import SECRET_KEY, ALGORITHMSfrom users.models import Userdef login_decorator(func):    def wrapper(self, request, *args, **kwargs):        if 'Authorization' not in request.headers :             return JsonResponse ({'message' : 'UNAUTHORIZED'}, status=401)        access_token = request.headers.get('Authorization')                try:            payload      = jwt.decode(access_token, SECRET_KEY, algorithms=ALGORITHMS)            user         = User.objects.get(id=payload['user_id'])            request.user = user        except jwt.exceptions.DecodeError:            return JsonResponse({'MESSAGE': 'INVALID_TOKEN'}, status=401)        except User.DoesNotExist:            return JsonResponse({'MESSAGE': 'INVALID_USER'}, status=401)        return func(self, request,  *args, **kwargs)    return wrapper  python decorator 활용  로그인 성공 시 토큰 발급(jwt)  로그인 실패 시 예외처리  jwt.decode() 함수를 통해 토큰 검증  디코딩한 토큰에서 user_id 추출, user모델에서 해당 user_id 조회 후 가져옴  추출한 사용자를 request.user에 저장, 이후 로그인 상태 유지  상세 페이지class DetailProductView(View) :    def get(self, request, product_id) :        try :                           buy_price_filter  = (Q(productsize__bidding__bidding_position_id = 2) &amp; Q(productsize__bidding__bidding_status_id = 1))            sell_price_filter = (Q(productsize__bidding__bidding_position_id = 1) &amp; Q(productsize__bidding__bidding_status_id = 1))            if not Product.objects.filter(id = product_id).exists():                return JsonResponse({'MESSAGE':'product_id_not_exist'}, status = 404)                        product  = Product.objects\\                                    .annotate(buy_price = Min('productsize__bidding__price', filter = buy_price_filter),                                             sell_price = Max('productsize__bidding__price', filter = sell_price_filter))\\                                    .get(id = product_id)                                                                orders   = Order.objects.\\                                    filter(bidding__product_size__product_id = product_id).\\                                    order_by('-created_at')            wishlist = len(Wishlist.objects.filter(id=product_id).all())                        product_detail = [{                                'product_id'      : product.id,                                'name'            : product.name,                                'brand_name'      : product.brand.name,                                'release_price'   : product.release_price,                                'model_number'    : product.model_number,                                'image_list'      : [image.image_url for image in product.productimage_set.all()],                                'recent_price'    : orders.first().bidding.price if orders.exists() else None,                                'buy_price'       : product.buy_price,                                'sell_price'      : product.sell_price,                                'total_wishlist'  : wishlist,                            }]            return JsonResponse({'product_detail' : product_detail}, status=200)        except AttributeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)                except TypeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)  필터 조건 정의: 구매 입찰 정보중 입찰 상태가 유효한 조건(입찰 포지션 2, 상태가 1인 경우)과 판매 입찰 정보 중 입찰 상태가 유효한 조건(입찰 포지션 1, 상태가 1인 경우)  효율적인 데이터 처리와 코드의 간결성을 위하여 annotate()함수 활용  데이터베이스 단계서 집계 함수(Min, Max)를 활용하여 필요한 값을 미리 계산    상품 리스트 출력 API(ProductView)  브랜드 리스트 출력 API(BrandView)```pythonclass BrandView(View):    def get(self, request):            brands = Brand.objects.all()        brand_list = [{                    'brand_id'   : brand.id,                    'brand_name' : brand.name,                } for brand in brands]        return JsonResponse({'brand_list' : brand_list}, status = 200) ``` - 메인 페이지, 제품 페이지 상단 브랜드 출력을 위하여 API 작성❗ Reference  이 프로젝트는 KREAM 사이트를 참조하여 학습목적으로 만들었습니다.  실무수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제될 수 있습니다.  이 프로젝트에서 사용하고 있는 사진 모두는 copyright free 사이트들의 이미지들을 취합 및 canva 에서 직접 제작한 이미지들로 제작되었습니다."
  },
  
  {
    "title": "Spao 사이트 클론 프로젝트",
    "url": "/posts/Spao_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-05 10:00:00 +0900",
    





    
    "snippet": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획...",
    "content": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획 과정 없이 짧은 기간 안에 기술 습득 및 기본 기능 구현에 집중하기 위해서 SPAO 사이트를 참고.📅 개발 기간 및 개발 인원  개발 기간 : 2021-10-05 ~ 2021-10-15 (공휴일 포함)  개발 인원  👨‍👧‍👦 Front-End 3명 : 강성구, 김현진, 정경훈  👨‍👧‍👦 Back-End 3명 : 김주현, 이기용, 송영록⚙ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia🗜 데이터베이스 Diagram(클릭 시 해당 링크로 이동합니다)💻 구현 기능BACKEND  회원가입 API  jwt와 bcrpyt를 이용한 로그인 API  장바구니 상품 추가, 수정, 삭제 API⌨ EndPoint  POST/users/signup (회원가입)  POST/users/signin (로그인)  POST/orders/cart (장바구니 생성)  GET/orders/cart (장바구니 조회)  PATCH/orders/cart (장바구니 수정)  DEL/orders/cart (장바구니 삭제)  POST/postings  (후기 등록)  POST/postings/comments (댓글 등록)  POST/postings/ (댓글 삭제)  POST/products/menus (메뉴 항목 추가)  GET/products/menus (메뉴 항목 리스트 조회)  POST/products/categories (카테고리 항목 추가)  GET/products// (특정 메뉴별 카테고리 항목 리스트 조회)  POST/products (상품 등록)  GET/products// (특정 메뉴-카테고리별 상품 리스트 조회)  GET/products/ (특정 상품에 대한 상세페이지)❗ Reference  이 프로젝트는 SPAO 사이트를 참조하여 학습목적으로 만들었습니다.  실무 수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다.🙏 help  프로젝트 상품 이미지 출처원 : MIDEOCK-미덕 , SARNO-사르노 *이미지 사용을 허가해주신 대표님들께 감사합니다.  해당 프로젝트의 이미지를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다."
  },
  
  {
    "title": "Django project 초기세팅",
    "url": "/posts/Django_Project_%EC%B4%88%EA%B8%B0%EC%84%B8%ED%8C%85/",
    "categories": "Django",
    "tags": "Django",
    "date": "2022-01-04 10:00:00 +0900",
    





    
    "snippet": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 ...",
    "content": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 후 mysql로 전환# 데이터베이스 생성mysql&gt; create database NAME character set utf8mb4 collate utf*mb4_general_ci; Project Python Package 설치$ pip install django# 이후에 MySQL server에 접속하기 위한 package$ pip install mysqlclient  (중요) mysql 설치되어 있는지 먼저 확인# 맥북은 mysqlclient를 다운받으려면 오류가 난다 그러므로 PyMySQL을 다운받자$ pip install PyMySQL#!밑글에 pymysql 세팅법을 적어놓음Django Project 생성$ django-admin startproject westarbucks$ cd westarbucksSettings.py 설정. IP허용\tALLOWED_HOSTS = ['*']. 추가로 westarbucks/urls.py를 아래와 같이 수정from django.urls import pathurlpatterns = []. 주석처리(admin, csrf, auth)my_settings.py 생성(DATABASES,SECRET_KEY). django 설정에 존재하는 내용 중 SECRET_KEY, DATABASE 등은 절대 settings.py에 두면 안됩니다.. 그대로 깃이나 오픈클라우드에 올려버리면 해킹을 당하기가 쉽습니다. 아니 당합니다!. 그래서 별도의 참조용 파이썬 파일(my_settings.py)을 생성해서, 참조하는 방법으로 진행cd '생성한 프로젝트 폴더명'touch my_settings.py. 파일에 실제 쓰여지는 내용#예시DATABASES = {    'default' : {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'DATABASE 명',        'USER': 'DB접속 계정명',        'PASSWORD': 'DB접속용 비밀번호',        'HOST': '127.0.0.1',        'PORT': '3306',    }}SECRET_KEY = '시크릿키' #settings.py에 있는 secret_key 를 사용합니다.settings.py &lt;-&gt; my_settings.py 연동#intel 맥북from pathlib\t\timport Path #기존에 settings.py에 있는 코드from my_settings\timport DATABASES, SECRET_KEYDATABASES = DATABASESSECRET_KEY = SECRET_KEY#### m1 맥북!!# $ pip install PyMySQL# 으로 PyMySQL을 다운받는거 잊지말자from pathlib        import Path #기존에 settings.py 에 있는 코드from my_settings import DATABASES, SECRET_KEYimport pymysqlpymysql.install_as_MySQLdb().corsheaderspip install django-cors-headers. 설치했다면 settings.py에 INSTALLED_APPS 안에 추가INSTALLED_APPS = [...\t\t'corsheaders']. middleware 추가MIDDLEWARE = [\t...\t\t'corsheaders.middleware.CorsMiddleware',\t...]. CORS 추가 설정##CORSCORS_ORIGIN_ALLOW_ALL=TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = (    'DELETE',    'GET',    'OPTIONS',    'PATCH',    'POST',    'PUT',)CORS_ALLOW_HEADERS = (    'accept',    'accept-encoding',    'authorization',    'content-type',    'dnt',    'origin',    'user-agent',    'x-csrftoken',    'x-requested-with',)서버 정상 동작 확인. 서버 동작(Runserver)을 통한 오류 검증python manage.py runserver. 정상 동작 예시이제 프로젝트를 위한 초기 세팅은 끝났다~프로젝트를 진행해보자!"
  }
  
]

