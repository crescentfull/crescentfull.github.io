[
  
  {
    "title": "Jekyll로 블로그 시작하기: 테스트 포스팅",
    "url": "/posts/jekyll/",
    "categories": "Blogging, Jekyll",
    "tags": "jekyll, blogging, tutorial",
    "date": "2023-10-15 10:00:00 +0900",
    





    
    "snippet": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게...",
    "content": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게 글을 작성할 수 있습니다.  빠른 속도: 정적 사이트이기 때문에 로딩 속도가 빠릅니다.테스트 포스팅 작성하기이 포스팅은 Jekyll을 사용하여 작성한 테스트 포스팅입니다. Jekyll의 기본적인 사용법을 익히고, 블로그를 시작하는 데 도움이 되기를 바랍니다.1. 파일 생성먼저 _posts 디렉토리에 새로운 파일을 생성합니다. 파일명은 YYYY-MM-DD-title.md 형식으로 작성합니다.2. Front Matter 설정파일의 맨 위에 YAML 형식의 Front Matter를 추가하여 포스트의 메타데이터를 설정합니다.---title: \"Jekyll로 블로그 시작하기: 테스트 포스팅\"date: 2023-10-15 10:00:00 +0900categories: [Blogging, Jekyll]tags: [jekyll, blogging, tutorial]---3. 포스트 내용 작성Markdown을 사용하여 포스트의 내용을 작성합니다. 예를 들어, Jekyll의 장점이나 사용법에 대해 설명할 수 있습니다.결론Jekyll을 사용하면 블로그를 쉽게 시작할 수 있습니다. 이 포스팅이 Jekyll을 이해하는 데 도움이 되었기를 바랍니다. 앞으로 더 많은 포스팅을 통해 Jekyll의 다양한 기능을 탐구해보세요!"
  },
  
  {
    "title": "힙 heap",
    "url": "/posts/Heap/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Heap",
    "date": "2022-02-08 10:00:00 +0900",
    





    
    "snippet": "힙(Heap)은 완전 이진 트리 형태의 자료구조로, 우선순위 큐(Priority Queue)와 같은 응용에 자주 사용된다. 힙은 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 나뉘며, 각각의 부모 노드는 자식 노드와 비교해 특정 조건을 만족해야 한다.힙의 종류  최대 힙 (Max Heap)          부모 노드가 자식 노드보다 항상 ...",
    "content": "힙(Heap)은 완전 이진 트리 형태의 자료구조로, 우선순위 큐(Priority Queue)와 같은 응용에 자주 사용된다. 힙은 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 나뉘며, 각각의 부모 노드는 자식 노드와 비교해 특정 조건을 만족해야 한다.힙의 종류  최대 힙 (Max Heap)          부모 노드가 자식 노드보다 항상 크거나 같은 값을 가진다.      트리의 루트 노드는 가장 큰 값을 가진다.      최대값을 빠르게 찾을 수 있으며, 삽입과 삭제 연산에서 부모 노드와 자식 노드를 비교해 위치를 조정한다.        최소 힙 (Min Heap)          부모 노드가 자식 노드보다 항상 작거나 같은 값을 가진다.      트리의 루트 노드는 가장 작은 값을 가진다.      최소값을 빠르게 찾을 수 있으며, 삽입과 삭제 시 자식 노드와 비교해 위치를 조정한다.      힙의 특성  힙은 완전 이진 트리이므로 마지막 레벨을 제외한 모든 레벨이 채워져 있으며, 마지막 레벨은 왼쪽부터 차례로 채워진다.  힙은 삽입, 삭제와 같은 연산 시에 부모 노드와 자식 노드의 값을 비교해 트리의 구조를 유지하며 균형을 맞춘다.  최대값 또는 최소값을 빠르게 찾는 데 유리하며, 시간 복잡도는 삽입, 삭제, 탐색 모두 (O(\\log n))이다.힙의 주요 연산  삽입(Insertion): 힙의 맨 끝에 새로운 노드를 삽입한 후, 부모 노드와 비교하면서 위로 올라가며 자리를 교환해 힙 속성을 유지한다.  삭제(Deletion): 최대 힙에서는 최대값, 최소 힙에서는 최소값을 삭제한다. 루트 노드를 삭제한 후 마지막 노드를 루트로 옮기고, 자식 노드와 비교해 아래로 내려가며 힙 속성을 유지한다.힙 구현 예시 (파이썬)파이썬에서는 heapq 모듈을 사용해 최소 힙을 간단하게 구현할 수 있다. 최대 힙은 heapq 모듈을 응용하여 구현한다.최소 힙 (Min Heap) 예시import heapq  # heapq 모듈을 임포트min_heap = []  # 최소 힙을 저장할 리스트 초기화# 힙에 요소 추가 (push)heapq.heappush(min_heap, 10)  # 10 삽입heapq.heappush(min_heap, 5)   # 5 삽입heapq.heappush(min_heap, 20)  # 20 삽입heapq.heappush(min_heap, 1)   # 1 삽입print(\"Min Heap:\", min_heap)  # 최소 힙 상태 출력# 힙에서 가장 작은 값 제거 (pop)min_val = heapq.heappop(min_heap)print(\"Removed Min Value:\", min_val)  # 제거한 최소 값 출력print(\"Min Heap after removal:\", min_heap)  # 갱신된 최소 힙 출력출력 결과:Min Heap: [1, 5, 20, 10]Removed Min Value: 1Min Heap after removal: [5, 10, 20]  최소 힙에서는 heapq 모듈이 자동으로 리스트의 첫 번째 요소를 최소값으로 유지하도록 한다.  삽입(heappush)과 삭제(heappop) 연산을 통해 최소 힙의 성질을 유지한다.최대 힙 (Max Heap) 예시최대 힙은 heapq 모듈을 이용해 최소 힙을 응용하여 구현할 수 있다. 음수로 변환하여 삽입한 후, 값을 꺼낼 때 다시 음수를 취해 원래 값을 복원한다.max_heap = []  # 최대 힙을 저장할 리스트 초기화# 힙에 요소 추가 (push) - 음수로 변환하여 삽입heapq.heappush(max_heap, -10)  # 10 삽입 (음수로 변환)heapq.heappush(max_heap, -5)   # 5 삽입 (음수로 변환)heapq.heappush(max_heap, -20)  # 20 삽입 (음수로 변환)heapq.heappush(max_heap, -1)   # 1 삽입 (음수로 변환)print(\"Max Heap:\", [-x for x in max_heap])  # 최대 힙 상태 출력 (음수로 변환한 값을 다시 양수로)# 힙에서 가장 큰 값 제거 (pop) - 꺼낸 후 양수로 변환max_val = -heapq.heappop(max_heap)print(\"Removed Max Value:\", max_val)  # 제거한 최대 값 출력print(\"Max Heap after removal:\", [-x for x in max_heap])  # 갱신된 최대 힙 출력출력 결과:Max Heap: [20, 10, 5, 1]Removed Max Value: 20Max Heap after removal: [10, 1, 5]힙의 활용 예시  우선순위 큐(Priority Queue): 우선순위가 높은 요소를 먼저 처리해야 하는 경우, 힙을 사용해 효율적으로 구현할 수 있다.  다익스트라 알고리즘: 그래프에서 최단 경로를 찾는 다익스트라 알고리즘에서 우선순위 큐로 최소 힙이 사용된다.  힙 정렬(Heap Sort): 최대 힙이나 최소 힙을 이용해 데이터를 정렬하는 알고리즘이다.  이벤트 처리 시스템: 이벤트 발생 시간이 빠른 순서대로 처리해야 할 경우, 힙을 사용해 이벤트를 관리할 수 있다.힙은 이러한 다양한 상황에서 중요한 값(최대값 또는 최소값)을 빠르게 찾고 관리할 수 있도록 돕는 자료구조이다."
  },
  
  {
    "title": "Graph 그래프",
    "url": "/posts/Graph/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Graph",
    "date": "2022-02-06 10:00:00 +0900",
    





    
    "snippet": "그래프(Graph)는 정점(Vertex)와 간선(Edge)으로 이루어진 자료구조로, 정점 간의 관계를 나타내는 데 사용된다. 그래프는 복잡한 관계나 연결을 표현하는 데 적합하며, 특히 네트워크, 소셜 미디어 연결, 경로 탐색 등의 문제를 해결할 때 유용하다.그래프의 구성 요소  정점(Vertex): 그래프의 각 점으로, 데이터가 저장되는 단위이다. 정...",
    "content": "그래프(Graph)는 정점(Vertex)와 간선(Edge)으로 이루어진 자료구조로, 정점 간의 관계를 나타내는 데 사용된다. 그래프는 복잡한 관계나 연결을 표현하는 데 적합하며, 특히 네트워크, 소셜 미디어 연결, 경로 탐색 등의 문제를 해결할 때 유용하다.그래프의 구성 요소  정점(Vertex): 그래프의 각 점으로, 데이터가 저장되는 단위이다. 정점은 노드(Node)라고도 한다.  간선(Edge): 정점 간의 연결을 나타내며, 두 정점 사이의 관계를 정의한다.그래프의 종류  무방향 그래프 (Undirected Graph): 간선에 방향이 없는 그래프이다. 정점 A와 B가 연결되어 있다면 A에서 B로, B에서 A로 모두 이동할 수 있다.  방향 그래프 (Directed Graph): 간선에 방향이 있는 그래프로, 한 방향으로만 이동 가능하다. A에서 B로 연결된 경우, B에서 A로는 이동할 수 없을 수도 있다.  가중치 그래프 (Weighted Graph): 간선에 가중치(비용)가 부여된 그래프이다. 예를 들어, 지도에서 도시 간의 거리를 가중치로 설정할 수 있다.  사이클 그래프 (Cyclic Graph)와 비순환 그래프 (Acyclic Graph): 사이클이 있는 그래프는 어떤 정점에서 시작하여 다시 해당 정점으로 돌아올 수 있는 경로가 존재하는 그래프이며, 비순환 그래프는 그런 경로가 없는 그래프이다.그래프의 표현 방법  인접 행렬 (Adjacency Matrix): 그래프를 2차원 배열로 표현하며, 배열의 요소가 간선의 존재 여부를 나타낸다. 주로 간선이 많은 밀집 그래프(Dense Graph)에서 유리하다.  인접 리스트 (Adjacency List): 각 정점에 연결된 정점 목록을 리스트 형태로 표현한다. 간선이 적은 희소 그래프(Sparse Graph)에서 메모리 효율이 좋다.예제: 인접 리스트로 무방향 그래프 표현class Graph:    def __init__(self):        # 그래프를 인접 리스트로 표현하기 위한 딕셔너리 초기화        self.graph = {}    def add_edge(self, vertex, neighbor):        # vertex가 그래프에 없으면, 빈 리스트로 초기화하여 추가        if vertex not in self.graph:            self.graph[vertex] = []                # neighbor가 그래프에 없으면, 빈 리스트로 초기화하여 추가        if neighbor not in self.graph:            self.graph[neighbor] = []                # 무방향 그래프이므로 양방향 간선을 추가 (vertex에서 neighbor로)        self.graph[vertex].append(neighbor)                # 무방향 그래프이므로 양방향 간선을 추가 (neighbor에서 vertex로)        self.graph[neighbor].append(vertex)    def display(self):        # 그래프의 각 정점과 연결된 정점들을 출력        for vertex in self.graph:            print(f\"{vertex}: {self.graph[vertex]}\")# 그래프 객체 생성g = Graph()# 각 정점과 간선을 추가하여 그래프 구조 형성g.add_edge('A', 'B')  # 정점 'A'와 'B' 사이에 간선 추가g.add_edge('A', 'C')  # 정점 'A'와 'C' 사이에 간선 추가g.add_edge('B', 'D')  # 정점 'B'와 'D' 사이에 간선 추가g.add_edge('C', 'D')  # 정점 'C'와 'D' 사이에 간선 추가g.add_edge('D', 'E')  # 정점 'D'와 'E' 사이에 간선 추가# 그래프 구조를 출력print(\"그래프 구조:\")g.display()출력 결과:그래프 구조:A: ['B', 'C']B: ['A', 'D']C: ['A', 'D']D: ['B', 'C', 'E']E: ['D']그래프 탐색 알고리즘그래프에서는 탐색 알고리즘을 통해 정점을 방문하고 특정 조건에 맞는 경로를 찾을 수 있다. 주요 탐색 방법에는 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)이 있다.1. 너비 우선 탐색 (BFS)BFS는 시작 정점에서 가까운 정점부터 차례대로 방문하는 방식이다. 주로 큐(Queue) 자료구조를 사용하여 구현한다. 최단 경로 문제에 유용하다.from collections import deque  # 큐(Queue)를 사용하기 위해 deque를 임포트def bfs(graph, start):    visited = set()  # 방문한 정점을 저장할 집합 초기화    queue = deque([start])  # 탐색을 위한 큐 초기화, 시작 정점을 큐에 추가    while queue:        vertex = queue.popleft()  # 큐에서 가장 앞에 있는 정점을 꺼냄        if vertex not in visited:  # 꺼낸 정점을 아직 방문하지 않았다면            print(vertex, end=\" \")  # 정점을 출력(방문 순서 확인)            visited.add(vertex)  # 정점을 방문한 것으로 표시            # 현재 정점에 인접한 모든 정점을 큐에 추가 (방문하지 않은 정점만 추가)            queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)# 그래프 예제graph = {    'A': ['B', 'C'],    'B': ['A', 'D', 'E'],    'C': ['A', 'F'],    'D': ['B'],    'E': ['B', 'F'],    'F': ['C', 'E']}print(\"BFS 탐색 결과:\")bfs(graph, 'A')출력:BFS 탐색 결과:A B C D E F  BFS는 시작 정점(A)에서 가까운 정점(B, C)부터 차례대로 방문하며, 큐를 사용하여 방문할 정점들을 순차적으로 관리한다.2. 깊이 우선 탐색 (DFS)DFS는 시작 정점에서 최대한 깊숙이 들어간 후, 더 이상 갈 곳이 없으면 되돌아와 다른 경로를 탐색하는 방식이다. 스택이나 재귀를 사용해 구현할 수 있다.def dfs(graph, start, visited=None):    if visited is None:        visited = set()  # 방문한 정점을 저장할 집합 초기화    print(start, end=\" \")  # 시작 정점을 출력(방문 순서 확인)    visited.add(start)  # 시작 정점을 방문한 것으로 표시    for neighbor in graph[start]:  # 시작 정점에 인접한 모든 정점을 순회        if neighbor not in visited:  # 인접 정점이 방문되지 않았다면            dfs(graph, neighbor, visited)  # 인접 정점으로 DFS 재귀 호출print(\"\\nDFS 탐색 결과:\")dfs(graph, 'A')출력:DFS 탐색 결과:A B D E F C  DFS는 시작 정점(A)에서 가능한 한 경로를 따라 깊이 탐색하며, 방문하지 않은 정점으로 이동한다. 재귀 호출을 통해 방문 경로를 추적하고, 모든 정점을 탐색한다.그래프의 활용 예시  네트워크 연결: 네트워크의 컴퓨터들이 연결되어 있는지 확인하고 경로를 탐색하는 데 사용된다.  소셜 네트워크: 사용자 간의 친구 관계를 그래프로 표현하여 친구 추천, 관계 탐색 등을 구현할 수 있다.  경로 찾기: 지도에서 두 지점 간의 최단 경로나 최적 경로를 찾는 데 그래프를 사용한다.  웹 크롤링: 웹 페이지를 노드로, 하이퍼링크를 간선으로 연결하여 탐색하는 데 활용된다."
  },
  
  {
    "title": "Tree 트리(2)",
    "url": "/posts/Tree(2)/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Tree",
    "date": "2022-02-05 12:00:00 +0900",
    





    
    "snippet": "1. 이진 트리 (Binary Tree)이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조이다. 자식 노드는 왼쪽과 오른쪽으로 구분되며, 주로 계층적 데이터 표현이나 간단한 탐색 트리에 사용된다.class BinaryTreeNode:    def __init__(self, key):        self.key = key        sel...",
    "content": "1. 이진 트리 (Binary Tree)이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조이다. 자식 노드는 왼쪽과 오른쪽으로 구분되며, 주로 계층적 데이터 표현이나 간단한 탐색 트리에 사용된다.class BinaryTreeNode:    def __init__(self, key):        self.key = key        self.left = None        self.right = None# 이진 트리 생성 예시root = BinaryTreeNode(1)root.left = BinaryTreeNode(2)root.right = BinaryTreeNode(3)root.left.left = BinaryTreeNode(4)root.left.right = BinaryTreeNode(5)print(\"Binary Tree Root:\", root.key)  # 결과: 12. 이진 탐색 트리 (Binary Search Tree, BST)이진 탐색 트리는 이진 트리의 특수한 형태로, 각 노드의 왼쪽 서브트리에는 부모 노드보다 작은 값들이, 오른쪽 서브트리에는 더 큰 값들이 저장되는 구조이다. 이 특성 덕분에 빠른 검색이 가능하다.class BSTNode:    def __init__(self, key):        self.key = key        self.left = None        self.right = Noneclass BinarySearchTree:    def __init__(self):        self.root = None    def insert(self, key):        if self.root is None:            self.root = BSTNode(key)        else:            self._insert(self.root, key)    def _insert(self, node, key):        if key &lt; node.key:            if node.left is None:                node.left = BSTNode(key)            else:                self._insert(node.left, key)        else:            if node.right is None:                node.right = BSTNode(key)            else:                self._insert(node.right, key)# BST 생성 예시bst = BinarySearchTree()bst.insert(10)bst.insert(5)bst.insert(15)bst.insert(7)print(\"BST Root:\", bst.root.key)  # 결과: 103. 힙 (Heap)힙은 완전 이진 트리 구조로 최대 힙과 최소 힙으로 구분된다. 최대 힙에서는 부모 노드가 자식 노드보다 크고, 최소 힙에서는 부모 노드가 자식 노드보다 작다. 힙은 우선순위 큐와 같은 자료구조를 구현할 때 유용하다.import heapq# Min-Heap 예시min_heap = []heapq.heappush(min_heap, 10)heapq.heappush(min_heap, 5)heapq.heappush(min_heap, 20)print(\"Min Heap:\", min_heap)  # 결과: [5, 10, 20]# Max-Heap 예시 (음수로 변환하여 사용)max_heap = []heapq.heappush(max_heap, -10)heapq.heappush(max_heap, -5)heapq.heappush(max_heap, -20)print(\"Max Heap:\", [-x for x in max_heap])  # 결과: [20, 10, 5]4. 트라이 (Trie)트라이는 문자열 검색에 최적화된 트리이다. 문자열의 각 문자마다 노드를 생성하여 접두사를 빠르게 검색할 수 있다. 검색 엔진, 사전 등에서 문자열 검색이나 자동 완성 기능에 자주 사용된다.class TrieNode:    def __init__(self):        self.children = {}        self.is_end_of_word = Falseclass Trie:    def __init__(self):        self.root = TrieNode()    def insert(self, word):        node = self.root        for char in word:            if char not in node.children:                node.children[char] = TrieNode()            node = node.children[char]        node.is_end_of_word = True    def search(self, word):        node = self.root        for char in word:            if char not in node.children:                return False            node = node.children[char]        return node.is_end_of_word# Trie 사용 예시trie = Trie()trie.insert(\"hello\")print(\"Search 'hello':\", trie.search(\"hello\"))  # 결과: Trueprint(\"Search 'world':\", trie.search(\"world\"))  # 결과: False5. AVL 트리AVL 트리는 균형을 유지하는 이진 탐색 트리(BST)의 한 종류로, 높이 균형 트리라고도 한다. AVL 트리는 트리의 각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1을 넘지 않도록 한다. 만약 삽입이나 삭제 연산 중 이 균형이 깨진다면, 트리 회전(Rotation) 연산을 통해 균형을 복구한다.  이름 유래: AVL 트리는 두 발명가 Adelson-Velsky와 Landis의 이름을 따서 지어졌다.  주요 특징:          이진 탐색 트리의 속성을 가지면서 균형을 유지한다.      삽입 및 삭제 연산 후 높이 균형을 맞추기 위해 회전 연산을 수행한다.      탐색, 삽입, 삭제의 시간 복잡도는 모두 (O(\\log n))이다.      AVL 트리의 회전(Rotation)AVL 트리는 불균형이 발생했을 때 트리의 균형을 맞추기 위해 회전 연산을 수행한다. 회전에는 단일 회전(Single Rotation)과 이중 회전(Double Rotation)이 있으며, 삽입된 위치에 따라 회전 방식이 달라진다.  LL 회전 (Left-Left): 왼쪽 자식의 왼쪽 서브트리에 삽입되었을 때 불균형 해소를 위해 오른쪽으로 회전.  RR 회전 (Right-Right): 오른쪽 자식의 오른쪽 서브트리에 삽입되었을 때 불균형 해소를 위해 왼쪽으로 회전.  LR 회전 (Left-Right): 왼쪽 자식의 오른쪽 서브트리에 삽입되었을 때, 좌-우 방향으로 이중 회전을 수행.  RL 회전 (Right-Left): 오른쪽 자식의 왼쪽 서브트리에 삽입되었을 때, 우-좌 방향으로 이중 회전을 수행.  AVL 트리의 회전 연산은 구현이 복잡하여 코드로 나타내기 어렵지만, AVL 트리는 회전을 통해 항상 트리의 균형을 유지하도록 한다.AVL 트리의 활용AVL 트리는 데이터가 빈번히 삽입되고 삭제되는 상황에서 균형을 유지하면서 효율적인 검색을 제공하는 데 유리하다. 특히, 빠른 데이터 접근이 필요한 경우 효율적으로 사용될 수 있다.6. B-트리B-트리는 균형을 유지하는 다중 자식 트리(Multi-way Tree)의 일종으로, 대용량 데이터를 효율적으로 저장하고 탐색할 수 있도록 설계된 트리 자료구조이다. 주로 데이터베이스와 파일 시스템에 사용되며, 노드 하나에 여러 키를 저장하고 자식 노드도 여러 개 가질 수 있다. B-트리는 대개 디스크 기반 시스템에서 성능을 극대화하기 위해 설계되었다.  특징:          각 노드에 여러 개의 키와 자식 노드를 가질 수 있다.      B-트리는 항상 균형을 유지하며, 모든 리프 노드가 같은 높이를 유지한다.      검색, 삽입, 삭제 연산의 시간 복잡도는 (O(\\log n))이다.      B-트리의 구조B-트리는 차수(Order)라는 속성을 가지며, 트리의 각 노드는 최대 차수만큼의 자식 노드와 키를 가질 수 있다. 예를 들어, 차수 3인 B-트리는 한 노드에 최대 2개의 키와 3개의 자식 노드를 가질 수 있다. 새 노드를 삽입할 때 노드가 차수 이상으로 가득 차게 되면 분할(Split) 연산을 수행하여 트리를 균형 상태로 유지한다.  삽입과 분할: 노드가 가득 차면 노드를 분할하여 부모 노드에 새로운 노드를 생성하고, 키를 상위 노드로 올린다.  삭제와 병합: 노드의 키가 너무 적어질 경우, 형제 노드에서 키를 빌리거나 병합하여 균형을 유지한다.B+ 트리B+ 트리는 B-트리의 변형으로, 모든 키가 리프 노드에 저장되고 리프 노드가 순서대로 연결된 구조이다. B+ 트리는 B-트리보다 범위 검색이 더 효율적이다. 데이터베이스 인덱스에서 흔히 사용된다.B-트리의 활용B-트리는 대용량 데이터베이스에서 인덱싱을 효율적으로 수행하는 데 적합하다. 특히, 디스크 접근이 많은 경우 B-트리는 한 번의 접근으로 더 많은 데이터를 불러올 수 있어 성능이 높다. 데이터베이스 관리 시스템, 파일 시스템의 인덱스 등에 자주 사용된다.AVL 트리와 B-트리는 모두 효율적인 검색과 균형 유지에 유리한 트리 구조이지만, 활용되는 환경과 목적이 다르다. AVL 트리는 메모리 내 자료 관리에 적합하고, B-트리는 디스크 기반 대용량 데이터 관리에서 최적의 성능을 발휘하도록 설계된 트리 구조이다."
  },
  
  {
    "title": "Tree 트리",
    "url": "/posts/Tree/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Tree",
    "date": "2022-02-05 10:00:00 +0900",
    





    
    "snippet": "Tree트리는 계층 구조를 표현하는 비선형 자료구조이다.트리는 루트 노드에서 시작해 여러 개의 자식 노드를 가질 수 있으며, 트리의 각 노드는 자식 노드와 연결될 수 있다. 부모-자식 관계로 구성되어 계층적인 데이터를 표현할 때 유용하며, 특히 이진 트리(Binary Tree) 형태가 많이 사용된다.트리의 주요 개념  루트 노드(Root Node): ...",
    "content": "Tree트리는 계층 구조를 표현하는 비선형 자료구조이다.트리는 루트 노드에서 시작해 여러 개의 자식 노드를 가질 수 있으며, 트리의 각 노드는 자식 노드와 연결될 수 있다. 부모-자식 관계로 구성되어 계층적인 데이터를 표현할 때 유용하며, 특히 이진 트리(Binary Tree) 형태가 많이 사용된다.트리의 주요 개념  루트 노드(Root Node): 트리의 최상단 노드.  자식 노드(Child Node): 다른 노드로부터 연결된 하위 노드.  부모 노드(Parent Node): 자식 노드를 가진 노드.  잎(Leaf): 자식 노드가 없는 노드.  트리의 가장 일반적인 형태인 이진 트리는 각 노드가 최대 두 개의 자식을 가지는 구조트리 구현 예시# 노드를 나타내는 클래스class Node:    def __init__(self, value):        self.value = value  # 노드의 값        self.left = None    # 왼쪽 자식 노드        self.right = None   # 오른쪽 자식 노드# 이진 트리를 생성하는 함수def create_binary_tree():    # 루트 노드 생성    root = Node(1)        # 레벨 1의 자식 노드 추가    root.left = Node(2)    root.right = Node(3)        # 레벨 2의 자식 노드 추가    root.left.left = Node(4)    root.left.right = Node(5)    root.right.left = Node(6)    root.right.right = Node(7)        return root위의 코드는 다음과 같은 형태의 트리를 만든다.       1     /   \\    2     3   / \\   / \\  4   5 6   7  노드 1은 루트 노드  노드 2와 3은 1의 자식 노드  노드 4, 5, 6, 7은 잎 노드로, 자식이 없다.트리 순회(Tree Traversal)트리 순회는 트리 구조의 모든 노드를 방문하는 방법이다. 순회 방식에는 주로 전위 순회(Pre-order), 중위 순회(In-order), 후위 순회(Post-order)가 있다.1. 전위 순회 (Pre-order)전위 순회는 루트 -&gt; 왼쪽 -&gt; 오른쪽 순으로 방문한다.def pre_order(node):    if node:        print(node.value, end=\" \")  # 현재 노드 방문        pre_order(node.left)       # 왼쪽 서브트리 순회        pre_order(node.right)      # 오른쪽 서브트리 순회# 사용 예시root = create_binary_tree()print(\"전위 순회 결과:\")pre_order(root)  # 결과: 1 2 4 5 3 6 72. 중위 순회 (In-order)중위 순회는 왼쪽 -&gt; 루트 -&gt; 오른쪽 순으로 방문한다.def in_order(node):    if node:        in_order(node.left)        # 왼쪽 서브트리 순회        print(node.value, end=\" \")  # 현재 노드 방문        in_order(node.right)       # 오른쪽 서브트리 순회print(\"\\n중위 순회 결과:\")in_order(root)  # 결과: 4 2 5 1 6 3 73. 후위 순회 (Post-order)후위 순회는 왼쪽 -&gt; 오른쪽 -&gt; 루트 순으로 방문한다.def post_order(node):    if node:        post_order(node.left)      # 왼쪽 서브트리 순회        post_order(node.right)     # 오른쪽 서브트리 순회        print(node.value, end=\" \")  # 현재 노드 방문print(\"\\n후위 순회 결과:\")post_order(root)  # 결과: 4 5 2 6 7 3 1설명  전위 순회: 노드의 방문 순서가 루트에서 시작하므로, 트리의 구조를 출력하거나 저장할 때 유용하다.  중위 순회: 이진 탐색 트리(BST)에서 중위 순회를 사용하면 모든 노드를 오름차순으로 정렬된 순서로 방문할 수 있다.  후위 순회: 서브트리의 모든 노드를 방문한 후 부모 노드를 방문하므로, 하위 노드를 먼저 처리해야 하는 경우 유용하다.게임 스킬 트리 코드 구현RPG 게임의 스킬 트리RPG 게임에서는 캐릭터가 특정 스킬을 배우거나 업그레이드할 때, 특정 조건이 충족되어야 하는 경우가 많이 있다.예를 들어, 기본 스킬을 먼저 습득해야 고급 스킬을 배울 수 있는 구조이다. 이를 트리 구조로 표현하면 각 스킬은 노드가 되고, 부모-자식 관계로 스킬들이 계층적으로 연결된다.스킬 트리 구조와 코드 예시class SkillNode:    def __init__(self, name, level_required, description):        self.name = name                   # 스킬 이름        self.level_required = level_required  # 스킬 습득에 필요한 레벨        self.description = description     # 스킬 설명        self.children = []                 # 하위 스킬 목록    # 자식 노드(하위 스킬) 추가    def add_child(self, child):        self.children.append(child)    # 스킬 정보를 출력하는 메소드    def display(self, level=0):        indent = \" \" * (level * 4)        print(f\"{indent}- {self.name} (레벨 {self.level_required} 이상 필요): {self.description}\")        for child in self.children:            child.display(level + 1)# 스킬 트리 생성 함수def create_skill_tree():    # 기본 스킬    root = SkillNode(\"기본 공격\", 1, \"일반 공격으로 적에게 피해를 줍니다.\")        # 1레벨 스킬    skill1 = SkillNode(\"파워 스트라이크\", 2, \"강력한 공격으로 추가 피해를 줍니다.\")    skill2 = SkillNode(\"방어 자세\", 2, \"방어력을 일시적으로 증가시킵니다.\")        # 2레벨 스킬    skill1_1 = SkillNode(\"폭발 스트라이크\", 4, \"더 큰 피해를 주는 강력한 공격.\")    skill2_1 = SkillNode(\"철벽 방어\", 4, \"방어력을 크게 증가시킵니다.\")    # 스킬 트리 구축    root.add_child(skill1)    root.add_child(skill2)    skill1.add_child(skill1_1)    skill2.add_child(skill2_1)        return root위의 코드에서 SkillNode 클래스는 각 스킬을 표현한다. 각 스킬은 이름, 요구 레벨, 설명, 그리고 하위 스킬들을 가질 수 있다. create_skill_tree() 함수는 간단한 스킬 트리를 생성하고 트리 구조를 반환한다.스킬 트리 출력이제 만들어진 스킬 트리를 출력해 보겠다. display() 메소드를 호출하여 트리 구조를 계층적으로 표현할 수 있다.# 스킬 트리 생성 및 출력skill_tree = create_skill_tree()print(\"스킬 트리:\")skill_tree.display()출력 결과는 다음과 같은 계층 구조를 가진다.스킬 트리:- 기본 공격 (레벨 1 이상 필요): 일반 공격으로 적에게 피해를 줍니다.    - 파워 스트라이크 (레벨 2 이상 필요): 강력한 공격으로 추가 피해를 줍니다.        - 폭발 스트라이크 (레벨 4 이상 필요): 더 큰 피해를 주는 강력한 공격.    - 방어 자세 (레벨 2 이상 필요): 방어력을 일시적으로 증가시킵니다.        - 철벽 방어 (레벨 4 이상 필요): 방어력을 크게 증가시킵니다.설명  기본 공격을 배우면 파워 스트라이크와 방어 자세라는 새로운 스킬을 배울 수 있다.  파워 스트라이크를 배운 후에는 더 강력한 폭발 스트라이크를 배울 수 있고, 방어 자세를 배우면 철벽 방어 스킬을 사용할 수 있다.  각 스킬은 특정 레벨 이상일 때 배울 수 있도록 설정되어 있으며, 이처럼 특정 조건을 가지는 트리 구조를 통해 계층적인 스킬 습득 과정을 쉽게 관리할 수 있다."
  },
  
  {
    "title": "Hash 테이블",
    "url": "/posts/%ED%95%B4%EC%89%AC%ED%85%8C%EC%9D%B4%EB%B8%94/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Hash Table",
    "date": "2022-02-03 10:00:00 +0900",
    





    
    "snippet": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열...",
    "content": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열(Array)의 비교해보자.예를 들어 레스토랑의 메뉴를 배열에 저장한다면?menu = [\t{ name: \"coffee\",price: 10},\t{ name: \"burger\",price: 15},    \t{ name: \"tea\",price: 15}    ]이 중에서 tea의 값을 알고 싶다면 linear Search(선형검색)을 통해서 순차적으로 찾을 것이다. =&gt; 시간이 많이 걸린다!순차적으로 하나하나 쓰고 싶지 않을때 어떻게 써야할까?같은 메뉴를 해쉬테이블로 만들어보자menu = \t{ \tcoffee : 10,\tburger : 15,    \ttea : 15    ]이 경우 tea를 알고 싶으면 tea = key가 될것이고 hash tables는 가격을 Value로 제공한다.시간 복잡도를 비교해 본다면?처음 했던 방법은 O(N)이라 할 수 있다. Linear Time(선형 시간)아이템이 많을수록 찾는 시간도 오래 걸린다.그렇다면 해쉬테이블은? O(1) 즉, Constant Time(상수 시간)이다.해쉬테이블에서 어떤 값을 찾더라도 소요되는 건 오직 하나의 단계이기 때문에 배열에 비해서 굉장히 빠르다. 삭제 했을때도 마찬가지이다.value만 쓰고 싶다면?conturies = [\t\t\"🇬🇷\",\t\t\"🇬🇱\",\t\t\"🇬🇳\",\t\t\"🇳🇦\",\t\t\"🇳🇷\",\t\t\"🇦🇶\"\t]key 값이 없는데 어떻게 찾냐?conturies = {\t\t\"🇬🇷\": true,\t\t\"🇬🇱\": true,\t\t\"🇬🇳\": true,\t\t\"🇳🇦\": true,\t\t\"🇳🇷\": true,\t\t\"🇦🇶\": true\t}   #key가 국기가 되고, value는 그저 true 이다..!이렇게 되면 한 스텝만에 원하는 값을 찾을수(검색) 있다.해쉬테이블은 어떻게 작동하고 왜 “Hash”테이블이라고 할까?Hash Tables에는 array 구조가 있다.인덱스 값을 던져 주었을 때 key의 value값을 찾게 해주는 방법은 무엇이 있을까? 바로 Hash function(해시 함수)가 그것을 가능하게 해준다.key_2의 값이 해시 함수를 지나면서 index가 0인 값을 자동으로 찾아주게 된다. 조금 더 쉽게 가보자pizza의 알파벳 숫자를 5라고 했을 때 해시함수는 인덱스 5를 찾는다고 가정한다면 인덱스가 5번인 곳에 10을 넣어준다.cake는 알파벳이 4이기 때문에 4에 value값을 넣어준다. 그런데 taco도 4이기 때문에 오류가 일어나는데 이것을 Hash Collision(해시 충돌)라고 한다.이를 해결하기 위한 하나의 방법은 인덱스 4의 값에 cake와 taco 두개의 값을  가지고 있는 list를 만드는 것이다.따라서 우리는 Hash Tables에 cake가격을 물으면, Cake = key라는 해시함수에 넣고 이는 ‘4’라는 숫자를 줄 것이고, 리스트의 4로 이동하여 선형검색을 할 것이다.  바로 이러한 이유 때문에 Hash Table은 언제나 상수 시간(0(1))은 아니다.!왜냐하면 충돌이 있을 수 있고, 그 경우 선형검색을 해야하기 때문이다.참고 자료 : 노마드코더 유튜브"
  },
  
  {
    "title": "연결리스트, 근데 포인터를 곁들인",
    "url": "/posts/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%A5%BC_%EA%B3%81%EB%93%A4%EC%9D%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Linked List, Pointer",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 ...",
    "content": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 개념이 없다.class Node:    def __init__(self, data):        self.data = data        self.next = None        # 파이썬에서 노드는 위와같이 구현하였다. # 위 구조에서 현재 노드에서 다음 노드를 어떻게 참조 시킬 수 있을까?head = Node(5)next_node = Node(12)head.next = next_node# 위와같이 구현하여 참조시킬 수 있다. # 이제 위와같이 노드를 생성하고 관리하는 클래스를 구현하여 사용할 것이다.출처 : 링크포인터로 연결 리스트 만들기연결 리스트에 데이터를 삽일할 때 노드용 인스턴스를 생성하고, 데이터를 삭제할 때 노드용 인스턴스를 없애면 앞에서 제시한 데이터를 옮기는 문제를 해결할 수 있다.      Node : 데이터와 다음 데이터를 가리키는 주소(포인터)로 이루어져 있다.        Pointer : 각 노드에서 다음 데이터를 가리키는 주소값을 가진다.        Head : 링크드리스트에서 가장 시작점인 데이터를 의미한다.        Tail : 링크드리스트에서 가장 마지막 데이터를 의미        Next=None(또는 Null) : 다음 데이터가 없을 경우 포인터의 주소값은 None(또는 Null)이다.  출처: https://ybworld.tistory.com/85 [투손플레이스]링크드 리스트 만들기  노드 생성    class Node: \"\"\"연결 리스트용 노드 클래스\"\"\" def __init__(self, data: Any = None, next: Node = None):     \"\"\"초기화\"\"\"     self.data = data  # 데이터     self.next = next  # 뒤쪽 포인터            Node 연결리스트 클래스 생성```pythonclass LinkedList: “\"”연결 리스트 클래스”””    def init(self) -&gt; None:     “\"”초기화”””     self.no = 0          # 노드의 개수     self.head = None     # 머리 노드     self.current = None  # 주목 노드    def len(self) -&gt; int:     “\"”연결 리스트의 노드 개수를 반환”””     return self.no  3. search() / 검색에 성공하면 발견할 수 있는 노드```pythondef search(self, data: Any) -&gt; int:        \"\"\"data와 값이 같은 노드를 검색\"\"\"        cnt = 0        ptr = self.head        while ptr is not None:            if ptr.data == data:                self.current = ptr                return cnt            cnt += 1            ptr = ptr.next        return -1    def __contains__(self, data: Any) -&gt; bool:        \"\"\"연결 리스트에 data가 포함되어 있는가?\"\"\"        return self.search(data) &gt;= 0  add_first() / 삽입한 머리 노드     def add_first(self, data: Any) -&gt; None:     \"\"\"맨 앞에 노드를 삽입\"\"\"     ptr = self.head  # 삽입 전의 머리 노드     self.head = self.current = Node(data, ptr)     self.no += 1        add_last() / 삽입한 꼬리 노드     def add_last(self, data: Any):     \"\"\"맨 끝에 노드를 삽입\"\"\"     if self.head is None :    # 리스트가 비어 있으면         self.add_first(data)  # 맨앞에 노드 삽입     else:         ptr = self.head         while ptr.next is not None:             ptr = ptr.next  # while문을 종료할 때 ptr은 꼬리 노드를 참조         ptr.next = self.current = Node(data, None)         self.no += 1        remove_first() / 삭제한 뒤 머리노드(리스트가 비어 있으면 None)     def remove_first(self) -&gt; None:     \"\"\"머리 노드를 삭제\"\"\"     if self.head is not None:  # 리스트가 비어 있으면         self.head = self.current = self.head.next     self.no -= 1        remove_last() / 삭제한 뒤 꼬리녿(리스트가 비어 있으면 None)     def remove_last(self):     \"\"\"꼬리 노드 삭제\"\"\"     if self.head is not None:         if self.head.next is None :  # 노드가 1개 뿐이라면             self.remove_first()      # 머리 노드를 삭제         else:             ptr = self.head  # 스캔 중인 노드             pre = self.head  # 스캔 중인 노드의 앞쪽 노드             while ptr.next is not None:                 pre = ptr                 ptr = ptr.next # while문 종료시 ptr은 꼬리 노드를 참조하고 pre는 맨끝에서 두 번째 노드를 참조             pre.next = None  # pre는 삭제 뒤 꼬리 노드             self.current = pre             self.no -= 1        remove() / 삭제한 노드의 앞쪽 노드    def remove(self, p: Node) -&gt; None:     \"\"\"노드 p를 삭제\"\"\"     if self.head is not None:         if p is self.head:       # p가 머리 ​​노드이면             self.remove_first()  # 머리 노드를 삭제         else:             ptr = self.head             while ptr.next is not p:                 ptr = ptr.next                 if ptr is None:                     return  # ptr은 리스트에 존재하지 않음             ptr.next = p.next             self.current = ptr             self.no -= 1        remove_current_node() / 삭제한 노드의 앞쪽 노드     def remove_current_node(self) -&gt; None:     \"\"\"주목 노드를 삭제\"\"\"     self.remove(self.current)        clear()    def clear(self) -&gt; None:    \"\"\"전체 노드를 삭제\"\"\"    while self.head is not None:  # 전체가 비어 있게 될 때까지        self.remove_first()       # 머리 노드를 삭제    self.current = None    self.no = 0        next()    def next(self) -&gt; bool:    \"\"\"주목 노드를 한 칸 뒤로 진행\"\"\"    if self.current is None or self.current.next is None:        return False  # 진행할 수 없음    self.current = self.current.next    return True        print_current_node() &amp; print()    def print_current_node(self) -&gt; None:    \"\"\"주목 노드를 출력\"\"\"    if self.current is None:        print('주목 노드가 존재하지 않습니다.')    else:        print(self.current.data)def print(self) -&gt; None:    \"\"\"모든 노드를 출력\"\"\"    ptr = self.head    while ptr is not None:        print(ptr.data)        ptr = ptr.next      다른 예시코드class Node:    def __init__(self, data):        self.data = data        self.next = None    def __str__(self):        return str(self.data)class SingleLinkedList:    def __init__(self, data):        new_node = Node(data)        self.head = new_node        self.list_size = 1    def __str__(self):        print_list = '[ '        node = self.head        while True:            print_list += str(node)            if node.next == None:                break            node = node.next            print_list += ', '        print_list += ' ]'        return print_list    def insertFirst(self, data):        new_node = Node(data)        temp_node = self.head        self.head = new_node        self.head.next = temp_node        self.list_size += 1    def insertMiddle(self, num, data):        if self.head.next == None:            insertLast(data)            return        node = self.selectNode(num)        new_node = Node(data)        temp_next = node.next        node.next = new_node        new_node.next = temp_next        self.list_size += 1    def insertLast(self, data):        node = self.head        while True:            if node.next == None:                break            node = node.next        new_node = Node(data)        node.next = new_node        self.list_size += 1    def selectNode(self, num):        if self.list_size &lt; num:            print(\"Overflow\")            return        node = self.head        count = 0        while count &lt; num:            node = node.next            count += 1        return node    def deleteNode(self, num):        if self.list_size &lt; 1:            return # Underflow        elif self.list_size &lt; num:            return # Overflow        if num == 0:            self.deleteHead()            return        node = self.selectNode(num - 1)        node.next = node.next.next        del_node = node.next        del del_node    def deleteHead(self):        node = self.head        self.head = node.next        del node    def size(self):        return str(self.list_size)if __name__ == \"__main__\":    m_list = SingleLinkedList(1)    m_list.insertLast(5)    m_list.insertLast(6)    print('LinkedList :', m_list)    print('LinkedList Size() :', m_list.size())    print('LinkedList SelectNode(1) :', m_list.selectNode(1))    m_list.insertMiddle(1, 15)    print('LinkedList Insert Middle(1, 15) :', m_list)    m_list.insertFirst(100)    print('LinkedList Insert First(100) : ', m_list)    print('LinkedList SelectNode(0) :', m_list.selectNode(0))    m_list.deleteNode(0)    print('LinkedList Delete Node(0) : ', m_list)    m_list.deleteNode(1)    print('LinkedList Delete Node(1) : ', m_list)    #LinkedList : [ 1, 5, 6 ]#LinkedList Size() : 3#LinkedList SelectNode(1) : 5#LinkedList Insert Middle(1, 15) : [ 1, 5, 15, 6 ]#LinkedList Insert First(100) :  [ 100, 1, 5, 15, 6 ]#LinkedList SelectNode(0) : 100#LinkedList Delete Node(0) :  [ 1, 5, 15, 6 ]#LinkedList Delete Node(1) :  [ 1, 15, 6 ]    예시코드 출처 : 링크"
  },
  
  {
    "title": "연결리스트(linked list) VS 배열(array)",
    "url": "/posts/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8(linked-list)_VS_%EB%B0%B0%EC%97%B4(array)/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Linked List, Array",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "차이점1. Search(검색)  Array      Arrary는 Random Access를 지원하므로 element들을 index를 통해 직접적으로 접근 가능    특정 element 접근하는 시간 복잡도 O(1)    Linked List      Linked List는 Sequential Access를 지원하므로 element/node에 접근할 ...",
    "content": "차이점1. Search(검색)  Array      Arrary는 Random Access를 지원하므로 element들을 index를 통해 직접적으로 접근 가능    특정 element 접근하는 시간 복잡도 O(1)    Linked List      Linked List는 Sequential Access를 지원하므로 element/node에 접근할 때 처음부터 순차적으로 접근하여 찾아야함    특정 element 접근하는 시간 복잡도 O(n)  2. Insert(삽입)  Array      Array는 데이터들이 순차적으로 저장되어있으므로 맨 처음이나 그 이후에 데이터가 추가될 경우 그 뒤에 있는 데이터들을 모두 한 칸씩 뒤로 미뤄야함    추가하려는 데이터가 맨뒤가 아니라면 O(n)의 시간복잡도    추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남는다면 O(1)의 시간복잡도    Linked List      데이터를 추가하는 행위 자체의 시간복잡도는 O(1)    데이터의 위치가 맨 처음이 아닌 그 이후라면 순차적으로 탐색하여 해당위치  까지가 가야함    추가하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간복잡도    추가하려는 데이터의 위치가 맨 앞 그 이후라면 O(n)의 시간복잡도  3. Deletion(삭제)  Array      Array는 데이터들이 순차적으로 저장되어있으므로 맨 처음이나 그 이후에 데이터가 삭제될 경우 그 뒤에 있는 데이터들을 모두 한 칸씩 앞으로 당겨야함    삭제하려는 데이터가 맨뒤가 아니라면 O(n)의 시간복잡도    삭제하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남는다면 O(1)의 시간복잡도    Linked List      데이터를 삭제하는 행위 자체의 시간복잡도는 O(1)    데이터의 위치가 맨 처음이 아닌 그 이후라면 순차적으로 탐색하여 해당위치 까지가 가야함삭제하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간복잡도삭제하려는 데이터의 위치가 맨 앞 그 이후라면 O(n)의 시간복잡도  4. 저장 방식  Array      Array에서 element들은 인접한 memory 위치에 저장되거나 memory에 연이어 저장    Linked List      Linked List에서 새로운 element/node들은 memory 어딘가에 저장    새로운 element/node에 할당된 memory 위치 주소는 linked list의 이전 node에 저장  5. Memory Allocation(메모리 할당)  Array      Stack section에 메모리 할당이 이루어짐    Memory는 Array가 선언되자마자 Compile time에 할당    Static Memory Allocation이라고 부름    Linked List      Heap section에 메모리 할당이 이루어짐    Memory는 새로운 node가 추가될 때 runtime에 할당    Dynamic Memory Allocation이라고 부름  6. Size(크기)  Array      Array의 size는 array 선언 시점에 지정    Linked List      Linked List의 size는 다양할 수 있음✅ node들이 추가될 때 runtime 시점에서 size가 커질 수 있기 때문  결론데이터 접근이 중요하다면 Array데이터 수정(삽입 및 삭제)이 중요하다면 Linked List*출처https://velog.io/@alsrn7590/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-ArrayLinked-List"
  },
  
  {
    "title": "Stack & Queue with Python",
    "url": "/posts/stack&queue_with_python/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Stack, Queue",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "1. stack | 스택스택스택이란?스택(stack)은 ‘마른 풀을 쌓은 더미’, ‘겹겹이 쌓음’을 뜻함빠르다? 왜?크기를 미리 지정해서 메모리에 고정된 할당 값을 가지고 연산처리를 하기 때문이다.데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO)방식 혹은 FILO : First In Last Out  LIF...",
    "content": "1. stack | 스택스택스택이란?스택(stack)은 ‘마른 풀을 쌓은 더미’, ‘겹겹이 쌓음’을 뜻함빠르다? 왜?크기를 미리 지정해서 메모리에 고정된 할당 값을 가지고 연산처리를 하기 때문이다.데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO)방식 혹은 FILO : First In Last Out  LIFO(last in first out)란 가장 나중에 넣은 데이터를 가정 먼저 꺼낸다는 뜻python에는 stack 모듈이 있다.!그런데 이미 파이썬에는 stack을 쓰지 않아도 구현이 되어있다?!바로 list []append()pop()len()하지만 클래스로 stack을 만들어 볼 수도 있다.알고리즘 문제를 풀기위해서는 클래스를 만들어서 사용하기에는 시간도 많이 걸리므로 그저 구조를 파악하기 위해서 만들어 보는것을 추천한다.2. Queue | 큐큐는 스택과 같이 데이터를 임시 저장하는 자료구조이다. 스택과는 반대로 FIFO(First In First Out)이다. 즉, 먼저 push 된게 먼저 pop 된다.  인큐 (enqueue) : 큐에 데이터를 추가하는 작업      디큐 (dequeue) : 큐에서 데이터를 꺼내는 작업    프런트 (front) : 데이터를 꺼내는 쪽  리어 (rear) : 데이터를 집어넣는 쪽, back이라고도 함장 / 단점  장점          삽입, 삭제가 빠르다        단점          탐색이 비효율 적이다. 다 꺼내보면서 탐색해야 하기 때문.      정책에 따라 가장 위쪽의 원소만 접근이 가능하다.      큐를 사용하면 좋은 경우  맛집 예약 시스템  OS 프로세스 스케쥴링 시스템 (Priority Queue)  최근에 방문한 사이트 주소 기록 (Dequeue)  문서 작성 툴에서 undo 기록 (Dequeue)배열로 큐 구현하기  enqueue : 데이터를 추가하는 과정  dequeue : 데이터를 꺼내는 과정  peek : front에 있는 값을 꺼내지 않고 어떤 값인지만 returnclass Queue:    def __init__(self):        self.queue = []    def isEmpty(self):        if not self.queue:            return True        else:            return False    def enqueue(self, data):        self.queue.append(data)        def dequeue(self):        if self.isEmpty():            return \"Queue is Empty\"        else:            dequeued   = self.queue[0]            del self.queue[0]                        return dequeued    def peek(self):        if self.isEmpty():            return \"Queue is Empty\"                    return self.queue[0]시간 복잡도  enqueue : O(1)  dequeue : O(n)우선순위 큐인큐 시 데이터에 우선순위를 부여하여 추가하고, 디큐 시 우선순위가 가장 높은 데이터를 꺼내는 방식.  enqueue : 데이터를 추가하는 과정  dequeue : 데이터를 꺼내는 과정# path : chap04/priority_queue.pyfrom collections import namedtupleclass PriorityQueue:    Element = namedtuple(\"element\", [\"priority\", \"data\"])    def __init__(self):        self.queue = []    def isEmpty(self):        if not self.queue:            return True        else:            return False        def enqueue(self, priority, data):        return self.queue.append(PriorityQueue.Element(priority, data))    def dequeue(self):        if self.isEmpty():            return \"Queue is Empty\"                data = self.queue[0]        idx  = 0        for i in range(1, len(self.queue)):            if data.priority &lt; self.queue[i].priority:                data = self.queue[i]                idx  = i                del self.queue[idx]                return data  우선순위 큐파이썬에서 우선순위를 부여하는 큐는 heapq 모듈에서 제공한다.  heap에서 data의 인큐는 heapq.heqppush(heap,data) 로 수행하고, 디큐는 heapq.heapop(heap)으로 수행한다.  참고 : https://docs.python.org/ko/3/library/heapq.html링 버퍼로 큐 구현하기링버퍼 : 배열 맨 끝의 원소 뒤에 맨 앞의 원소가 연결되는 자료 구조  front : 배열의 맨 앞 원소  rear : 배열의 맨 끝 원소출처 : https://namu.moe/w/%ED%81%90(%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)기존의 큐는 공간이  꽉 차게 되면 더이상 요소를 추가할 수 없다. 앞쪽에 공간이 남아있다면 동그랗게 연결해 앞쪽으로 추가할 수 있도록 재활용 가능한 큐가 링 버퍼큐(원형 큐)이다.# path : chap04/fixed_queue.pyfrom typing import Anyclass FixedQueue:    class Empty(Exception):        pass    class Full(Exception):        pass    def __init__(self, capacity: int) -&gt; None:        self.no       = 0                   # 현재 데이터 개수        self.front    = 0                   # 맨 앞 원소 커서        self.rear     = 0                   # 맨 끝 원소 커서        self.capacity = capacity            # 큐의 크기        self.que      = [None] * capacity   # 큐의 본체    def __len__(self) -&gt; int:        '''큐에 있는 모든 데이터 개수를 반환'''        return self.no        def isEmpty(self) -&gt; bool:        '''큐가 비어있는지 판단'''        return self.no &lt;= 0    def isFull(self) -&gt; bool:        '''큐가 가득 차 있는지 판단'''        return self.no &gt;= self.capacity    def enqueue(self, x: Any) -&gt; None:        '''데이터 x를 인큐'''        if self.isFull():            raise FixedQueue.Full        self.que[self.rear] = x        self.rear += 1        self.no   += 1        if self.rear == self.capacity: # 큐가 가득 찰 경우            self.rear = 0        def dequeue(self) -&gt; Any:        '''데이터를 디큐'''        if  self.isEmpty():            raise FixedQueue.Empty        x = self.que[self.front]        self.front +=1        self.no    -=1        if self.front == self.capacity: # 큐 배열의 한계를 넘어설경우            self.front = 0              # front값을 배열 맨 앞 인덱스인 0으로 되돌림        return x        def peek(self) -&gt; Any:        '''큐의 맨 앞 데이터를 확인'''        if  self.isEmpty():            raise FixedQueue.Empty        return self.que(self.front)    def find(self, value: Any) -&gt; Any:        '''큐에서 value를 찾아 인덱스 반환 (없으면 -1)'''        for i in range(self.no):            idx = (i + self.front) % self.capacity            if self.que[idx] == value:                return idx        return -1    def count(self, value: Any) -&gt; Any:        '''큐에 있는 value의 개수를 반환'''        c = 0        for i in range(self.no):            idx = (i + self.front) % self.capacity            if self.que[idx] == value:                c += 1        return c    def __contains__(self, value: Any) -&gt; Any:        '''큐에 value가 있는지 판단'''        return self.count(value)    def clear(self) -&gt; None:        '''큐 초기화'''        self.no = self.front = self.rear = 0    def dump(self) -&gt; None:        '''모든 데이터를 맨 앞부터 맨 끝 순으로 출력'''        if self.isEmpty():            print(\"Queue is Empty\")                else:            for i in range(self.no):                print(self.que[(i + self.front) % self.capacity], end='')                print()  que : 큐의 배열로서 밀어 넣는 데이터를 저장하는 list형 배열  capacity : 큐의 최대 크기를 나타내는 int 형 정수. 배열 queue 원소 수와 일치한다.  front, rear : 맨 앞 원소, 맨끝 원소.  no : 큐에 쌓여있는 데이터 개수를 나타내는 int형 정수. 변수 front와 rear값이 같을 경우 큐가 비어있는지, 가득 차 있는지 구별하기 위해 필요하다. 큐가 비어있다면 no 는 0이고, 가득 차있다면 no는 capacity 값과 같다."
  },
  
  {
    "title": "Set with Python",
    "url": "/posts/SET_with_python/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Set, Python",
    "date": "2022-02-01 11:00:00 +0900",
    





    
    "snippet": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dic...",
    "content": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dict'&gt;c = set()print(type(c)) #&lt;class 'set'&gt;2. 추가&amp;삭제#추가a = {1, 2, 3}a.add(4)print(a)&gt;&gt;&gt; {1, 2, 3, 4}#여러 값 추가a = {1, 2, 3}a.update({4, 5, 6})print(a)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6}#삭제a = {1, 2, 3}a.remove(2)print(a)&gt;&gt;&gt; {1, 3}3. 교집합&amp;합집합&amp;차집합  메서드나 연산자를 사용하여 구할 수 있다.set1 = {1, 2, 3, 4, 5, 6}set2 = {4, 5, 6, 7, 8, 9}#교집합print(set1 &amp; set2)&gt;&gt;&gt; {4, 5, 6}print(set1.intersection(set2))&gt;&gt;&gt; {4, 5, 6}#합집합print(set1 | set2)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}print(set1.union(set2))&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}#차집합print(set1 - set2)&gt;&gt;&gt; {1, 2, 3}print(set1.difference(set2))&gt;&gt;&gt; {1, 2, 3}4. list VS set (in 연산 시간복잡도 비교)  List 자료형에서는 in 연산자의 시간 복잡도는 O(n)이고,  set 자료형에서는 in 연산자의 시간 복잡도는 O(1)이다.import timeits = set(range(0, 1000000))l = list(range(0, 1000000))# setstart = timeit.default_timer()print(999999 in s)print(timeit.default_timer() - start) # liststart = timeit.default_timer()print(999999 in l)print(timeit.default_timer() - start)  print('-----------------------------------')#setstart = timeit.default_timer()for i in range(1000):    i+1000 in sprint(timeit.default_timer() - start) #list start = timeit.default_timer()for i in range(1000):    i+1000 in lprint(timeit.default_timer() - start) &gt;&gt;&gt;True0.00001733399403747171True0.010281834998750128-----------------------------------0.000097908006864599880.015224540999042802"
  },
  
  {
    "title": "배열과 리스트",
    "url": "/posts/%EB%B0%B0%EC%97%B4%EA%B3%BC_%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Array, List, Data Structure",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2 ...",
    "content": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2        값 3        값 4            배열의 특징  인덱스를 사용하여 값에 바로 접근 가능  새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.          값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요        배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 변경할 수 없다.리스트리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 구조리스트의 특징  인덱스가 없으므로 값에 접근하려면 Head 포인터로부터 순서대로 접근          즉, 값에 접근하는 속도가 느림        포인터로 연결되어 있으므로 데이터를 삽인하거나 삭제하는 연산 속도가 빠름  선언할 때 크기를 별도로 지정하지 않아도 된다.          리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.        포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡  ✅ 파이썬에서는 배열과 리스트를 구분하지 않는다.파이썬의 list는 리스트의 특징과 배열의 특징까지 모두 가지도록 구현되어 있다.Reference책 - Do it! 알고리즘 코딩 테스트 파이썬 편"
  },
  
  {
    "title": "객체 지향 프로그램 OOP",
    "url": "/posts/OOP/",
    "categories": "CS",
    "tags": "Computer Science, OOP",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 ...",
    "content": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 통하여 객체들이 서로 상호작용을 하는 구조로 전체 프로그램이 구현될 수 있도록 하는 것      로직에 구조를 더하기 위해 OOP를 사용      2. 사용이유  절차 지향 방식 -&gt; 데이터를 중심으로 함수 구현, 순차적인 처리 중요, C언어  객체 지향 방식 -&gt; 기능을 중심으로 함수 구현  OOP 사용의 핵심 이유 : 코드의 구조화          유지보수 용이 : 기능별로 구현되어 있기 때문에 일부가 고장나도 그 해당 부분만 고치면 됨      재활용 용이 : 정의한 class를 상속하고 확장하여 재사용할 수 있음      가독성 좋아짐      3. Class &amp; Object &amp; Instance1. 클래스(class)1) 개념  객체를 생성하기 위한 설계도  클래스를 잘 이해하는 것이 OOP의 기본  ex) Car라는 부류가 클래스(큰 개념, 범주) Car의 instance(실체)가 렉서스, bmw, 벤츠, 현대라는 객체인 것2) 구성  Class = Property + Method  Property(속성) : 해당 entity를 표현하는 data = 변수 = 명사  Method(기능) : 해당 entity가 가지고 있는 기능들 = 함수 = 동사2. 객체(Object)  클래스를 통해 정의된 설계도로 만들어진 프로그램  객체는 고유한 성격을 지니기 때문에 동일한 클래스로 만들어진 객체라도 다른 객체의 영향을 받지 않는다  객체는 클래스의 constructor 메소드로 생성된다.3. 인스턴스(Instance)  클래스로 만든 객체를 인스턴스라고도 함  객체가 개념이라면 인스턴스는 실체  인스턴스라는 말은 특정 객체가 어떤 클래스의 객체인지 관계를 위주로 설명할 때 사용  ex) 현대는 그 자체로는 인스턴스라기 보다는 객체이고,  class와의 관계에서 보면 Car의 객체라고 말하기보단 Car의 인스턴스라고 함4. The Four Pilars of OOP1. Encapsulation (캡슐화)  관련있는 변수와 함수를 하나의 단위로 묶는 것  자동차와 관련된 변수와 함수가 묶여있는 클래스 자체가 캡슐화의 예시class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"Information Hiding(정보 은닉)  속성이나 메소드같이 객체가 소유하는 것들을 다른 객체에 공개하지 않고 숨기는 것  외부 객체가 특정 객체의 데이터화 함수를 직접 접근하여 사용하거나 변경하지 못하므로 유지 보수와 소프트 웨어 확장시 오류를 최소화  속성과 메소드의 공개 범위를 access modifier(접근 제어자) 로 결정          public : 공개                  해당 클래스의 객체, 상속받는 클래스의 객체, 그리고 외부 객체 모두 다 접근 가능                    private : 숨김                  Private으로 지정된 property나 메소드는 해당 클래스의 객체 내부에서만 접근 가능          외부 객체는 접근이 막혀있음          상속받는 sub class도 직접적인 접근은 할 수 없고 상속받지 아니한다.                    protected : 숨김                  외부 객체는 접근이 막혀있음          상속받는 sub class는 접근 할 수 있고 상속 받는다.                    2. Abstraction (추상화)  객체들의 공통 특징(property, method)을 뽑아 하나의 클래스로 표현하는 것  객체의 관점에서 클래스를 정의하는 것  사자, 곰, 말 -&gt; 각각 객체이 객체들을 공통된 특징인 동물이나 생물로 묶는 것이 추상화3. Inheritance (상속성)  자식클래스(Sub Class)가 부모클래스(Base Class, Super Class)로부터 Property와 Method들을 상속받을 수 있는 특성class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"class Taxi(Car):    def take_passengers(self, passengers):        if passengers &gt; 4:            return \"5명 이상 못 탐\"        else:            return \"출발~\"taxi1 = Taxi(\"기아\", \"3,000만원\", \"orange\")print(taxi1.take_passengers(7)) # 5명 이상 못 탐print(taxi1.drive(120))# SPEEDING VIOLATION 🔵  Taxi 클래스는 자신의 고유 Method를 사용할 수 있는 것은 물론 Car 클래스를 상속받았기 때문에 Car 클래스 안의 Property(model, price, color) 와 Method(drive) 모두를 사용할 수 있다🔵  상속성을 사용하면 자식클래스에서 불필요하게 다시 정의할 일 없이 부모클래스의 코드를 재사용가능하기 때문에 중복을 방지할 수 있다  Overriding : 부모클래스의 메소드를 그대로 상속받지 않고 재정의해서 사용할 수 있는 기능4. Polymorphism (다형성)  하나의 형태가 다양한 유형으로 나타날 수 있는 특성  Overriding처럼 부모클래스의 메소드가 자식클래스에서 다양한 기능으로 나타날 수 있는 것도 한 예시  Overloading : 메소드의 이름은 같지만 매개변수가 다름          python 과 javascript는 overloading 함수를 지원하지 않음      ex) sum 이라는 같은 이름의 함수가 매개변수의 개수와 타입에 따라 각기 다른 3개의 메소드로 구현되고 있다      public class Math {      public int sum(int x, int y)    {        return (x + y);    }      public int sum(int x, int y, int z)    {        return (x + y + z);    }      public double sum(double x, double y)    {        return (x + y);    }      public static void main(String args[])    {        Math math = new Math();        System.out.println(math.sum(1, 2));        System.out.println(math.sum(3, 4, 5));        System.out.println(math.sum(7.7, 8.8));    }}  Duck Typing : “만약 어떤 것이 오리처럼 생겼고, 오리처럼 헤엄치고, 오리처럼 꽥꽥거린다면 그건 오리라고 봐야 한다”라는 오리 실험에서 유래된 것으로 동일한 변수와 메소드를 가지고 있는 객체는 동일한 타입으로 간주하는 typing 방법  서로 아무 상관없는 세 클라스 Truck, Bus, RaceCar는 모두 drive 메소드를 제공하기 때문에 Duck Typing 개념에 의하여 drive_car 함수 입장에서는 동일한 객체로 간주될 수 있다는 것이다.class Truck:  def drive(self):    print(\"Driving Truck\")  def stop(self):    print(\"Stoping Truck\")class Bus:\tdef drive(self):\t\tprint(\"Driving Bus\")\tdef stop(self):\t\tprint(\"Stoping Bus\")class RaceCar:\tdef drive(self):\t\tprint(\"Driving RaceCar\")\tdef stop(self):\t\tprint(\"Stoping RaceCar\")def drive_car(car):\tcar.drive()truck = Truck()bus = Bus()race_car = RaceCar()drive_car(truck) # Driving Truckdrive_car(bus) # Driving Busdrive_car(race_car) # Driving RaceCar  Polymorphism(다형성) 이 중요한 이유 polymorphism을 통해서 포괄적인(generic) 인터페이스 제공이 가능해지기 때문이다. 위 duck typing 코드 예제에세도, drive_car 함수는 실제 input으로 들어오는 객체의 타입이나 구현 내용이나 실행 로직에 대해서 확인하거나 인지할 필요가 없다. drive 메소드만 가지고 있다면 실행이 가능하기 때문이다. 그러므로 polymorphism을 통해 굉장히 유연하고 간단한 인터페이스 및 로직 구현이 가능해진다."
  },
  
  {
    "title": "HTTP 상태 코드",
    "url": "/posts/HTTP_status/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2022-01-12 10:00:00 +0900",
    





    
    "snippet": "HTTP 상태 코드란 무엇인가?웹사이트에 접속할 때, 브라우저는 서버에게 정보를 요청한다. 이때 서버는 요청을 처리한 결과를 HTTP 상태 코드라는 숫자로 알려준다. 이 숫자는 요청이 성공했는지, 실패했는지, 실패했다면 왜 실패했는지를 알려주는 중요한 역할을 한다.HTTP 상태 코드의 중요성HTTP 상태 코드는 200 = 성공, 400 = 클라이언트가...",
    "content": "HTTP 상태 코드란 무엇인가?웹사이트에 접속할 때, 브라우저는 서버에게 정보를 요청한다. 이때 서버는 요청을 처리한 결과를 HTTP 상태 코드라는 숫자로 알려준다. 이 숫자는 요청이 성공했는지, 실패했는지, 실패했다면 왜 실패했는지를 알려주는 중요한 역할을 한다.HTTP 상태 코드의 중요성HTTP 상태 코드는 200 = 성공, 400 = 클라이언트가 요청을 잘못 보냄, 500 = 서버가 문제를 일으킴과 같이 여러 가지 상황을 나타낸다. 웹사이트나 앱을 만들 때, 이 상태 코드를 잘 활용하면 프로그램이 더 안정적으로 작동할 수 있다.브라우저와 상태 코드브라우저는 서버가 보내주는 상태 코드를 보고 요청이 성공했는지 실패했는지를 판단한다. 예를 들어, 서버가 200번 상태 코드를 보내면 브라우저는 “아, 요청이 성공했구나!”라고 생각한다. 반면에 400번이나 500번 상태 코드를 받으면 “어, 뭔가 문제가 있네?”라고 판단한다.각 상태 코드 알아보기이제 각 상태 코드가 어떤 의미를 가지는지 하나씩 살펴본다. 모든 상태 코드를 다 알 필요는 없고, 자주 사용하는 것들만 알아두면 된다.100번대: 정보 제공      100 Continue: 클라이언트가 요청을 계속해도 된다는 의미를 가진다.    @app.route('/continue')def continue_request():    return '', 100            101 Switching Protocols: 서버가 클라이언트의 프로토콜 전환 요청을 수락했음을 의미한다.    @app.route('/switch-protocol')def switch_protocol():    return '', 101      200번대: 성공      200 OK: 요청이 성공적으로 처리되었음을 의미한다.    @app.route('/success')def success():    return jsonify(message=\"요청이 성공했습니다!\"), 200            201 Created: 요청이 성공적으로 처리되었고, 새로운 리소스가 생성되었음을 의미한다.    @app.route('/create', methods=['POST'])def create():    return jsonify(message=\"새로운 리소스가 생성되었습니다!\"), 201            202 Accepted: 요청이 수락되었지만, 아직 처리되지 않았음을 의미한다.    @app.route('/accepted')def accepted():    return jsonify(message=\"요청이 수락되었습니다!\"), 202            204 No Content: 요청이 성공적으로 처리되었지만, 반환할 내용이 없음을 의미한다.    @app.route('/delete', methods=['DELETE'])def delete():    return '', 204      300번대: 리다이렉션      301 Moved Permanently: 요청한 리소스가 다른 곳으로 옮겨졌음을 의미한다.    @app.route('/moved-permanently')def moved_permanently():    return '', 301, {'Location': 'https://new-location.com'}            302 Found: 요청한 리소스가 임시로 다른 곳에 있음을 의미한다.    @app.route('/found')def found():    return '', 302, {'Location': 'https://temporary-location.com'}            304 Not Modified: 요청한 리소스가 이전과 달라진 점이 없음을 의미한다.    @app.route('/not-modified')def not_modified():    return '', 304      400번대: 클라이언트 오류      400 Bad Request: 클라이언트가 잘못된 요청을 보냈음을 의미한다.    @app.route('/bad-request')def bad_request():    return jsonify(error=\"잘못된 요청입니다.\"), 400            401 Unauthorized: 인증이 필요한 리소스를 인증 없이 요청했음을 의미한다.    @app.route('/unauthorized')def unauthorized():    return jsonify(error=\"인증이 필요합니다.\"), 401            403 Forbidden: 접근이 금지된 리소스를 요청했음을 의미한다.    @app.route('/forbidden')def forbidden():    return jsonify(error=\"접근이 금지되었습니다.\"), 403            404 Not Found: 요청한 리소스를 찾을 수 없음을 의미한다.    @app.route('/not-found')def not_found():    return jsonify(error=\"리소스를 찾을 수 없습니다.\"), 404            405 Method Not Allowed: 요청한 메소드가 허용되지 않음을 의미한다.    @app.route('/method-not-allowed', methods=['POST'])def method_not_allowed():    return jsonify(error=\"허용되지 않는 메소드입니다.\"), 405            406 Not Acceptable: 요청한 리소스가 클라이언트가 수용할 수 없는 형식임을 의미한다.    @app.route('/not-acceptable')def not_acceptable():    return jsonify(error=\"수용할 수 없는 형식입니다.\"), 406            408 Request Timeout: 서버가 클라이언트의 요청을 기다리다 시간이 초과되었음을 의미한다.    @app.route('/request-timeout')def request_timeout():    return jsonify(error=\"요청 시간이 초과되었습니다.\"), 408            429 Too Many Requests: 클라이언트가 너무 많은 요청을 보냈음을 의미한다.    @app.route('/too-many-requests')def too_many_requests():    return jsonify(error=\"너무 많은 요청을 보냈습니다.\"), 429      500번대: 서버 오류      500 Internal Server Error: 서버에서 알 수 없는 오류가 발생했음을 의미한다.    @app.route('/server-error')def server_error():    return jsonify(error=\"서버 오류가 발생했습니다.\"), 500            501 Not Implemented: 서버가 요청한 기능을 지원하지 않음을 의미한다.    @app.route('/not-implemented')def not_implemented():    return jsonify(error=\"기능이 구현되지 않았습니다.\"), 501            502 Bad Gateway: 서버가 다른 서버로부터 잘못된 응답을 받았음을 의미한다.    @app.route('/bad-gateway')def bad_gateway():    return jsonify(error=\"잘못된 게이트웨이입니다.\"), 502            503 Service Unavailable: 서버가 요청을 처리할 준비가 되지 않았음을 의미한다.    @app.route('/service-unavailable')def service_unavailable():    return jsonify(error=\"서비스를 사용할 수 없습니다.\"), 503            504 Gateway Timeout: 서버가 다른 서버로부터 응답을 기다리다 시간이 초과되었음을 의미한다.    @app.route('/gateway-timeout')def gateway_timeout():    return jsonify(error=\"게이트웨이 시간이 초과되었습니다.\"), 504      백엔드와 클라이언트 간의 문제 상황 예시웹 애플리케이션을 개발할 때, 백엔드와 클라이언트 간에 다양한 문제 상황이 발생할 수 있다. 이러한 문제를 해결하기 위해 HTTP 상태 코드를 적절히 사용하는 것이 중요하다. 다음은 몇 가지 일반적인 문제 상황과 그에 대한 예시이다.      잘못된 요청 데이터: 클라이언트가 서버에 잘못된 데이터를 보낼 때, 서버는 400 Bad Request 상태 코드를 반환할 수 있다. 예를 들어, 필수 입력값이 누락된 경우이다.    @app.route('/submit', methods=['POST'])def submit():    data = request.json    if 'name' not in data:        return jsonify(error=\"이름이 필요합니다.\"), 400    return jsonify(message=\"데이터가 성공적으로 제출되었습니다.\"), 200            인증 문제: 사용자가 로그인하지 않고 보호된 리소스에 접근하려고 할 때, 서버는 401 Unauthorized 상태 코드를 반환할 수 있다.    @app.route('/profile')def profile():    if not user_is_authenticated():        return jsonify(error=\"로그인이 필요합니다.\"), 401    return jsonify(profile_data)            리소스 접근 제한: 사용자가 권한이 없는 리소스에 접근하려고 할 때, 서버는 403 Forbidden 상태 코드를 반환할 수 있다.    @app.route('/admin')def admin():    if not user_is_admin():        return jsonify(error=\"관리자 권한이 필요합니다.\"), 403    return jsonify(admin_data)            리소스 없음: 사용자가 존재하지 않는 페이지나 리소스를 요청할 때, 서버는 404 Not Found 상태 코드를 반환할 수 있다.    @app.route('/item/&lt;int:item_id&gt;')def get_item(item_id):    item = find_item_by_id(item_id)    if item is None:        return jsonify(error=\"아이템을 찾을 수 없습니다.\"), 404    return jsonify(item)            서버 오류: 서버에서 예기치 않은 오류가 발생할 때, 500 Internal Server Error 상태 코드를 반환할 수 있다.    @app.route('/process')def process():    try:        # 처리 로직        return jsonify(result=\"처리가 완료되었습니다.\"), 200    except Exception as e:        return jsonify(error=\"서버 오류가 발생했습니다.\"), 500      이러한 예시들은 백엔드와 클라이언트 간의 문제 상황을 처리하는 데 있어 HTTP 상태 코드가 어떻게 사용될 수 있는지를 보여준다. 적절한 상태 코드를 사용하면 클라이언트는 서버의 상태를 더 잘 이해하고, 사용자에게 적절한 피드백을 제공할 수 있다.참고 자료Evans Library-about-http-status-code"
  },
  
  {
    "title": "URL",
    "url": "/posts/URL/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2022-01-11 10:00:00 +0900",
    





    
    "snippet": "URL 이란URL은 Uniform Resource Locator의 약자로, 인터넷 상의 자원 위치를 표기하기 위한 규약이다. 이는 월드 와이드 웹(WWW)의 주요 요소 중 하나로, HTML(데이터 표기), URL(자원 지칭), HTTP(통신 방식)과 함께 작동한다. URL은 사용자가 웹 브라우저를 통해 특정 자원에 접근할 수 있도록 돕는 역할을 한다....",
    "content": "URL 이란URL은 Uniform Resource Locator의 약자로, 인터넷 상의 자원 위치를 표기하기 위한 규약이다. 이는 월드 와이드 웹(WWW)의 주요 요소 중 하나로, HTML(데이터 표기), URL(자원 지칭), HTTP(통신 방식)과 함께 작동한다. URL은 사용자가 웹 브라우저를 통해 특정 자원에 접근할 수 있도록 돕는 역할을 한다.URL vs URIURI(Uniform Resource Identifier)는 통합 자원 식별자로, URL은 URI의 하위 개념에 속한다. 예를 들어, https://velog.io/는 서버를 나타내는 URL이면서 URI이다. 반면, https://velog.io/input?id=1234&amp;pw=1234는 URI로, “https://velog.io/input”은 URL이며, “?id=1234&amp;pw=1234”는 특정 자원을 식별하기 위한 추가 정보이다. URI는 자원을 식별하는 데 중점을 두고 있으며, URL은 자원의 위치를 명시하는 데 중점을 둔다.URI 구조URI는 일반적으로 다음과 같은 구조를 가진다:  스킴(Scheme): 자원에 접근하기 위한 프로토콜을 정의한다. 예로는 http, https, ftp 등이 있다.  호스트(Host): 자원이 위치한 서버의 도메인 이름 또는 IP 주소를 나타낸다.  경로(Path): 서버 내에서 자원의 위치를 나타낸다.  쿼리(Query): 자원에 대한 추가적인 정보를 제공하며, ?로 시작하여 &amp;로 구분된다.  프래그먼트(Fragment): 자원의 특정 부분을 지칭하며, #로 시작한다.위 그림은 URI의 일반적인 구조를 시각적으로 보여준다.이 이미지는 URI의 구성 요소를 더 자세히 설명한다.사진출처 : 코디엔에스위키피디아에서 제공하는 이 이미지는 URI의 다양한 예시를 보여준다.사진출처 : 위키피디아"
  },
  
  {
    "title": "Kream 사이트 클론 프로젝트",
    "url": "/posts/kream_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-06 10:00:00 +0900",
    





    
    "snippet": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 ...",
    "content": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 서비스 수준으로 개발할 수 있도록 2주간 고군분투 하였습니다.프로젝트 선정이유  조사결과, 해당 사이트의 경매 입찰 기능과 결제 플로우, 차트 구현, 상품리스트 필터 구현 등 배울 점이 많다고 판단하여 선정하게 되었습니다.📅 개발 기간 및 개발 인원  개발 기간 : 2021/10/18 ~ 2021/10/29  개발 인원  👨‍👧‍👦 Front-End 4명 : 김현진, 박산성, 이선호, 하상영 👨‍👧‍👦 Back-End 3명 : 박치훈, 양가현, 송영록  Back-end github 링크🎬 프로젝트 구현 영상  🔗 [구현영상] : https://youtu.be/N63MUdDmDFI⛓️ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia⚙️ 데이터베이스 Diagram💻 구현 기능Endpoint documentation - Postman APIBACKEND  로그인 구현import jwtimport requestsfrom json.decoder import JSONDecodeErrorfrom django.http  import JsonResponsefrom django.views import Viewfrom users.models import Userfrom my_settings  import SECRET_KEY, ALGORITHMSclass KakaoLogin(View):    def get(self, request):        try:             token = request.headers.get('Authorization')            if token == None:                return JsonResponse({'messsage': 'INVALID_TOKEN'}, status=401)            kakao_account = requests.get('https://kapi.kakao.com/v2/user/me', headers = {'Authorization': f'Bearer {token}'}).json()            print('::::kakao_account:', kakao_account)            if not User.objects.filter(kakao_id=kakao_account['id']).exists():                user = User.objects.create(                    kakao_id = kakao_account['id'],                    email    = kakao_account['kakao_account']['email'],                    name     = kakao_account['kakao_account']['profile']['nickname']                )            user = User.objects.get(kakao_id=kakao_account['id'])            access_token = jwt.encode({'user_id': user.id}, SECRET_KEY, algorithm=ALGORITHMS)            return JsonResponse({'access_token': access_token}, status=201)        except KeyError:            return JsonResponse({'message': 'KEY_ERROR'}, status=400)                except JSONDecodeError:            return JsonResponse({'message': 'JSON_DECODE_ERROR'}, status=400)        except jwt.DecodeError:            return JsonResponse({'message': 'JWT_DECODE_ERROR'}, status=400)        except ConnectionError:            return JsonResponse({'message': 'CONNECTION_ERROR'}, status=400)  카카오 연동 로그인 구현  Authorization 헤더에서 카카오 엑세스 토큰을 받아옴  request.get() 함수를 통해 카카오 API 엔드포인트로 사용자 정보 요청, json 형식으로 받아옴  카카오 아이디로 사용자 조회, 없으면 새로운 유저 생성  사용자 정보에서 user모델의 id를 이용하여 jwt 토큰 발급  jwt.encode()함수에 SECRET_KEY와 ALGORITHMS를 활용하여 JWT 토큰 생성 후 반환  프론트엔드에 발상할 오류의 종류를 예외처리하여 명확히 명시  로그인 데코레이터 구현import jsonimport jwtfrom django.http  import JsonResponsefrom my_settings  import SECRET_KEY, ALGORITHMSfrom users.models import Userdef login_decorator(func):    def wrapper(self, request, *args, **kwargs):        if 'Authorization' not in request.headers :             return JsonResponse ({'message' : 'UNAUTHORIZED'}, status=401)        access_token = request.headers.get('Authorization')                try:            payload      = jwt.decode(access_token, SECRET_KEY, algorithms=ALGORITHMS)            user         = User.objects.get(id=payload['user_id'])            request.user = user        except jwt.exceptions.DecodeError:            return JsonResponse({'MESSAGE': 'INVALID_TOKEN'}, status=401)        except User.DoesNotExist:            return JsonResponse({'MESSAGE': 'INVALID_USER'}, status=401)        return func(self, request,  *args, **kwargs)    return wrapper  python decorator 활용  로그인 성공 시 토큰 발급(jwt)  로그인 실패 시 예외처리  jwt.decode() 함수를 통해 토큰 검증  디코딩한 토큰에서 user_id 추출, user모델에서 해당 user_id 조회 후 가져옴  추출한 사용자를 request.user에 저장, 이후 로그인 상태 유지  상세 페이지class DetailProductView(View) :    def get(self, request, product_id) :        try :                           buy_price_filter  = (Q(productsize__bidding__bidding_position_id = 2) &amp; Q(productsize__bidding__bidding_status_id = 1))            sell_price_filter = (Q(productsize__bidding__bidding_position_id = 1) &amp; Q(productsize__bidding__bidding_status_id = 1))            if not Product.objects.filter(id = product_id).exists():                return JsonResponse({'MESSAGE':'product_id_not_exist'}, status = 404)                        product  = Product.objects\\                                    .annotate(buy_price = Min('productsize__bidding__price', filter = buy_price_filter),                                             sell_price = Max('productsize__bidding__price', filter = sell_price_filter))\\                                    .get(id = product_id)                                                                orders   = Order.objects.\\                                    filter(bidding__product_size__product_id = product_id).\\                                    order_by('-created_at')            wishlist = len(Wishlist.objects.filter(id=product_id).all())                        product_detail = [{                                'product_id'      : product.id,                                'name'            : product.name,                                'brand_name'      : product.brand.name,                                'release_price'   : product.release_price,                                'model_number'    : product.model_number,                                'image_list'      : [image.image_url for image in product.productimage_set.all()],                                'recent_price'    : orders.first().bidding.price if orders.exists() else None,                                'buy_price'       : product.buy_price,                                'sell_price'      : product.sell_price,                                'total_wishlist'  : wishlist,                            }]            return JsonResponse({'product_detail' : product_detail}, status=200)        except AttributeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)                except TypeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)  필터 조건 정의: 구매 입찰 정보중 입찰 상태가 유효한 조건(입찰 포지션 2, 상태가 1인 경우)과 판매 입찰 정보 중 입찰 상태가 유효한 조건(입찰 포지션 1, 상태가 1인 경우)  효율적인 데이터 처리와 코드의 간결성을 위하여 annotate()함수 활용  데이터베이스 단계서 집계 함수(Min, Max)를 활용하여 필요한 값을 미리 계산    상품 리스트 출력 API(ProductView)  브랜드 리스트 출력 API(BrandView)```pythonclass BrandView(View):    def get(self, request):            brands = Brand.objects.all()        brand_list = [{                    'brand_id'   : brand.id,                    'brand_name' : brand.name,                } for brand in brands]        return JsonResponse({'brand_list' : brand_list}, status = 200) ``` - 메인 페이지, 제품 페이지 상단 브랜드 출력을 위하여 API 작성❗ Reference  이 프로젝트는 KREAM 사이트를 참조하여 학습목적으로 만들었습니다.  실무수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제될 수 있습니다.  이 프로젝트에서 사용하고 있는 사진 모두는 copyright free 사이트들의 이미지들을 취합 및 canva 에서 직접 제작한 이미지들로 제작되었습니다."
  },
  
  {
    "title": "Spao 사이트 클론 프로젝트",
    "url": "/posts/Spao_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-05 10:00:00 +0900",
    





    
    "snippet": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획...",
    "content": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획 과정 없이 짧은 기간 안에 기술 습득 및 기본 기능 구현에 집중하기 위해서 SPAO 사이트를 참고.📅 개발 기간 및 개발 인원  개발 기간 : 2021-10-05 ~ 2021-10-15 (공휴일 포함)  개발 인원  👨‍👧‍👦 Front-End 3명 : 강성구, 김현진, 정경훈  👨‍👧‍👦 Back-End 3명 : 김주현, 이기용, 송영록⚙ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia🗜 데이터베이스 Diagram(클릭 시 해당 링크로 이동합니다)💻 구현 기능BACKEND  회원가입 API  jwt와 bcrpyt를 이용한 로그인 API  장바구니 상품 추가, 수정, 삭제 API⌨ EndPoint  POST/users/signup (회원가입)  POST/users/signin (로그인)  POST/orders/cart (장바구니 생성)  GET/orders/cart (장바구니 조회)  PATCH/orders/cart (장바구니 수정)  DEL/orders/cart (장바구니 삭제)  POST/postings  (후기 등록)  POST/postings/comments (댓글 등록)  POST/postings/ (댓글 삭제)  POST/products/menus (메뉴 항목 추가)  GET/products/menus (메뉴 항목 리스트 조회)  POST/products/categories (카테고리 항목 추가)  GET/products// (특정 메뉴별 카테고리 항목 리스트 조회)  POST/products (상품 등록)  GET/products// (특정 메뉴-카테고리별 상품 리스트 조회)  GET/products/ (특정 상품에 대한 상세페이지)❗ Reference  이 프로젝트는 SPAO 사이트를 참조하여 학습목적으로 만들었습니다.  실무 수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다.🙏 help  프로젝트 상품 이미지 출처원 : MIDEOCK-미덕 , SARNO-사르노 *이미지 사용을 허가해주신 대표님들께 감사합니다.  해당 프로젝트의 이미지를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다."
  },
  
  {
    "title": "Django project 초기세팅",
    "url": "/posts/Django_Project_%EC%B4%88%EA%B8%B0%EC%84%B8%ED%8C%85/",
    "categories": "Django",
    "tags": "Django",
    "date": "2022-01-04 10:00:00 +0900",
    





    
    "snippet": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 ...",
    "content": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 후 mysql로 전환# 데이터베이스 생성mysql&gt; create database NAME character set utf8mb4 collate utf*mb4_general_ci; Project Python Package 설치$ pip install django# 이후에 MySQL server에 접속하기 위한 package$ pip install mysqlclient  (중요) mysql 설치되어 있는지 먼저 확인# 맥북은 mysqlclient를 다운받으려면 오류가 난다 그러므로 PyMySQL을 다운받자$ pip install PyMySQL#!밑글에 pymysql 세팅법을 적어놓음Django Project 생성$ django-admin startproject westarbucks$ cd westarbucksSettings.py 설정. IP허용\tALLOWED_HOSTS = ['*']. 추가로 westarbucks/urls.py를 아래와 같이 수정from django.urls import pathurlpatterns = []. 주석처리(admin, csrf, auth)my_settings.py 생성(DATABASES,SECRET_KEY). django 설정에 존재하는 내용 중 SECRET_KEY, DATABASE 등은 절대 settings.py에 두면 안됩니다.. 그대로 깃이나 오픈클라우드에 올려버리면 해킹을 당하기가 쉽습니다. 아니 당합니다!. 그래서 별도의 참조용 파이썬 파일(my_settings.py)을 생성해서, 참조하는 방법으로 진행cd '생성한 프로젝트 폴더명'touch my_settings.py. 파일에 실제 쓰여지는 내용#예시DATABASES = {    'default' : {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'DATABASE 명',        'USER': 'DB접속 계정명',        'PASSWORD': 'DB접속용 비밀번호',        'HOST': '127.0.0.1',        'PORT': '3306',    }}SECRET_KEY = '시크릿키' #settings.py에 있는 secret_key 를 사용합니다.settings.py &lt;-&gt; my_settings.py 연동#intel 맥북from pathlib\t\timport Path #기존에 settings.py에 있는 코드from my_settings\timport DATABASES, SECRET_KEYDATABASES = DATABASESSECRET_KEY = SECRET_KEY#### m1 맥북!!# $ pip install PyMySQL# 으로 PyMySQL을 다운받는거 잊지말자from pathlib        import Path #기존에 settings.py 에 있는 코드from my_settings import DATABASES, SECRET_KEYimport pymysqlpymysql.install_as_MySQLdb().corsheaderspip install django-cors-headers. 설치했다면 settings.py에 INSTALLED_APPS 안에 추가INSTALLED_APPS = [...\t\t'corsheaders']. middleware 추가MIDDLEWARE = [\t...\t\t'corsheaders.middleware.CorsMiddleware',\t...]. CORS 추가 설정##CORSCORS_ORIGIN_ALLOW_ALL=TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = (    'DELETE',    'GET',    'OPTIONS',    'PATCH',    'POST',    'PUT',)CORS_ALLOW_HEADERS = (    'accept',    'accept-encoding',    'authorization',    'content-type',    'dnt',    'origin',    'user-agent',    'x-csrftoken',    'x-requested-with',)서버 정상 동작 확인. 서버 동작(Runserver)을 통한 오류 검증python manage.py runserver. 정상 동작 예시이제 프로젝트를 위한 초기 세팅은 끝났다~프로젝트를 진행해보자!"
  },
  
  {
    "title": "모두의 네트워크 - 제7장(lesson28~31)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C7%EC%9E%A5(lesson28~31)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-07 00:00:00 +0900",
    





    
    "snippet": "Lesson 28응용계층의 역할클라이언트 = 서비스를 요청하는 요청하는 측서버 = 서비스를 제공하는 측응용계층(세션계층과 표현계층을 포함)애플리케이션과 데이터를 주고받기 위해서 필요하다.  사용자 측(클라이언트)의 요쳥을 전달하기 위해 통신대상(서버 등)이 이해할 수 있는 메시지(데이터)로 변환하고 전송 계층으로 전달하는 역할을 한다클라이언트 측 애플...",
    "content": "Lesson 28응용계층의 역할클라이언트 = 서비스를 요청하는 요청하는 측서버 = 서비스를 제공하는 측응용계층(세션계층과 표현계층을 포함)애플리케이션과 데이터를 주고받기 위해서 필요하다.  사용자 측(클라이언트)의 요쳥을 전달하기 위해 통신대상(서버 등)이 이해할 수 있는 메시지(데이터)로 변환하고 전송 계층으로 전달하는 역할을 한다클라이언트 측 애플리케이션(웹 브라우저, 메일 프로그램 등)이 서버측 애플리케이션(웹 서버 프로그램, 메일 서버 프로그램)과 통신하려면 응용 계층의 프로토콜을 사용해야 한다.|프로토콜|내용||—|—||HTTP|웹사이트접속||DNS|이름해석||FTP|파일 전송||SMTP|메일 송신||POP3|메일 수신|HTTP = Hyper Text TransferFTP = File Transfer ProtocolSMTP = Simple Mail ProtocolPOP3 = Post Office Protocol versionDNS = Domain Name SystemLesson 29웹 서버의 구조(웹 사이트 접속)1. www란? World Wide Web, 줄여서 웹(web)www에서는 HTML,URL,HTTP 라는 세가지 기술이 쓰인다.HTML은 웹페이지에서 문장 구조나 문자를 꾸미는 태그를 사용하여 작성하는 마크업 언어이다.또한 HTML은 하이퍼텍스트(hypertext)를 작성하는 마크업 언어라고도 한다.하이퍼텍스트로는 문자와 이미지를 표시하거나 하이퍼링크(hyperlink)를 사용할 수 있다. 하이퍼링크는 보통 링크(Link)라고 부른다.2. 클라이언트(웹 브라우저)HTTP란?클라이언트(웹 브라우저)는 웹 사이트를 보기 위해 서버(웹 서버 프로그램)의 80번 포트를 사용하여 HTTP통신을 한다.  request(요청) = 데이터나 작업처리를 요청하는 메세지response(응답) = 상대에게 보낸 데이터나 처리 요청에 대한 응답클라이언트가 데이터를 요청할 때는 “GET”이라고 하는 요청 정보, 파일 이름, 버전 등을 서버에 전송한다. 그러면 서버는 응답으로 요청을 정상적으로 처리했다는 “OK”라는 정보를 반환하고 index,html를 클라이언트에게 보내준다.html/2 , html/1.1 , html/1.0http/1.0버전에서는 요청을 보낼때마다 끊는 작업을 반복-&gt; keepalive 기능추가 -&gt; html/1.1  keepalive는 연결이 한번 수립하면 데이터 교환을 마칠 때까지 유지하고, 데이터 교환을 모두 끝내면 연결을 끊는 구조이다. keepalive는 요청도 순서대로 처리하는 특징이 있어서 이전 요청을 처리하는 데 시간이 길어지면 다음 요청에 대한 처리가 늦어진다.-&gt; 콘테츠 표시가 늦어지는 걸 방지하기 위해서 요청을 순서대로 반환하지 않는 방법 적용 -&gt; http/2Lesson 30DNS서버의 구조도메인 이름이란?DNS는 간단히 말하면 URL을 IP주소로 변환하는 서비스(시스템)이다ip주소가 아닌 http://velog.io와 같은 주소를 사용하여 접속하도록 돕는 것을 DNS의 이름 해석(name resolution)이라고 한다.웹사이트에 접속하면 DNS서버가 웹사이트 서버의 IP주소를 알려주는 것이다.URL에는 호스트이름과 도메인 이름이 있다.            웹주소      www.github.com                  도메인      github.com              호스트      www      요청받은 DNS 서버가 해당 도메인 이름의 ip주소를 모르는 경우에는 다른 DNS서버에서 질의를 한다.DNS서버는 전 세계에 흩어져 있고 모두 계층적으로 연결되어 있다.Lesson 31메일 서버의 구조(SMTP와 POP3)메일 송수신 구조메일을 송수신하려면 클라이언트 측의 메일 프로그램과 서버 측의 메일 서버 프로그램 간에 통신을 해야한다. 이 때 프로토콜이 필요하다            프로토콜 이름      내용      포트번호                  SMTP      메일을 보내는데 사용      25              POP3      메일을 받는데 사용      110       출처:https://post.naver.com/viewer/postView.naver?volumeNo=26957131&amp;memberNo=2521903SMTP , POP3 , IMAP      SMTP(Simple Mail Transfer Protocol)Simple Mail Transfer Protocol(SMTP)은 이메일을 전송할 때 사용하는 프로토콜입니다. 이메일 송신 프로토콜이 사용되는 경우는 크게 두 가지.(1) 클라이언트가 작성한 메일을 서버로 전송할 때(2) 인터넷을 통해 서버 간 메일을 전송할 때위 그림의 경우 Sunny라는 발신자가 메일 서버(A)에 메일을 보낼 때(1), 그리고 메일 서버(A)가 인터넷을 통해 서버(B)에 메일을 전달할 때(2) 발신 프로토콜인 SMTP를 사용한다.        POP3(Post Office Protocol 3)Post Office Protocol 3(POP3)은 이메일을 수신할 때 사용하는 프로토콜의 한 종류입니다. 보다 구체적으로는 이메일 서버에 도착한 메일을 클라이언트로 가져올 때 사용됩니다. 현재 통용되고 있는 Post Office 프로토콜의 버전이 세 번째이기 때문에 프로토콜명에 숫자 3을 붙여 POP3라고 부릅니다. POP3의 경우 서버의 사서함으로부터 클라이언트 PC로 메일을 직접 다운로드 하는 형식입니다. POP3로 서버로부터 메일을 다운로드 할 때는 헤더 부분(발신자의 정보, 수신 서버의 호스트 주소, 해당 메일의 고유한 식별자와 메일이 수신된 날짜 시간 등의 정보를 담은 메일의 앞머리 부분)과 본문(메일 본문 및 첨부파일을 포함한 실제 메일 내용)을 모두 다운로드합니다. 또한 다운로드와 동시에 사서함에 있는 이메일이 삭제되는 것이 기본적 특징입니다. (다운로드 후에도 서버에서 메일이 삭제되지 않도록 별도로 설정하는 것은 가능) 따라서 POP3 방식을 이메일을 수신한 경우 메일을 다운로드 받은 로컬 PC에만 해당 메일이 남아있게 되어 추가적인 설정을 하지 않는 이상 다른 PC나 모바일 등의 기기로 동일한 이메일을 확인할 수 없고, 별도 설정 없이 로컬 PC에서 메일을 삭제한 경우 서버에서 해당 메일을 확인할 수 없다는 단점이 존재합니다.        IMAP(Internet Message Access Protocol)Internet Message Access Protocol(IMAP)은 위에서 설명한 POP3와 마찬가지로 이메일을 수신할 때 사용하는 또 다른 프로토콜의 종류입니다.IMAP의 경우 이메일 서버와 동기화되는 방식이기에 스마트폰, 태블릿, PC 등 다양한 클라이언트 장치에서 동일하게 미리 설정한 ‘받은 편지함’, ‘보낸 편지함’ 등을 확인할 수 있다. 이는 서버에 직접 접속하여 직접 메일을 확인하는 방식이기 때문에 메일 열람 후에도 서버에 이메일이 그대로 남아있어 여러 클라이언트를 통해서도 반복적으로 이메일을 확인할 수 있는 것입니다. 또한 수신자에게 메일을 보여줄 때 메일의 헤더 부분만 보여주고 수신자가 해당 메일을 클릭해야만 메일 내용과 첨부파일 등의 본문을 다운로드하기 때문에 POP보다 빠른 방법으로 메일을 확인할 수 있습니다. ! 하지만 메일을 확인할 때마다 클라이언트와 서버가 통신해야만 하므로 메일 서버의 통신 트래픽을 높이며, 오프라인 상태에서는 메일을 확인할 수 없다는 점과 개인 메일함의 용량이 곧 서버의 용량이기 때문에 주기적인 용량 관리가 필요하다는 점은 단점으로 작용할 수 있습니다.  용량이 큰 메일을 자주 주고받아 주기적인 용량 관리가 필요하고 오프라인 상태에서도 메일 확인이 필요한 경우라면 POP3가 적합하고, 다양한 단말기에서 메일 확인이 필요하거나 불필요한 메일 다운로드 없이 빠르게 필요한 메일만 확인하고자 하는 경우 IMAP를 사용하는 것이 바람직합니다.메일 서버간에도 SMTP를 사용하여 메일을 전송한다.메일 서버에는 메일 박스가 있는데 이곳에 메일이 보관되는 것이다.Reference책 - [모두의 네트워크]https://post.naver.com/viewer/postView.naver?volumeNo=26957131&amp;memberNo=2521903"
  },
  
  {
    "title": "모두의 네트워크 - 제6장(lesson23~27)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C6%EC%9E%A5(lesson23~27)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-06 00:00:00 +0900",
    





    
    "snippet": "전송계층 : 신뢰할 수 있는 데이터 전송하기전송계층의 역할  목적지에 신뢰할 수 있는 데이터를 전달하기 위한 역할을 담당  오류를 점검하는 기능  전송된 데이터의 목적지가 어떤 애플리케이션인지 식별하는 기능연결형 통신과 비연결형 통신  연결형 통신 : 신뢰할 수 있고 정확한 데이터를 전달하는 통신(상대편과 확인해가며 통신하는 방식)          연...",
    "content": "전송계층 : 신뢰할 수 있는 데이터 전송하기전송계층의 역할  목적지에 신뢰할 수 있는 데이터를 전달하기 위한 역할을 담당  오류를 점검하는 기능  전송된 데이터의 목적지가 어떤 애플리케이션인지 식별하는 기능연결형 통신과 비연결형 통신  연결형 통신 : 신뢰할 수 있고 정확한 데이터를 전달하는 통신(상대편과 확인해가며 통신하는 방식)          연결형 통신 프로토콜 : TCP        비연결형 통신 : 효율적으로 데이터를 전달하는 통신(상대방을 확인하지 않고 일방적으로 데이터를 전송하는 방식, ex) 동영상)          비연결형 통신 프로토콜 : UDP** 신뢰성/정확성 : 데이터를 목적지에 문제없이 전달하는 것** 효율성 : 데이터를 빠르고 효율적으로 전달하는 것      TCP의 구조TCP란?연결형 통신 프로토콜  TCP 헤더 : TCP로 전송할 때 붙이는 헤더  세그먼트 : 헤더가 붙은 데이터  연결(connection, 커넥션) : TCP 통신에서 정보를 전달하기 위해 사용되는 가상의 통신로TCP 헤더TCP 헤더는 총 20바이트의 크기이며 다음과 같은 구조로 되어있다.코드비트는 각 비트별로 역할이 있으며 이중 SYN, ACK가 연결과 관련된 비트이다.SYN –&gt; 연결요청, ACK –&gt; 확인응답, FIN –&gt; 연결종료3-way, 4-way 핸드셰이크3-way 핸드셰이크(연결)연결은 SYN, ACK를 사용해서 확립한다.&lt;br&gt;신뢰할 수 있는 연결을 위해 데이터를 전송하기전에 패킷을 교환하는데 다음과 같이 세 번 확인한다. ![image](https://www.researchgate.net/profile/Zerina-Masetic/publication/321698222/figure/fig3/AS:631632801320965@1527604403114/TCP-three-way-handshake.png) 1. 연결하고자하는 두 대의 컴퓨터 주 한 대에서 최초 연결요청 2. 나머지 컴퓨터에서 확인응답 및 연결요청 3. 처음 한 대의 컴퓨터에서 다시 확인응답4-way 핸드셰이크(연결종료)연결종료는 FIN, ACK를 사용한다.역시 패킷을 교환하며 네 번 확인한다. ![image](https://ipcisco.com/wp-content/uploads/tcp-4-way-handshake.jpg)일련번호와 확인 응답 번호의 구조일련번호, 확인 응답 번호3-way 핸드셰이크가 끝나고 실제 데이터를 보내거나 받을 때는 TCP 헤더의 일련번호와 확인 응답 번호를 사용한다.  일련번호 : 이 데이터가 몇 번째 데이터인지 알려주는 역할을 한다.(송신측 –&gt; 수신측)      확인 응답 번호 : 몇 번째 데이터를 수신했는지 알려주는 역할을 하며 다음 번호의 데이터를 요청하는 데도 사용된다.(수신측 –&gt; 송신측)    재전송 제어 : 데이터가 항상 올바르게 전달되지 않기 때문에 일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우 데이터를 재전송하는 것윈도우 크기?앞서 설명한 것은 세그먼트(데이터) 하나를 보낼 때 마다 확인 응답을 한번 반환하는 통신이다.효율을 높이기 위한 방법으로 매번 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 난 후 확인 응답을 반환하는 방식을 사용하고자 하였다.  버퍼(buffer) : 세그먼트를 일시적으로 보관하는 장소      오버플로우(overflow) : 수신 측에 대량의 데이터가 전송될 경우 보관의 한계를 넘어선 경우    따라서 오버플로우를 발생시키지 않도록 버퍼의 한계 크기를 알고있어야 하며 그것이 TCP 헤더의 윈도우 크기 값에 해당한다.  윈도우 크기란 얼마나 많은 용량의 데이터를 저장해 둘 수 있는지를 나타낸다. 윈도우 크기의 초깃값은 3-way 핸드셰이크를 할 때 판단한다.  포트 번호의 구조포트 번호란?전송 계층의 역할 중 목적지가 어떤 어플리케이션인지 구분하는 역할이 있는데 이를 위해 출발지 포트 번호, 목적지 포트 번호가 필요하다. 이 값들 역시 TCP 헤더에 포함되어 있다.0~1023번 포트는 주요 프로토콜이 사용하도록 예약되어 있으며 잘 알려진 포트(well-known ports)라고 한다.1024번은 예약되어 있지만 사용되지 않는 포트, 1025번 이상은 랜덤 포트라고 해서 클라이언트 측의 송신 포트로 사용한다.            애플리케이션      포트번호                  SSH      22              SMTP      25              DNS      53              HTTP      80              POP3      110              HTTPS      443      포트 번호를 붙이지 않고 통신하면 다른 컴퓨터에 데이터가 도착하더라도 어플리케이션까지는 도착할 수 없다.UDP의 구조UDP란?비연결형 통신으로 TCP처럼 번거로운 확인과정을 거치지 않고 효율성을 중요시하는 프로토콜이다. UDP의 장점은 데이터를 효율적으로 빠르게 보내는 것! 동영상 스트리밍과 같은 서비스에서 주로 사용된다.UDP 헤더란?UDP에서는 UDP 헤더가 붙은 데이터를 UDP 데이터그램이라고 한다.신뢰성과 정확성이 필요하지 않기 때문에 TCP 헤더에 비해 적은 정보를 필요로한다. 또한 UDP를 사용하면 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있고 이를 브로드캐스트(broadcast)라고 한다.(목적지에 관계없이 랜에서 일괄적으로 송신)"
  },
  
  {
    "title": "모두의 네트워크 - 제5장part2(lesson20~22)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C5%EC%9E%A5part2(lesson20~22)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-05 00:00:00 +0900",
    





    
    "snippet": "Lesson 20 네트워크 주소와 브로드캐스트 주소의 구조  네트워크 주소와 브로드캐스트 주소란?IP 주소에는 네트워크 주소, 브로드캐스트 주소가 있다이 두 주소는 컴퓨터나 라우터가 자신의 IP로 사용하면 안되는 주소다.  네트워크 주소 : 호스트 ID가 10진수로 0이고, 2진수로 00000000  브로드캐스트 주소 : 호스트 ID가 10진수로 25...",
    "content": "Lesson 20 네트워크 주소와 브로드캐스트 주소의 구조  네트워크 주소와 브로드캐스트 주소란?IP 주소에는 네트워크 주소, 브로드캐스트 주소가 있다이 두 주소는 컴퓨터나 라우터가 자신의 IP로 사용하면 안되는 주소다.  네트워크 주소 : 호스트 ID가 10진수로 0이고, 2진수로 00000000  브로드캐스트 주소 : 호스트 ID가 10진수로 255이고, 2진수로 11111111네트워크 주소는 전체 네트워크에서 작은 네트워크를 식별하는 데 사용되고, 호스트 ID가 10진수로 0이면 그 네트워크 전체를 대표하는 주소가 된다. 즉, 전체 네트워크 대표 주소이다.  예) 192.168.1.1~ 192.168.1.6은 [192.168.1.0]의 네트워크에 있다.브로드캐스트 주소는 네트워크에 있는 컴퓨터나 장비 모두에게 한 번에 데이터를 전송하는 데 사용되는 전용 IP주소이다. -&gt; 전체 네트워크에 데이터를 전송하려면 호스트 ID에 255를 설정하면 된다.  예) 192.168.1.1~ 192.168.1.6의 IP주소를 가진 컴퓨터에서 192.168.1.255로 데이터를 보내면 192.168.1.255로 전송한 데이터는 네트워크 안에 있는 모든 컴퓨터로 송신이 된다.Lesson 21 서브넷의 구조서브넷(subnet)이란?IP주소에는 A,B,C클래스가 있다.A클래스 =&gt; 네트워크 ID 8비트  | 호스트 ID 24비트B클래스 =&gt; 네트워크 ID 16비트 | 호스트 ID 16비트C클래스 =&gt; 네트워크 ID 24비트 | 호스트 ID 8비트  예를 들어 A클래스 네트워크는 호스트 ID가 24비트여서  IP주소를 1677만 7214개를 사용할 수 있다.이러한 수 많은 컴퓨터가 브로드캐스트 패킷을 전송하면 네트워크가 혼잡해진다. 네트워크가 정체되고 지연되는 것을 방지하기 위하여 A클래스의 대규모 네트워크를 작은 네트워크로 분할하여 브로드 캐스트로 전송되는 패킷의 범위를 좁힐 수 있다. ! 이처럼 네트워크를 분할하는 것을 서브넷팅(subneting)이라고 하고, 분할된 네트워크를 서브넷(subnet)이라고 한다.출처: 변계사 Sam의 테크 스타트업!기존에 네트워크 ID와 호스트 ID로 구성 =&gt; 네트워크 ID, 서브넷 ID, 호스트 ID 나뉨원래 호스트 ID로 사용되던 비트를 빌려서 서브넷 ID로 만들어 주는 것이다.서브넷 마스크란?IP 주소가 서브넷팅을 하면 어디까지가 네트워크ID이고 어디부터가 호스트 ID인지 판단하기 어려울 때가 있다. 이럴 때 서브넷 마스크라는 값을 사용한다.  서브넷 마스크는 네트워크 ID와 호스크 ID를 식별하기 위한 값 !서브넷 마스크는 IP 주소의 32비트에 대응한 32비트로 구성되어 있다. 즉, 서브넷 마스크는 IP 주소처럼 32개의 0 또는 1로 구성된 값이다.IP 주소의 비트가 네트워크 부이면 이 비트에 대응하는 서브넷 마스크의 비트는 1이 되고, IP 주소의 비트가 호스트 부이면 서브넷 마스크의 비트는 0이 된다. 이러한 방법으로 클래스에 구애받지 않고 IP 주소의 네트워크부를 식별할 수 있다.서브넷 표기법  십진수 표기법32비트로 구성된 서브넷 마스크도 전체 32비트를 8비트씩 4그룹으로 나누고, 그것을 십진수로 표기할 수 있다.  프리픽스 표기법서브넷 마스크를 슬래시(/)와 네트워크 부 비트수로 나타내는 프리픽스(prefix)서브넷 마스크 255.255.255.0은 네트워크부의 비트수가 24비트이므로 프리픽스 표기법을 사용하면 /24가 된다.C클래스를 컷팅해 본다면??네트워크  ID를 24비트에서 26으로 변경하면 2비트를 호스트 ID에서 빌리게 된다. 즉 네트워크 ID가 4비트 서브넷 ID가 2비트, 호스트 ID가 6비트가 된다.  현재는 클래스와 상관없이 한 네트워크에 연결하고 싶은 호스트들의 규모에 맞게 네트워크 부와 호스트 부의 길이를 비트 단위로 유연하게 변경할 수 있는 서브넷 마스크를 사용하여 IP 주소를 할당Lesson 22 라우터의 구조라우터(router)란?서로 다른 네트워크와 통신하려면 라우터가 필요하다. 라우터는 네트워크와 네트워크간의 경로(route)를 설정하고 가장 빠른 길로 트래픽을 이끌어주는 네트워크 장비다.그림의 컴퓨터 1이 컴퓨터 6에 접속하려면 라우터의 IP주소를 설정해야 된다. 이것은 네트워크의 출입구를 설정하는 것으로 기본 게이트 웨이(default gateway)라고 한다.  컴퓨터1은 다른 네트워크로 데이터를 보낼 때 어디로 전송해야 하는지 알지 못한다. 그래서 네트워크의 출입구를 지정하고 일단은 라우터로 데이터를 전송한다. 여기에서 컴퓨터 1은 192.168.1.0/24 네트워크에 속해 있기 때문에 라우터의 IP주소인 192.168.1.1로 설정한 것이다하지만 데이터를 보내려면 라우팅(routing) 기능이 필요하다!라우팅(routing)이란?경로 정보를 기반으로 현재의 네트워크에서 다른 네트워크로 최적의 경로를 통해 데이터를 전송한다. 이 경로 정보가 등록되어 있는 테이블이 라우팅 테이블이다.   라우팅 테이블 등록하는 방법      수동 등록 : 소규모 네트워크에 적합    자동 등록 : 대규모 네트워크에 적합(라우터 간에 경로 정보를 서로 교환하여 라우팅 테이블 정보를 자동으로 수정)  라우터간에 라우팅 정보를 교환하기 위한 프로토콜이 있다.=&gt; 라우팅 프로토콜이 라우팅 프로토콜을 설정하여 라우터 간에 경로 정보를 서로 교환하고 그것을 라우팅 테이블에 등록해 나가는 것이다.라우팅 프로토콜의 종류Reference책 - [모두의 네트워크]변계사 Sam의 테크 스타트업!"
  },
  
  {
    "title": "모두의 네트워크 - 제4장(lesson12~14)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C4%EC%9E%A5(lesson12~14)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-04 00:00:00 +0900",
    





    
    "snippet": "LESSON 12 데이터 링크 계층의 역할과 이더넷OSI 2계층 데이터링크 계층은 랜에서 데이터를 주고 받기 위해 필요한 일을 합니다.즉 네트워크 장비 간에 신호를 주고받는 규칙을 정하는 계층입니다.데이터 링크 계층에는 두 가지 주요 기능이 있습니다.  주소 할당: 물리 계층으로부터 받은 신호들이 네트워크 상의 장치에 올바르게 안착할 수 있게 한다. ...",
    "content": "LESSON 12 데이터 링크 계층의 역할과 이더넷OSI 2계층 데이터링크 계층은 랜에서 데이터를 주고 받기 위해 필요한 일을 합니다.즉 네트워크 장비 간에 신호를 주고받는 규칙을 정하는 계층입니다.데이터 링크 계층에는 두 가지 주요 기능이 있습니다.  주소 할당: 물리 계층으로부터 받은 신호들이 네트워크 상의 장치에 올바르게 안착할 수 있게 한다.  오류 감지: 신호가 전달되는 동안 오류가 포함되는지를 감지한다. 오류가 감지되면 데이터 링크 계층은 해당 데이터를 폐기한다.데이터 링크 계층에서 가장 많이 사용되는 프로토콜이 이더넷(Ethernet)입니다.이더넷은 랜에서 데이터를 정상적으로 주고 받기 위한 규칙입니다.데이터 충돌을 막기 위해 CSMA/CD 방식을 사용합니다.  CS : 데이터를 보내려고 하는 컴퓨터가 케이블에 신호가 흐르고 있는지 아닌지를 확인한다는 규칙  MA : 케이블에 데이터가 흐르고 있지 않다면 데이터를 보내도 좋다는 규칙  CD : 충돌이 발생하고 있는지를 확인한다는 규칙LESSON 13 MAC 주소의 구조랜 카드에는 MAC(Media Access Control Address) 주소라는 번호가 정해져 있습니다. 이 번호는 제조할 때 전 세계에서 유일한 번호로 할당 되기 때문에 물리주소 라고 불립니다.이더넷의 헤더이더넷의 헤더에는 목적지의 MAC 주소(6바이트), 출발지 MAC 주소(6바이트), 유형(2바이트) 14바이트로 구성되어 있습니다.이 중에서 유형에는 이더넷을 통해 전송되는 상위 계층 프로토콜을 식별하는 번호가 들어갑니다.이더넷의 트레일러트레일러는 헤더 외에 데이터 뒤에 추가되는 것으로 데이터 전송 도중에 오류가 발생하는지 확인하는 용도로 사용됩니다.프레임이더넷 헤더와 트레일러가 추가된 데이터를 프레임이라고 합니다.컴퓨터 1에서 컴퓨터 3으로 데이터를 전송한다고 했을 때, 이더넷 헤더에 컴퓨터 3의 MAC주소(목적지 MAC주소)와 자신의 MAC주소(출발지 MAC주소) 정보를 넣고 데이터를 전송합니다. 허브는 컴퓨터 1이 보낸 데이터를 1포트로 수신하고 2,3,4,5 모든 포트로 전송합니다. 이 때 2,4,5 컴퓨터는 목적지 MAC 주소가 자신과 다르기 때문에 데이터를 파기합니다. 만약 컴퓨터 1과 2가 동시에 컴퓨터 3에 데이터를 전송한다고 하면 충돌을 방지하기 위해 CSMA/CD 방식이 사용됩니다. 충돌이 감지되면 컴퓨터 2는 잠시 대기하고 데이터를 다시 전송합니다.LESSON 14 스위치의 구조스위치는 데이터 링크 계층에서 동작하고 레이어 2 스위치, 스위칭 허브라고도 불립니다.느리고 충돌이 생기는 허브의 단점 개선 위해 프레임을 목적지까지 포워딩 시키는 OSI Layer 2 MAC 주소 기반 네트워크 장치입니다.스위치에는 스위치의 포트 번호와 그 포트에 연결되어 있는 컴퓨터의 MAC 주소가 등록되는 데이터베이스인 MAC 주소 테이블이 있습니다.스위치의 기능      learning    출발지 주소가 MAC 주소 테이블에 없으면 MAC 주소를 포트와 함께 등록합니다.        flooding(플러딩)    목적지 MAC 주소가 MAC 주소 테이블에 없으면 송신 포트를 제외한 전체 포트에 데이터를 전송합니다.        filtering(필터링)    MAC 주소를 기준으로 목적지를 선택하여 해당 포트로만 데이터를 전송합니다.  "
  },
  
  {
    "title": "모두의 네트워크 - 제3장(lesson09~11)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C3%EC%9E%A5(lesson09~11)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-03 00:00:00 +0900",
    





    
    "snippet": "Lesson 09~10물리 계층 Physical Layer  OSI모델의 1계층으로 컴퓨터와 네트워크 장비 간에 전송되는 데이터를 전기 신호로 변환하는 계층입니다.전기 신호      아날로그 신호 : 전화 회선이나 라디오 방송에 사용되는 신호        디지털 신호  :  컴퓨터에서 전송에 사용되는 신호    컴퓨터는 네트워크를 통해 데이터를 송수신...",
    "content": "Lesson 09~10물리 계층 Physical Layer  OSI모델의 1계층으로 컴퓨터와 네트워크 장비 간에 전송되는 데이터를 전기 신호로 변환하는 계층입니다.전기 신호      아날로그 신호 : 전화 회선이나 라디오 방송에 사용되는 신호        디지털 신호  :  컴퓨터에서 전송에 사용되는 신호    컴퓨터는 네트워크를 통해 데이터를 송수신할 수 있도록 랜 카드를 가지고 있습니다.  랜 카드를 통해 0과 1의 비트열을 전기 신호로 변환할 수 있습니다.  비트열은 전기신호로 변환되어 네트워크를 통해 전송됩니다.  상대방이 받은 전기 신호는 다시 비트열 데이터로 복원됩니다.케이블의 종류와 구조네트워크 전송 매체  데이터가 흐르는 물리적인 선로로 유선과 무선이 있습니다.  유선 : 트위스트 페어 케이블(랜선), 광 케이블  무선 : 라디오파, 마이크로파, 적외선이 중 가장 많이 사용되는 트위스트 페어 케이블의 종류에는  UTP 케이블과 STP 케이블이 있다.  UTP 케이블 : 구리 선 여덟 개를 두 개씩 꼬아 만든 네 쌍의 전선으로 실드가 없는 케이블  UTP 케이블의 성능에 따라 카테고리(CAT)란 이름으로 종류가 나뉜다.  저렴하지만 노이즈의 영항을 많이 받는다.  일반적으로 많이 사용된다.  STP 케이블 : 실드로 보호한 케이블  실드는 금속 호일이나 금속의 매듭과 같은 것으로 외부에서 발생하는 노이즈를 막는 역할을 한다.  노이즈의 영향을 적게 받지만 비싸다.랜 케이블의 양쪽 끝에는 RJ-45라고 부르는 커넥터가 붙어있다.이 커넥터를 컴퓨터의 랜 포트나 네트워크 기기에 연결할 수 있다.다이렉트 케이블과 크로스 케이블  랜 케이블의 종류에는 다이렉트 케이블과 크로스 케이블이 있다.  다이렉트 케이블 : 구리 선 여덟 개를 같은 순서로 커넥터에 연결한 케이블이다.      예를 들어, 컴퓨터와 허브를 연결할 때 사용된다.    크로스 케이블 : 한쪽 커넥터의 1번, 2번과 다른 쪽 커넥터의 3번, 6번을 연결한 케이블이다.      컴퓨터와 컴퓨터를 연결할 때 사용된다.    컴퓨터간 다이렉트 케이블을 사용하면 동시에 1번과 2번으로 데이터를 전송할 시 충돌이 발생한다.  이 때문에 선이 교차된 크로스 케이블을 사용하여 송, 수신 측이 올바르게 연결되도록 한다.  실제로 다이렉트와 크로스 케이블 모두 1, 2, 3, 6번 구리선을 사용하고 나머지 네 개의 선은 사용하지 않는다.Lesson 11 리피터와 허브의 구조1. 리피터란?  리피터는 전기신호를 정형하고 증폭하는 기능을 가진 네트워크 중계 장비이다.  통신대상이 먼 거리에 있을 경우 약해지는 신호를 정상 파형으로 복원하는 역할을 한다.2. 허브란?  여러개의 포트를 가지고 있어 여러대의 컴퓨터 또는 네트워크 장비와 연결할 수 있다.  같은 허브에 연결된 장비들은 모두 상호간에 통신할 수 있다.  허브도 리피터와 마찬가지로 전기신호를 정형하고 증폭하는 기능을 수행한다.2-1 더미허브  특정 포트로부터 데이터를 받았을 때 해당 포트를 제외한 나머지 모든 포트로 받은 데이터를 전송  불필요한 데이터의 전송으로 비효율적이며 네트워크에 연결된 컴퓨터가 많을수록, 데이터가 많아질수록 속도가 급격하게 떨어진다.2-2 스위치허브  네트워크에 연결된 모든 컴퓨터는 각각 고유 주소를 가진다.  해당 고유주소를 이용하여 허브로 들어온 데이터정보를 분류하여 전송할 컴퓨터에 연결된 포트로만 전송한다.Referencehttps://almotjalal.tistory.com/81https://linkhub.tistory.com/85"
  },
  
  {
    "title": "모두의 네트워크 - 제2장(lesson06~08)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C2%EC%9E%A5(lesson06~08)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-03 00:00:00 +0900",
    





    
    "snippet": "Lesson 06 네트워크의 규칙❗️연관 정보 타 블로그와 사이트도 참조하였음프로토콜(protocol)이란?통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.프로토콜 구성 요소  형식(Syntax : 문법,구문)          데이터 포맷(형식), 부호화, 신호 레벨 등“데이터 포맷” : ...",
    "content": "Lesson 06 네트워크의 규칙❗️연관 정보 타 블로그와 사이트도 참조하였음프로토콜(protocol)이란?통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.프로토콜 구성 요소  형식(Syntax : 문법,구문)          데이터 포맷(형식), 부호화, 신호 레벨 등“데이터 포맷” : 통신,처리,해석하는데 적합하도록 형식화 된 표현(Syntax)        의미(Semantic)          특정 패턴을 어떻게 해석하고, 어떤 동작을 할 것인가 결정      전송의 조정 및 오류 처리를 위한 제어 정보 등        타이밍(Timing)          속도 일치 및 순서 제어 등      프로토콜의 주요 기능  에러 제어 (Error Control)          전송 중 에러 검출 및 에러 정정        캡슐화 (Encapsulation)          통신계층 상의 각 계층이 자신 만의 특정제어정보(주로 Header)를 추가하는 것        연결 제어 (Connection Control) 또는 세션 관리          연결지향적 통신에서 연결설정,데이터전달,연결종료 절차의 제어        순서 제어 (Sequence Control)          순서 역전, 중복 패킷 발생 등의 방지        흐름 제어 (Flow Control)          보낼 데이터량/전송률의 제한        혼잡 제어 (Congestion Control)          포화/대기 패킷 수의 제한을 위한 제어 기법        동기화 (Synchronization)          송수신 양측 간에 시간 관계(주로,위상)의 일치        주소 지정 (Addressing)          호스트/디바이스/프로세스 등을 유일하게 식별할 수 있는 방법을 제공        단편화 및 재조립 (Segmentation and Reassembly, Fragmentation and Reassembly)  데이터의 형식화 (Data Formatting) 등계층(Layer)별 프로토콜의 종류|Layer|프로토콜||—|—||응용(Application)|HTTP,SMTP,FTP,Telnet,DNS,POP3…||표현(Presetation)|SSL,SSH,ASCII,MPEG,JPEG,MIDI…||세션(Session)|NetBIOS,SAP,SDP,NWLink…||전송(Transport)|TCP,UDP,SPX…||네트워크(Network|IP,IPX…||데이터 링크(Data Link)|Ethernet,Token Ring…||물리(Physical)|-|  ❗️주된 프로토콜에 대한 것은 참조할 것=&gt; 자비스가필요해-주요 프로토콜 정리Lesson 07 OSI 모델과 TCP/IP 모델네트워크에서는 데이터를 주고받기위한 통신 규격이 정해져 있다. ‘통신 규격’에 대해 알아보자OSI 모델ISO(International Organization for Standardization) 국제 표준화기구 에서 OSI 모델이라는 표준 규격을 제정하였다.데이터 송수신은 컴퓨터에서 컴퓨터로 데이터를 전송하는 것이다.이 것을 7개의 layer로 나누어서 표현한 모델이다.             계층(Layer)      이름      설명                  7계층      응용(Application)      이메일&amp;파일전송, 웹사이트 조회 등 애플리케이션에 대한 서비스 제공              6계층      표현(Presetation)      문자코드,압축,암호화 등의 데이터를 변환              5계층      세션(Session)      세션 체결, 통신 방식을 결정              4계층      전송(Transport)      신뢰할 수 있는 통신 구현              3계층      네트워크(Network      다른 네트워크와 통신하기 위한 경로 설정 및 논리 주소를 결정              2계층      데이터 링크(Data Link)      네트워크 기기 간의 데이터 전송 및 물리 주소를 결정              1계층      물리(Physical)      시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어      그럼 데이터는 어떻게 전달 될까????그림을 참조하자구TCP/IP 모델OSI 7 계층을 4계층으로 바꾸었다고 생각하자  ❗️ OSI모델의 응용,표현,세션 세가지의 계층이 TCP/IP에서는 응용 계층하나로 포함되어 있다는 걸 놓치지 말자.Lesson 08 캡슐화와 역캡슐화데이터를 송수신할 때는 캡슐화와 역캡슐화가 이루어진다.캡슐화와 역캡슐화란?  데이터를 보낼 때는 필요한 정보를 데이터에 추가해야 하는데 이 정보가 헤더  요청 데이터에서 계층을 지날수록 필요한 헤더를 추가해 나가는 것이 캡슐화  데이터를 수신 할때 캡슐화된 데이터에서 각 계층에서 받은 헤더를 제거해 나가는 것을 역캡슐화![](https://velog.velcdn.com/images/sicksong/post/48766163-acb4-4d11-9379-d3fe6bf853cf/image.png)&gt; ❓ 트레일러란? 데이터를 전달할 때 데이터의 마지막에 추가하는 정보를 말한다.✅ 최종적으로 송신측의 데이터 링크 계층에서 만들어진 데이터가 전기 신호로 변환되어서 수신 측에 전송 되며 캡슐화와 역캡슐화가 이루어지는 것이다. ---Reference[책 - [모두의 네트워크]](https://book.naver.com/bookdb/book_detail.nhn?bid=13735927)[정보통신기술용어해설](http://www.ktword.co.kr/test/view/view.php?m_temp1=432)[곰돌이 놀이터-프로토콜 종류](https://helloworld-88.tistory.com/146)"
  },
  
  {
    "title": "모두의 네트워크 - 제1장(lesson01~05)",
    "url": "/posts/%EB%AA%A8%EB%91%90%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C1%EC%9E%A5(lesson01~05)/",
    "categories": "CS, Network",
    "tags": "Computer Science, Network",
    "date": "2021-12-03 00:00:00 +0900",
    





    
    "snippet": "Lesson 01 네트워크의 구조컴퓨터 네트워크란?컴퓨터를 2대 이상 연결하였을 때 컴퓨터 네트워크라 칭할 수 있다.(컴퓨터 간에 필요한 데이터(정보)를 서로 주고 받을 수 있다.)  그렇다면 인터넷은 무엇인가?      전 세계의 큰 네트워크로부터 작은 네트워크까지를 연결하는 거대한 네트워크를 말하는 것이다.  패킷이란?네트워크나 인터넷에서 데이터를...",
    "content": "Lesson 01 네트워크의 구조컴퓨터 네트워크란?컴퓨터를 2대 이상 연결하였을 때 컴퓨터 네트워크라 칭할 수 있다.(컴퓨터 간에 필요한 데이터(정보)를 서로 주고 받을 수 있다.)  그렇다면 인터넷은 무엇인가?      전 세계의 큰 네트워크로부터 작은 네트워크까지를 연결하는 거대한 네트워크를 말하는 것이다.  패킷이란?네트워크나 인터넷에서 데이터를 주고 받으려면 규칙이 있어야 한다.그 규칙에 패킷(packet)을 이용한다.  패킷 packet?      네트워크를 통해 전송되는 데이터의 작은 조각을 말한다.    큰 데이터가 있어도 작게 나누어서 보내는게 규칙이다.( 일종의 택배? )  왜 큰 데이터를 한번에 보내지 않고 나누어서 보내야 할까?  큰 데이터를 그대로 보내면 그 데이터가 네트워크의 대역폭(bandwidth)을 너무 많이 차지(점유)해서 다른 패킷의 흐름을 막을 위험이 있다.(고속도로 2차선에 대형 화물차가 나란히 간다고 생각하면,,어후)          대역폭(bandwidth) : 일반적으로는 네트워크에서 이용 가능한 최대 전송 속도로 정보를 전송할 수 있는 단위 시간당 전송량을 말한다.        ❗️ 데이터를 패킷으로 보내면 원래의 데이터로 돌리는 작업을 해줘야 한다.그래서 송신측에서 수신 측으로 패킷을 보낼 때는 각 패킷에 순서대로 번호를 붙여서 보낸다.그럼 번호에 맞춰 정렬하면 되니까 늦게 도착한 패킷도 원래 위치로 돌아갈 수 있는 것이다.Lesson 02 정보의 양을 나타내는 단위비트(bit)와 바이트(byte)란?디지털 데이터(digital data) : 모든 컴퓨터는 숫자 0과 1만을 다루는데 그 0과 1의 집합이다.비트(bit) : 0과 1의 정보를 나타내는 최소 단위바이트(byte) : 0 또는 1인 숫자 여덟개의 집합 단위 (8비트 = 1바이트)❓ 컴퓨터는 숫자로만 이루어져 있는데 어떻게 문자를 쓸 수 있을까?  숫자와 문자의 대응표를 미리 만들어 두었기 때문이다.  이 대응표를 문자코드(character code)라고 한다 (예: ASCII코드,unicode em등등 )          ASCII코드미국정보교환표준부호(영어: American Standard Code for Information Interchange), 또는 줄여서 ASCII( /ˈæski/, 아스키)는 영문 알파벳을 사용하는 대표적인 문자 인코딩이다. 아스키는 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며, 대부분의 문자 인코딩이 아스키에 기초를 두고 있다.아스키는 7비트 인코딩으로, 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 총128개로 이루어진다. 제어 문자들은 역사적인 이유로 남아 있으며 대부분은 더 이상 사용되지 않는다. 출력 가능한 문자들은 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수 문자, 그리고 하나의 공백 문자로 이루어진다.위키백과 - 링크      문자도 사진과 마찬가지로 상대방에게 이 숫자를 패킷으로 나누어서 보내면 받은 쪽에서 패킷을 원래 값으로 되돌릴 수 있다. 따라서 문자 데이터도 패킷으로 나누어서 네트워크에 전송하면 된다.Lesson 03 랜과 왠(LAN &amp; WAN)네트워크에는 랜(LAN)이라고 하는 좁은 범위의 네트워크와 왠(WAN)이라고 하는 넓은 범위의 네트워크가 있다. 랜과 왠의 차이점에 대해 알아보자LAN과 WAN의 차이LAN(Local Area Network)  건물 안이나 특정 지역을 범위로 하는 네트워크(지리적으로 제한된 공간. 예)) 사무실, 집)WAN(Wide Area Network)  지리적으로 넓은 범위에 구축된 네트워크  인터넷 서비스 제공자(ISP)가 제공하는 서비스를 사용하여 구축된 네트워크  LAN과 LAN을 ISP(kt,u+,sk브로드밴드)에서 제공해주는 서비스로 연결시켜주면 WAN구성이 된다.                   LAN      WAN                  범위      좁다      넓다              속도      빠르다      느리다              오류      적다      많다      *요즘에는 기가바이트로 이루어져서 WAN도 워낙 빠르기 때문에 일반적으로 체감하기 힘들긴 하나 여전히 WAN은 LAN보다는 느리다.  ✅ 인터넷의 시작1969년 12월 미국 국방부의 ARPA(Advanced Research Projects Agency,첨단연구계획)에서는 군사 목적으로 컴퓨터 네 대를 연결했는데 이것이 인터넷의 시작이다.(알파넷,ARPANET)Lesson 04 가정에서 하는 랜 구성인터넷 서비스 제공자와 인터넷 회선을 결정하고 계약한다인터넷 서비스 제공자와 인터넷 공유기로 접속한다.접속 방식에는 유선 랜 방식과 무선 랜 방식이 있다.Lesson 05 회사에서 하는 랜 구성소규모 회사에서의 네트워크 구성소규모 회사(소호 기업)에서의 네트워크 구성에 대해 알아 보자  소호기업 (SOHO)Small Office/Home Office의 약어가정에서의 랜 구성과 다른 점은 DMZ라는 네트워크 영역이 있다는 점이다.  DMZ(DeMilitarized Zone)는 외부에 공개하기 위한 네트워크외부에 무엇을 공개할까?  서버 : 주로 웹 서버, 메일 서버, DNS서버를 공개회사에서는 서버를 운영하기 위해 1)서버를 사내에 설치하거나 2)데이터 센터에 두거나 3)클라우드(cloud)에 둘 수 있다.  ❗️사내 또는 데이터 센터에 서버를 두고 운영하는 것을 온프레미스(on-premise)라고 한다. 클라우드와 비교할 때 자주 사용하는 단어이다각 서버나 컴퓨터는 스위치나 무선 랜 기능을 사용하여 사내 랜에 접속한다.Reference책 - [모두의 네트워크]"
  }
  
]

