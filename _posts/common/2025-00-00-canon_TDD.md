---
title: "Canon TDD by Kent Beck 원문 번역"
description: "Kent Beck의 Canon TDD 포스팅을 번역하였음"
date: 2025-11-25 10:00:00 +0900
categories: [CS, Common]
tags: [Computer Science, TDD, KentBeck]
image: https://substackcdn.com/image/fetch/$s_!1sX4!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7491e124-9e22-4e55-b03b-68d76316dcba_1602x1076.jpeg
---


*이 글은 kent beck의 [Canon TDD](https://tidyfirst.substack.com/p/canon-tdd)를 번역한 글입니다.

---

>다음에 이어지는 내용은 당신이 TDD를 이렇게 해야한다는 뜻이 절대 아니다. 당신이 어떤 방식을 선택하든 자신의 작업 품질에 책임을 져라. 정말로 책임을 지기만 한다면 말이다.  
이제 이어질 내용은 이런 주장들에 대한 나의 답이다:  
"TDD는 구려 친구, 왜냐면 <TDD가 아닌 무엇 >때문이지",
가장 흔한 예는 이런식이다. " 왜냐면 내가 코드를 적기도 전에 모든 테스트에 대해 적는게 싫기 때문이야"  
만약 당신이 무언가를 비판하려면, 실제 그 대상 자체를 비판해라.

1. 다루고 싶은 테스트 시나리오 목록을 작성한다.
2. 그 목록에서 정확히 하나만 골라, 실제로 구체적이고 실행 가능한 테스트로 만든다.
3. 해당테스트(그리고 기존의 모든 테스트)가 통과 하도록 코드를 변경한다.
이 과정에서 새 테스트가 필요하다는 것을 알게 되면 목록에 계속 추가한다.
4. 필요하다면 구현 설계를 개선하기 위한 리펙터링을 한다.
5. 목록이 다 빌때까지, 2번으로 돌아가라

---

## INTRO
'Vic Wu' 이 포스트의 요약을 도식화함
![Vic Wu summarized this post graphically:](https://substackcdn.com/image/fetch/$s_!1sX4!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7491e124-9e22-4e55-b03b-68d76316dcba_1602x1076.jpeg)


최근 TDD에 대한 해명들을 하면서 한가지 놀랐던 점은 사람들이 TDD의 정의에 동의를 하지 않는다는 것 이였다.
난 내 책에서 그 부분을 가능한한 명확히 썼다. 적어도 난 충분하다고 생각했다. 아니, 내 불찰이다.

아래에 적힌 워크플로우랑 다르게 하고 있는데도 잘 돌아간다면, 축하한다!
그건 Canon TDD는 아니겠지만, 그래서 뭐 어쨌다는 건데?. 
이 단계를 뚝딱뚝딱 그대로 따라했다고 금별 스티커를 붙여주는것도 아니다.

만약 당신이 TDD를 까겠다고 계획을 짜고는 아래 워크플로우를 까는게 아니라면, 그건 그냥 허수아비 때리기다.

그게 바로 내가 남은 인생의 소중한 시간을 보내며 이 글을 쓰는 이유다.-나는 당신한테 어떻게 프로그래밍을 하라고 하는 것도 아니다. 금별 스티커를 위해 요금을 청구하는 것도 아니다.-

나는 평소에 되도록 긍정적이고 건설적으로 말하려고 한다. 하지만 이 글은 어쩔 수 없이 간결하고 부정적일 것이다.
"사람들이 이걸 잘못 알고 있다. 이게 진짜다.". 누군가의 워크플로우를 까려는 것도 아니다. 하지만 Canon TDD에 대한 이해를 더 날카롭게 다듬으려는 것이다.

---
## Overview

테스트 주도 개발(TDD, Test-Driven Development)는 하나의 프로그래밍 워크플로우다.  
프로그래머는 시스템의 동작을 바꿔야 한다( 그 시스템이 지금은 텅 비어 있을지라도).
TDD는 프로그래머가 다음과 같이 시스템의 새로운 상태를 생성하도록 돕기 위해 존재한다.

- 예전에 잘 돌아가던 것들이 여전히 잘 돌아가는 모든 것
- 새로운 동작은 예측한대로 작동한다.
- 시스템은 다음 변경을 할 준비가 되어있다.
- 프로그래머와 그들의 동료들은 위 내용들에 대해 확신을 느낀다.

---
## Interface/Implementation Split

첫 번째 오해는 사람들이 설계라는 걸 죄다 한 덩어리로 묶어버린다는 거다. 
거기엔 두 가지 결이 있다.

- 특정한 부분의 동작이 어떻게 요청되는가
- 그 동작을 어떻게 시스템이 구현하는가

(내가 학교에 다닐 적에는 이걸 논리적 설계와 물리적 설계라고 불렀다. 그리고 두가지는 절대 섞일수 없다고 말이다. 하지만 누구도 어떻게 섞지말라는 것은 설명해주지 않더라. 그건 내가 나중에 직접 알아내야 했다.)

---
## The Steps
사람들은 형편없는 컴퓨터다. 앞으로 이어질 것들이 컴퓨터 프로그램처럼 보이겠지만 아니다. 프로그램을 다루는데 익숙한 사람들에게 효과적으로 전달하기 위한 시도(attempt)로 이렇게 적는 것이다.  
내가 "시도"라고 말하는 이유는, 앞에서 말했듯이, 사람들이 이런식으로 말하기 쉽게 보이기 때문이다.  
" 야 TDD 구리다! 나 완전히 다른 걸 했는데 그게 실패했거든 "

### 1. Test List
TDD의 첫 단계는, 바꾸고 싶은 동작과 시스템이 주어졌을 때, 그 새로운 동작에서 기대되는 모든 변수(경우의 수)를 쭉 나열하는 것이다.  
"기본 케이스가 있고, 그리고나서 만약 이 서비스가 타임아웃이 난다면, 또 키가 데이터베이스에 아직 없으면, 그리고 또..."

이건 분석이지만, 동작(Behavior)에 대한 분석이다. 지금 당신은 그 동작의 변경이 무조건 작동 해야하는 모든 다른 경우들을 생각하고 있다. 만약 당신이 이미 존재하는 동작들을 깨지 않고 동작의 변경을 하는 방법들이 생각났다면, 그것도 리스트에 넣어라.

**실수**: 구현 설계에 관한 결정들을 섞어 넣는 것. 참아라. 내부 구조를 어떻게 할지 결정할 시간은 나중에 얼마든지 있다.  
당신이 테스트 목록을 작성하는데만 모든 집중을 다한다면 더 나은 성과를 낼 수 있을거다.(만약 당신이 네임팬으로 냅킨에 구현 스케치를 해야한다면, 그래라, 하지만 당신은 그게 꼭 필요하지는 않을거다. 시험 삼아서 해봐라)

책에서 이 단계를 놓친 사람들이 있는 것 같아 보인다.  
" TDD는 이제 막 코딩에 도입 됐다 🚀 넌 너가 언제 끝낼지 절대 모를거야 ". 응 아냐(NOPE)




