[
  
  {
    "title": "Jekyll로 블로그 시작하기: 테스트 포스팅",
    "url": "/posts/jekyll/",
    "categories": "Blogging, Jekyll",
    "tags": "jekyll, blogging, tutorial",
    "date": "2023-10-15 10:00:00 +0900",
    





    
    "snippet": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게...",
    "content": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게 글을 작성할 수 있습니다.  빠른 속도: 정적 사이트이기 때문에 로딩 속도가 빠릅니다.테스트 포스팅 작성하기이 포스팅은 Jekyll을 사용하여 작성한 테스트 포스팅입니다. Jekyll의 기본적인 사용법을 익히고, 블로그를 시작하는 데 도움이 되기를 바랍니다.1. 파일 생성먼저 _posts 디렉토리에 새로운 파일을 생성합니다. 파일명은 YYYY-MM-DD-title.md 형식으로 작성합니다.2. Front Matter 설정파일의 맨 위에 YAML 형식의 Front Matter를 추가하여 포스트의 메타데이터를 설정합니다.---title: \"Jekyll로 블로그 시작하기: 테스트 포스팅\"date: 2023-10-15 10:00:00 +0900categories: [Blogging, Jekyll]tags: [jekyll, blogging, tutorial]---3. 포스트 내용 작성Markdown을 사용하여 포스트의 내용을 작성합니다. 예를 들어, Jekyll의 장점이나 사용법에 대해 설명할 수 있습니다.결론Jekyll을 사용하면 블로그를 쉽게 시작할 수 있습니다. 이 포스팅이 Jekyll을 이해하는 데 도움이 되었기를 바랍니다. 앞으로 더 많은 포스팅을 통해 Jekyll의 다양한 기능을 탐구해보세요!"
  },
  
  {
    "title": "Graph 그래프",
    "url": "/posts/Graph/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Graph",
    "date": "2022-02-06 10:00:00 +0900",
    





    
    "snippet": "그래프(Graph)는 정점(Vertex)와 간선(Edge)으로 이루어진 자료구조로, 정점 간의 관계를 나타내는 데 사용된다. 그래프는 복잡한 관계나 연결을 표현하는 데 적합하며, 특히 네트워크, 소셜 미디어 연결, 경로 탐색 등의 문제를 해결할 때 유용하다.그래프의 구성 요소  정점(Vertex): 그래프의 각 점으로, 데이터가 저장되는 단위이다. 정...",
    "content": "그래프(Graph)는 정점(Vertex)와 간선(Edge)으로 이루어진 자료구조로, 정점 간의 관계를 나타내는 데 사용된다. 그래프는 복잡한 관계나 연결을 표현하는 데 적합하며, 특히 네트워크, 소셜 미디어 연결, 경로 탐색 등의 문제를 해결할 때 유용하다.그래프의 구성 요소  정점(Vertex): 그래프의 각 점으로, 데이터가 저장되는 단위이다. 정점은 노드(Node)라고도 한다.  간선(Edge): 정점 간의 연결을 나타내며, 두 정점 사이의 관계를 정의한다.그래프의 종류  무방향 그래프 (Undirected Graph): 간선에 방향이 없는 그래프이다. 정점 A와 B가 연결되어 있다면 A에서 B로, B에서 A로 모두 이동할 수 있다.  방향 그래프 (Directed Graph): 간선에 방향이 있는 그래프로, 한 방향으로만 이동 가능하다. A에서 B로 연결된 경우, B에서 A로는 이동할 수 없을 수도 있다.  가중치 그래프 (Weighted Graph): 간선에 가중치(비용)가 부여된 그래프이다. 예를 들어, 지도에서 도시 간의 거리를 가중치로 설정할 수 있다.  사이클 그래프 (Cyclic Graph)와 비순환 그래프 (Acyclic Graph): 사이클이 있는 그래프는 어떤 정점에서 시작하여 다시 해당 정점으로 돌아올 수 있는 경로가 존재하는 그래프이며, 비순환 그래프는 그런 경로가 없는 그래프이다.그래프의 표현 방법  인접 행렬 (Adjacency Matrix): 그래프를 2차원 배열로 표현하며, 배열의 요소가 간선의 존재 여부를 나타낸다. 주로 간선이 많은 밀집 그래프(Dense Graph)에서 유리하다.  인접 리스트 (Adjacency List): 각 정점에 연결된 정점 목록을 리스트 형태로 표현한다. 간선이 적은 희소 그래프(Sparse Graph)에서 메모리 효율이 좋다.예제: 인접 리스트로 무방향 그래프 표현class Graph:    def __init__(self):        # 그래프를 인접 리스트로 표현하기 위한 딕셔너리 초기화        self.graph = {}    def add_edge(self, vertex, neighbor):        # vertex가 그래프에 없으면, 빈 리스트로 초기화하여 추가        if vertex not in self.graph:            self.graph[vertex] = []                # neighbor가 그래프에 없으면, 빈 리스트로 초기화하여 추가        if neighbor not in self.graph:            self.graph[neighbor] = []                # 무방향 그래프이므로 양방향 간선을 추가 (vertex에서 neighbor로)        self.graph[vertex].append(neighbor)                # 무방향 그래프이므로 양방향 간선을 추가 (neighbor에서 vertex로)        self.graph[neighbor].append(vertex)    def display(self):        # 그래프의 각 정점과 연결된 정점들을 출력        for vertex in self.graph:            print(f\"{vertex}: {self.graph[vertex]}\")# 그래프 객체 생성g = Graph()# 각 정점과 간선을 추가하여 그래프 구조 형성g.add_edge('A', 'B')  # 정점 'A'와 'B' 사이에 간선 추가g.add_edge('A', 'C')  # 정점 'A'와 'C' 사이에 간선 추가g.add_edge('B', 'D')  # 정점 'B'와 'D' 사이에 간선 추가g.add_edge('C', 'D')  # 정점 'C'와 'D' 사이에 간선 추가g.add_edge('D', 'E')  # 정점 'D'와 'E' 사이에 간선 추가# 그래프 구조를 출력print(\"그래프 구조:\")g.display()출력 결과:그래프 구조:A: ['B', 'C']B: ['A', 'D']C: ['A', 'D']D: ['B', 'C', 'E']E: ['D']그래프 탐색 알고리즘그래프에서는 탐색 알고리즘을 통해 정점을 방문하고 특정 조건에 맞는 경로를 찾을 수 있다. 주요 탐색 방법에는 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)이 있다.1. 너비 우선 탐색 (BFS)BFS는 시작 정점에서 가까운 정점부터 차례대로 방문하는 방식이다. 주로 큐(Queue) 자료구조를 사용하여 구현한다. 최단 경로 문제에 유용하다.from collections import deque  # 큐(Queue)를 사용하기 위해 deque를 임포트def bfs(graph, start):    visited = set()  # 방문한 정점을 저장할 집합 초기화    queue = deque([start])  # 탐색을 위한 큐 초기화, 시작 정점을 큐에 추가    while queue:        vertex = queue.popleft()  # 큐에서 가장 앞에 있는 정점을 꺼냄        if vertex not in visited:  # 꺼낸 정점을 아직 방문하지 않았다면            print(vertex, end=\" \")  # 정점을 출력(방문 순서 확인)            visited.add(vertex)  # 정점을 방문한 것으로 표시            # 현재 정점에 인접한 모든 정점을 큐에 추가 (방문하지 않은 정점만 추가)            queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)# 그래프 예제graph = {    'A': ['B', 'C'],    'B': ['A', 'D', 'E'],    'C': ['A', 'F'],    'D': ['B'],    'E': ['B', 'F'],    'F': ['C', 'E']}print(\"BFS 탐색 결과:\")bfs(graph, 'A')출력:BFS 탐색 결과:A B C D E F  BFS는 시작 정점(A)에서 가까운 정점(B, C)부터 차례대로 방문하며, 큐를 사용하여 방문할 정점들을 순차적으로 관리한다.2. 깊이 우선 탐색 (DFS)DFS는 시작 정점에서 최대한 깊숙이 들어간 후, 더 이상 갈 곳이 없으면 되돌아와 다른 경로를 탐색하는 방식이다. 스택이나 재귀를 사용해 구현할 수 있다.def dfs(graph, start, visited=None):    if visited is None:        visited = set()  # 방문한 정점을 저장할 집합 초기화    print(start, end=\" \")  # 시작 정점을 출력(방문 순서 확인)    visited.add(start)  # 시작 정점을 방문한 것으로 표시    for neighbor in graph[start]:  # 시작 정점에 인접한 모든 정점을 순회        if neighbor not in visited:  # 인접 정점이 방문되지 않았다면            dfs(graph, neighbor, visited)  # 인접 정점으로 DFS 재귀 호출print(\"\\nDFS 탐색 결과:\")dfs(graph, 'A')출력:DFS 탐색 결과:A B D E F C  DFS는 시작 정점(A)에서 가능한 한 경로를 따라 깊이 탐색하며, 방문하지 않은 정점으로 이동한다. 재귀 호출을 통해 방문 경로를 추적하고, 모든 정점을 탐색한다.그래프의 활용 예시  네트워크 연결: 네트워크의 컴퓨터들이 연결되어 있는지 확인하고 경로를 탐색하는 데 사용된다.  소셜 네트워크: 사용자 간의 친구 관계를 그래프로 표현하여 친구 추천, 관계 탐색 등을 구현할 수 있다.  경로 찾기: 지도에서 두 지점 간의 최단 경로나 최적 경로를 찾는 데 그래프를 사용한다.  웹 크롤링: 웹 페이지를 노드로, 하이퍼링크를 간선으로 연결하여 탐색하는 데 활용된다."
  },
  
  {
    "title": "Tree 트리(2)",
    "url": "/posts/Tree(2)/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Tree",
    "date": "2022-02-05 12:00:00 +0900",
    





    
    "snippet": "1. 이진 트리 (Binary Tree)이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조이다. 자식 노드는 왼쪽과 오른쪽으로 구분되며, 주로 계층적 데이터 표현이나 간단한 탐색 트리에 사용된다.class BinaryTreeNode:    def __init__(self, key):        self.key = key        sel...",
    "content": "1. 이진 트리 (Binary Tree)이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조이다. 자식 노드는 왼쪽과 오른쪽으로 구분되며, 주로 계층적 데이터 표현이나 간단한 탐색 트리에 사용된다.class BinaryTreeNode:    def __init__(self, key):        self.key = key        self.left = None        self.right = None# 이진 트리 생성 예시root = BinaryTreeNode(1)root.left = BinaryTreeNode(2)root.right = BinaryTreeNode(3)root.left.left = BinaryTreeNode(4)root.left.right = BinaryTreeNode(5)print(\"Binary Tree Root:\", root.key)  # 결과: 12. 이진 탐색 트리 (Binary Search Tree, BST)이진 탐색 트리는 이진 트리의 특수한 형태로, 각 노드의 왼쪽 서브트리에는 부모 노드보다 작은 값들이, 오른쪽 서브트리에는 더 큰 값들이 저장되는 구조이다. 이 특성 덕분에 빠른 검색이 가능하다.class BSTNode:    def __init__(self, key):        self.key = key        self.left = None        self.right = Noneclass BinarySearchTree:    def __init__(self):        self.root = None    def insert(self, key):        if self.root is None:            self.root = BSTNode(key)        else:            self._insert(self.root, key)    def _insert(self, node, key):        if key &lt; node.key:            if node.left is None:                node.left = BSTNode(key)            else:                self._insert(node.left, key)        else:            if node.right is None:                node.right = BSTNode(key)            else:                self._insert(node.right, key)# BST 생성 예시bst = BinarySearchTree()bst.insert(10)bst.insert(5)bst.insert(15)bst.insert(7)print(\"BST Root:\", bst.root.key)  # 결과: 103. 힙 (Heap)힙은 완전 이진 트리 구조로 최대 힙과 최소 힙으로 구분된다. 최대 힙에서는 부모 노드가 자식 노드보다 크고, 최소 힙에서는 부모 노드가 자식 노드보다 작다. 힙은 우선순위 큐와 같은 자료구조를 구현할 때 유용하다.import heapq# Min-Heap 예시min_heap = []heapq.heappush(min_heap, 10)heapq.heappush(min_heap, 5)heapq.heappush(min_heap, 20)print(\"Min Heap:\", min_heap)  # 결과: [5, 10, 20]# Max-Heap 예시 (음수로 변환하여 사용)max_heap = []heapq.heappush(max_heap, -10)heapq.heappush(max_heap, -5)heapq.heappush(max_heap, -20)print(\"Max Heap:\", [-x for x in max_heap])  # 결과: [20, 10, 5]4. 트라이 (Trie)트라이는 문자열 검색에 최적화된 트리이다. 문자열의 각 문자마다 노드를 생성하여 접두사를 빠르게 검색할 수 있다. 검색 엔진, 사전 등에서 문자열 검색이나 자동 완성 기능에 자주 사용된다.class TrieNode:    def __init__(self):        self.children = {}        self.is_end_of_word = Falseclass Trie:    def __init__(self):        self.root = TrieNode()    def insert(self, word):        node = self.root        for char in word:            if char not in node.children:                node.children[char] = TrieNode()            node = node.children[char]        node.is_end_of_word = True    def search(self, word):        node = self.root        for char in word:            if char not in node.children:                return False            node = node.children[char]        return node.is_end_of_word# Trie 사용 예시trie = Trie()trie.insert(\"hello\")print(\"Search 'hello':\", trie.search(\"hello\"))  # 결과: Trueprint(\"Search 'world':\", trie.search(\"world\"))  # 결과: False5. AVL 트리AVL 트리는 균형을 유지하는 이진 탐색 트리(BST)의 한 종류로, 높이 균형 트리라고도 한다. AVL 트리는 트리의 각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1을 넘지 않도록 한다. 만약 삽입이나 삭제 연산 중 이 균형이 깨진다면, 트리 회전(Rotation) 연산을 통해 균형을 복구한다.  이름 유래: AVL 트리는 두 발명가 Adelson-Velsky와 Landis의 이름을 따서 지어졌다.  주요 특징:          이진 탐색 트리의 속성을 가지면서 균형을 유지한다.      삽입 및 삭제 연산 후 높이 균형을 맞추기 위해 회전 연산을 수행한다.      탐색, 삽입, 삭제의 시간 복잡도는 모두 (O(\\log n))이다.      AVL 트리의 회전(Rotation)AVL 트리는 불균형이 발생했을 때 트리의 균형을 맞추기 위해 회전 연산을 수행한다. 회전에는 단일 회전(Single Rotation)과 이중 회전(Double Rotation)이 있으며, 삽입된 위치에 따라 회전 방식이 달라진다.  LL 회전 (Left-Left): 왼쪽 자식의 왼쪽 서브트리에 삽입되었을 때 불균형 해소를 위해 오른쪽으로 회전.  RR 회전 (Right-Right): 오른쪽 자식의 오른쪽 서브트리에 삽입되었을 때 불균형 해소를 위해 왼쪽으로 회전.  LR 회전 (Left-Right): 왼쪽 자식의 오른쪽 서브트리에 삽입되었을 때, 좌-우 방향으로 이중 회전을 수행.  RL 회전 (Right-Left): 오른쪽 자식의 왼쪽 서브트리에 삽입되었을 때, 우-좌 방향으로 이중 회전을 수행.  AVL 트리의 회전 연산은 구현이 복잡하여 코드로 나타내기 어렵지만, AVL 트리는 회전을 통해 항상 트리의 균형을 유지하도록 한다.AVL 트리의 활용AVL 트리는 데이터가 빈번히 삽입되고 삭제되는 상황에서 균형을 유지하면서 효율적인 검색을 제공하는 데 유리하다. 특히, 빠른 데이터 접근이 필요한 경우 효율적으로 사용될 수 있다.6. B-트리B-트리는 균형을 유지하는 다중 자식 트리(Multi-way Tree)의 일종으로, 대용량 데이터를 효율적으로 저장하고 탐색할 수 있도록 설계된 트리 자료구조이다. 주로 데이터베이스와 파일 시스템에 사용되며, 노드 하나에 여러 키를 저장하고 자식 노드도 여러 개 가질 수 있다. B-트리는 대개 디스크 기반 시스템에서 성능을 극대화하기 위해 설계되었다.  특징:          각 노드에 여러 개의 키와 자식 노드를 가질 수 있다.      B-트리는 항상 균형을 유지하며, 모든 리프 노드가 같은 높이를 유지한다.      검색, 삽입, 삭제 연산의 시간 복잡도는 (O(\\log n))이다.      B-트리의 구조B-트리는 차수(Order)라는 속성을 가지며, 트리의 각 노드는 최대 차수만큼의 자식 노드와 키를 가질 수 있다. 예를 들어, 차수 3인 B-트리는 한 노드에 최대 2개의 키와 3개의 자식 노드를 가질 수 있다. 새 노드를 삽입할 때 노드가 차수 이상으로 가득 차게 되면 분할(Split) 연산을 수행하여 트리를 균형 상태로 유지한다.  삽입과 분할: 노드가 가득 차면 노드를 분할하여 부모 노드에 새로운 노드를 생성하고, 키를 상위 노드로 올린다.  삭제와 병합: 노드의 키가 너무 적어질 경우, 형제 노드에서 키를 빌리거나 병합하여 균형을 유지한다.B+ 트리B+ 트리는 B-트리의 변형으로, 모든 키가 리프 노드에 저장되고 리프 노드가 순서대로 연결된 구조이다. B+ 트리는 B-트리보다 범위 검색이 더 효율적이다. 데이터베이스 인덱스에서 흔히 사용된다.B-트리의 활용B-트리는 대용량 데이터베이스에서 인덱싱을 효율적으로 수행하는 데 적합하다. 특히, 디스크 접근이 많은 경우 B-트리는 한 번의 접근으로 더 많은 데이터를 불러올 수 있어 성능이 높다. 데이터베이스 관리 시스템, 파일 시스템의 인덱스 등에 자주 사용된다.AVL 트리와 B-트리는 모두 효율적인 검색과 균형 유지에 유리한 트리 구조이지만, 활용되는 환경과 목적이 다르다. AVL 트리는 메모리 내 자료 관리에 적합하고, B-트리는 디스크 기반 대용량 데이터 관리에서 최적의 성능을 발휘하도록 설계된 트리 구조이다."
  },
  
  {
    "title": "Tree 트리",
    "url": "/posts/Tree/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Tree",
    "date": "2022-02-05 10:00:00 +0900",
    





    
    "snippet": "Tree트리는 계층 구조를 표현하는 비선형 자료구조이다.트리는 루트 노드에서 시작해 여러 개의 자식 노드를 가질 수 있으며, 트리의 각 노드는 자식 노드와 연결될 수 있다. 부모-자식 관계로 구성되어 계층적인 데이터를 표현할 때 유용하며, 특히 이진 트리(Binary Tree) 형태가 많이 사용된다.트리의 주요 개념  루트 노드(Root Node): ...",
    "content": "Tree트리는 계층 구조를 표현하는 비선형 자료구조이다.트리는 루트 노드에서 시작해 여러 개의 자식 노드를 가질 수 있으며, 트리의 각 노드는 자식 노드와 연결될 수 있다. 부모-자식 관계로 구성되어 계층적인 데이터를 표현할 때 유용하며, 특히 이진 트리(Binary Tree) 형태가 많이 사용된다.트리의 주요 개념  루트 노드(Root Node): 트리의 최상단 노드.  자식 노드(Child Node): 다른 노드로부터 연결된 하위 노드.  부모 노드(Parent Node): 자식 노드를 가진 노드.  잎(Leaf): 자식 노드가 없는 노드.  트리의 가장 일반적인 형태인 이진 트리는 각 노드가 최대 두 개의 자식을 가지는 구조트리 구현 예시# 노드를 나타내는 클래스class Node:    def __init__(self, value):        self.value = value  # 노드의 값        self.left = None    # 왼쪽 자식 노드        self.right = None   # 오른쪽 자식 노드# 이진 트리를 생성하는 함수def create_binary_tree():    # 루트 노드 생성    root = Node(1)        # 레벨 1의 자식 노드 추가    root.left = Node(2)    root.right = Node(3)        # 레벨 2의 자식 노드 추가    root.left.left = Node(4)    root.left.right = Node(5)    root.right.left = Node(6)    root.right.right = Node(7)        return root위의 코드는 다음과 같은 형태의 트리를 만든다.       1     /   \\    2     3   / \\   / \\  4   5 6   7  노드 1은 루트 노드  노드 2와 3은 1의 자식 노드  노드 4, 5, 6, 7은 잎 노드로, 자식이 없다.트리 순회(Tree Traversal)트리 순회는 트리 구조의 모든 노드를 방문하는 방법이다. 순회 방식에는 주로 전위 순회(Pre-order), 중위 순회(In-order), 후위 순회(Post-order)가 있다.1. 전위 순회 (Pre-order)전위 순회는 루트 -&gt; 왼쪽 -&gt; 오른쪽 순으로 방문한다.def pre_order(node):    if node:        print(node.value, end=\" \")  # 현재 노드 방문        pre_order(node.left)       # 왼쪽 서브트리 순회        pre_order(node.right)      # 오른쪽 서브트리 순회# 사용 예시root = create_binary_tree()print(\"전위 순회 결과:\")pre_order(root)  # 결과: 1 2 4 5 3 6 72. 중위 순회 (In-order)중위 순회는 왼쪽 -&gt; 루트 -&gt; 오른쪽 순으로 방문한다.def in_order(node):    if node:        in_order(node.left)        # 왼쪽 서브트리 순회        print(node.value, end=\" \")  # 현재 노드 방문        in_order(node.right)       # 오른쪽 서브트리 순회print(\"\\n중위 순회 결과:\")in_order(root)  # 결과: 4 2 5 1 6 3 73. 후위 순회 (Post-order)후위 순회는 왼쪽 -&gt; 오른쪽 -&gt; 루트 순으로 방문한다.def post_order(node):    if node:        post_order(node.left)      # 왼쪽 서브트리 순회        post_order(node.right)     # 오른쪽 서브트리 순회        print(node.value, end=\" \")  # 현재 노드 방문print(\"\\n후위 순회 결과:\")post_order(root)  # 결과: 4 5 2 6 7 3 1설명  전위 순회: 노드의 방문 순서가 루트에서 시작하므로, 트리의 구조를 출력하거나 저장할 때 유용하다.  중위 순회: 이진 탐색 트리(BST)에서 중위 순회를 사용하면 모든 노드를 오름차순으로 정렬된 순서로 방문할 수 있다.  후위 순회: 서브트리의 모든 노드를 방문한 후 부모 노드를 방문하므로, 하위 노드를 먼저 처리해야 하는 경우 유용하다.게임 스킬 트리 코드 구현RPG 게임의 스킬 트리RPG 게임에서는 캐릭터가 특정 스킬을 배우거나 업그레이드할 때, 특정 조건이 충족되어야 하는 경우가 많이 있다.예를 들어, 기본 스킬을 먼저 습득해야 고급 스킬을 배울 수 있는 구조이다. 이를 트리 구조로 표현하면 각 스킬은 노드가 되고, 부모-자식 관계로 스킬들이 계층적으로 연결된다.스킬 트리 구조와 코드 예시class SkillNode:    def __init__(self, name, level_required, description):        self.name = name                   # 스킬 이름        self.level_required = level_required  # 스킬 습득에 필요한 레벨        self.description = description     # 스킬 설명        self.children = []                 # 하위 스킬 목록    # 자식 노드(하위 스킬) 추가    def add_child(self, child):        self.children.append(child)    # 스킬 정보를 출력하는 메소드    def display(self, level=0):        indent = \" \" * (level * 4)        print(f\"{indent}- {self.name} (레벨 {self.level_required} 이상 필요): {self.description}\")        for child in self.children:            child.display(level + 1)# 스킬 트리 생성 함수def create_skill_tree():    # 기본 스킬    root = SkillNode(\"기본 공격\", 1, \"일반 공격으로 적에게 피해를 줍니다.\")        # 1레벨 스킬    skill1 = SkillNode(\"파워 스트라이크\", 2, \"강력한 공격으로 추가 피해를 줍니다.\")    skill2 = SkillNode(\"방어 자세\", 2, \"방어력을 일시적으로 증가시킵니다.\")        # 2레벨 스킬    skill1_1 = SkillNode(\"폭발 스트라이크\", 4, \"더 큰 피해를 주는 강력한 공격.\")    skill2_1 = SkillNode(\"철벽 방어\", 4, \"방어력을 크게 증가시킵니다.\")    # 스킬 트리 구축    root.add_child(skill1)    root.add_child(skill2)    skill1.add_child(skill1_1)    skill2.add_child(skill2_1)        return root위의 코드에서 SkillNode 클래스는 각 스킬을 표현한다. 각 스킬은 이름, 요구 레벨, 설명, 그리고 하위 스킬들을 가질 수 있다. create_skill_tree() 함수는 간단한 스킬 트리를 생성하고 트리 구조를 반환한다.스킬 트리 출력이제 만들어진 스킬 트리를 출력해 보겠다. display() 메소드를 호출하여 트리 구조를 계층적으로 표현할 수 있다.# 스킬 트리 생성 및 출력skill_tree = create_skill_tree()print(\"스킬 트리:\")skill_tree.display()출력 결과는 다음과 같은 계층 구조를 가진다.스킬 트리:- 기본 공격 (레벨 1 이상 필요): 일반 공격으로 적에게 피해를 줍니다.    - 파워 스트라이크 (레벨 2 이상 필요): 강력한 공격으로 추가 피해를 줍니다.        - 폭발 스트라이크 (레벨 4 이상 필요): 더 큰 피해를 주는 강력한 공격.    - 방어 자세 (레벨 2 이상 필요): 방어력을 일시적으로 증가시킵니다.        - 철벽 방어 (레벨 4 이상 필요): 방어력을 크게 증가시킵니다.설명  기본 공격을 배우면 파워 스트라이크와 방어 자세라는 새로운 스킬을 배울 수 있다.  파워 스트라이크를 배운 후에는 더 강력한 폭발 스트라이크를 배울 수 있고, 방어 자세를 배우면 철벽 방어 스킬을 사용할 수 있다.  각 스킬은 특정 레벨 이상일 때 배울 수 있도록 설정되어 있으며, 이처럼 특정 조건을 가지는 트리 구조를 통해 계층적인 스킬 습득 과정을 쉽게 관리할 수 있다."
  },
  
  {
    "title": "Hash 테이블",
    "url": "/posts/%ED%95%B4%EC%89%AC%ED%85%8C%EC%9D%B4%EB%B8%94/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Hash Table",
    "date": "2022-02-03 10:00:00 +0900",
    





    
    "snippet": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열...",
    "content": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열(Array)의 비교해보자.예를 들어 레스토랑의 메뉴를 배열에 저장한다면?menu = [\t{ name: \"coffee\",price: 10},\t{ name: \"burger\",price: 15},    \t{ name: \"tea\",price: 15}    ]이 중에서 tea의 값을 알고 싶다면 linear Search(선형검색)을 통해서 순차적으로 찾을 것이다. =&gt; 시간이 많이 걸린다!순차적으로 하나하나 쓰고 싶지 않을때 어떻게 써야할까?같은 메뉴를 해쉬테이블로 만들어보자menu = \t{ \tcoffee : 10,\tburger : 15,    \ttea : 15    ]이 경우 tea를 알고 싶으면 tea = key가 될것이고 hash tables는 가격을 Value로 제공한다.시간 복잡도를 비교해 본다면?처음 했던 방법은 O(N)이라 할 수 있다. Linear Time(선형 시간)아이템이 많을수록 찾는 시간도 오래 걸린다.그렇다면 해쉬테이블은? O(1) 즉, Constant Time(상수 시간)이다.해쉬테이블에서 어떤 값을 찾더라도 소요되는 건 오직 하나의 단계이기 때문에 배열에 비해서 굉장히 빠르다. 삭제 했을때도 마찬가지이다.value만 쓰고 싶다면?conturies = [\t\t\"🇬🇷\",\t\t\"🇬🇱\",\t\t\"🇬🇳\",\t\t\"🇳🇦\",\t\t\"🇳🇷\",\t\t\"🇦🇶\"\t]key 값이 없는데 어떻게 찾냐?conturies = {\t\t\"🇬🇷\": true,\t\t\"🇬🇱\": true,\t\t\"🇬🇳\": true,\t\t\"🇳🇦\": true,\t\t\"🇳🇷\": true,\t\t\"🇦🇶\": true\t}   #key가 국기가 되고, value는 그저 true 이다..!이렇게 되면 한 스텝만에 원하는 값을 찾을수(검색) 있다.해쉬테이블은 어떻게 작동하고 왜 “Hash”테이블이라고 할까?Hash Tables에는 array 구조가 있다.인덱스 값을 던져 주었을 때 key의 value값을 찾게 해주는 방법은 무엇이 있을까? 바로 Hash function(해시 함수)가 그것을 가능하게 해준다.key_2의 값이 해시 함수를 지나면서 index가 0인 값을 자동으로 찾아주게 된다. 조금 더 쉽게 가보자pizza의 알파벳 숫자를 5라고 했을 때 해시함수는 인덱스 5를 찾는다고 가정한다면 인덱스가 5번인 곳에 10을 넣어준다.cake는 알파벳이 4이기 때문에 4에 value값을 넣어준다. 그런데 taco도 4이기 때문에 오류가 일어나는데 이것을 Hash Collision(해시 충돌)라고 한다.이를 해결하기 위한 하나의 방법은 인덱스 4의 값에 cake와 taco 두개의 값을  가지고 있는 list를 만드는 것이다.따라서 우리는 Hash Tables에 cake가격을 물으면, Cake = key라는 해시함수에 넣고 이는 ‘4’라는 숫자를 줄 것이고, 리스트의 4로 이동하여 선형검색을 할 것이다.  바로 이러한 이유 때문에 Hash Table은 언제나 상수 시간(0(1))은 아니다.!왜냐하면 충돌이 있을 수 있고, 그 경우 선형검색을 해야하기 때문이다.참고 자료 : 노마드코더 유튜브"
  },
  
  {
    "title": "연결리스트, 근데 포인터를 곁들인",
    "url": "/posts/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%A5%BC_%EA%B3%81%EB%93%A4%EC%9D%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Linked List, Pointer",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 ...",
    "content": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 개념이 없다.class Node:    def __init__(self, data):        self.data = data        self.next = None        # 파이썬에서 노드는 위와같이 구현하였다. # 위 구조에서 현재 노드에서 다음 노드를 어떻게 참조 시킬 수 있을까?head = Node(5)next_node = Node(12)head.next = next_node# 위와같이 구현하여 참조시킬 수 있다. # 이제 위와같이 노드를 생성하고 관리하는 클래스를 구현하여 사용할 것이다.출처 : 링크포인터로 연결 리스트 만들기연결 리스트에 데이터를 삽일할 때 노드용 인스턴스를 생성하고, 데이터를 삭제할 때 노드용 인스턴스를 없애면 앞에서 제시한 데이터를 옮기는 문제를 해결할 수 있다.      Node : 데이터와 다음 데이터를 가리키는 주소(포인터)로 이루어져 있다.        Pointer : 각 노드에서 다음 데이터를 가리키는 주소값을 가진다.        Head : 링크드리스트에서 가장 시작점인 데이터를 의미한다.        Tail : 링크드리스트에서 가장 마지막 데이터를 의미        Next=None(또는 Null) : 다음 데이터가 없을 경우 포인터의 주소값은 None(또는 Null)이다.  출처: https://ybworld.tistory.com/85 [투손플레이스]링크드 리스트 만들기  노드 생성    class Node: \"\"\"연결 리스트용 노드 클래스\"\"\" def __init__(self, data: Any = None, next: Node = None):     \"\"\"초기화\"\"\"     self.data = data  # 데이터     self.next = next  # 뒤쪽 포인터            Node 연결리스트 클래스 생성```pythonclass LinkedList: “\"”연결 리스트 클래스”””    def init(self) -&gt; None:     “\"”초기화”””     self.no = 0          # 노드의 개수     self.head = None     # 머리 노드     self.current = None  # 주목 노드    def len(self) -&gt; int:     “\"”연결 리스트의 노드 개수를 반환”””     return self.no  3. search() / 검색에 성공하면 발견할 수 있는 노드```pythondef search(self, data: Any) -&gt; int:        \"\"\"data와 값이 같은 노드를 검색\"\"\"        cnt = 0        ptr = self.head        while ptr is not None:            if ptr.data == data:                self.current = ptr                return cnt            cnt += 1            ptr = ptr.next        return -1    def __contains__(self, data: Any) -&gt; bool:        \"\"\"연결 리스트에 data가 포함되어 있는가?\"\"\"        return self.search(data) &gt;= 0  add_first() / 삽입한 머리 노드     def add_first(self, data: Any) -&gt; None:     \"\"\"맨 앞에 노드를 삽입\"\"\"     ptr = self.head  # 삽입 전의 머리 노드     self.head = self.current = Node(data, ptr)     self.no += 1        add_last() / 삽입한 꼬리 노드     def add_last(self, data: Any):     \"\"\"맨 끝에 노드를 삽입\"\"\"     if self.head is None :    # 리스트가 비어 있으면         self.add_first(data)  # 맨앞에 노드 삽입     else:         ptr = self.head         while ptr.next is not None:             ptr = ptr.next  # while문을 종료할 때 ptr은 꼬리 노드를 참조         ptr.next = self.current = Node(data, None)         self.no += 1        remove_first() / 삭제한 뒤 머리노드(리스트가 비어 있으면 None)     def remove_first(self) -&gt; None:     \"\"\"머리 노드를 삭제\"\"\"     if self.head is not None:  # 리스트가 비어 있으면         self.head = self.current = self.head.next     self.no -= 1        remove_last() / 삭제한 뒤 꼬리녿(리스트가 비어 있으면 None)     def remove_last(self):     \"\"\"꼬리 노드 삭제\"\"\"     if self.head is not None:         if self.head.next is None :  # 노드가 1개 뿐이라면             self.remove_first()      # 머리 노드를 삭제         else:             ptr = self.head  # 스캔 중인 노드             pre = self.head  # 스캔 중인 노드의 앞쪽 노드             while ptr.next is not None:                 pre = ptr                 ptr = ptr.next # while문 종료시 ptr은 꼬리 노드를 참조하고 pre는 맨끝에서 두 번째 노드를 참조             pre.next = None  # pre는 삭제 뒤 꼬리 노드             self.current = pre             self.no -= 1        remove() / 삭제한 노드의 앞쪽 노드    def remove(self, p: Node) -&gt; None:     \"\"\"노드 p를 삭제\"\"\"     if self.head is not None:         if p is self.head:       # p가 머리 ​​노드이면             self.remove_first()  # 머리 노드를 삭제         else:             ptr = self.head             while ptr.next is not p:                 ptr = ptr.next                 if ptr is None:                     return  # ptr은 리스트에 존재하지 않음             ptr.next = p.next             self.current = ptr             self.no -= 1        remove_current_node() / 삭제한 노드의 앞쪽 노드     def remove_current_node(self) -&gt; None:     \"\"\"주목 노드를 삭제\"\"\"     self.remove(self.current)        clear()    def clear(self) -&gt; None:    \"\"\"전체 노드를 삭제\"\"\"    while self.head is not None:  # 전체가 비어 있게 될 때까지        self.remove_first()       # 머리 노드를 삭제    self.current = None    self.no = 0        next()    def next(self) -&gt; bool:    \"\"\"주목 노드를 한 칸 뒤로 진행\"\"\"    if self.current is None or self.current.next is None:        return False  # 진행할 수 없음    self.current = self.current.next    return True        print_current_node() &amp; print()    def print_current_node(self) -&gt; None:    \"\"\"주목 노드를 출력\"\"\"    if self.current is None:        print('주목 노드가 존재하지 않습니다.')    else:        print(self.current.data)def print(self) -&gt; None:    \"\"\"모든 노드를 출력\"\"\"    ptr = self.head    while ptr is not None:        print(ptr.data)        ptr = ptr.next      다른 예시코드class Node:    def __init__(self, data):        self.data = data        self.next = None    def __str__(self):        return str(self.data)class SingleLinkedList:    def __init__(self, data):        new_node = Node(data)        self.head = new_node        self.list_size = 1    def __str__(self):        print_list = '[ '        node = self.head        while True:            print_list += str(node)            if node.next == None:                break            node = node.next            print_list += ', '        print_list += ' ]'        return print_list    def insertFirst(self, data):        new_node = Node(data)        temp_node = self.head        self.head = new_node        self.head.next = temp_node        self.list_size += 1    def insertMiddle(self, num, data):        if self.head.next == None:            insertLast(data)            return        node = self.selectNode(num)        new_node = Node(data)        temp_next = node.next        node.next = new_node        new_node.next = temp_next        self.list_size += 1    def insertLast(self, data):        node = self.head        while True:            if node.next == None:                break            node = node.next        new_node = Node(data)        node.next = new_node        self.list_size += 1    def selectNode(self, num):        if self.list_size &lt; num:            print(\"Overflow\")            return        node = self.head        count = 0        while count &lt; num:            node = node.next            count += 1        return node    def deleteNode(self, num):        if self.list_size &lt; 1:            return # Underflow        elif self.list_size &lt; num:            return # Overflow        if num == 0:            self.deleteHead()            return        node = self.selectNode(num - 1)        node.next = node.next.next        del_node = node.next        del del_node    def deleteHead(self):        node = self.head        self.head = node.next        del node    def size(self):        return str(self.list_size)if __name__ == \"__main__\":    m_list = SingleLinkedList(1)    m_list.insertLast(5)    m_list.insertLast(6)    print('LinkedList :', m_list)    print('LinkedList Size() :', m_list.size())    print('LinkedList SelectNode(1) :', m_list.selectNode(1))    m_list.insertMiddle(1, 15)    print('LinkedList Insert Middle(1, 15) :', m_list)    m_list.insertFirst(100)    print('LinkedList Insert First(100) : ', m_list)    print('LinkedList SelectNode(0) :', m_list.selectNode(0))    m_list.deleteNode(0)    print('LinkedList Delete Node(0) : ', m_list)    m_list.deleteNode(1)    print('LinkedList Delete Node(1) : ', m_list)    #LinkedList : [ 1, 5, 6 ]#LinkedList Size() : 3#LinkedList SelectNode(1) : 5#LinkedList Insert Middle(1, 15) : [ 1, 5, 15, 6 ]#LinkedList Insert First(100) :  [ 100, 1, 5, 15, 6 ]#LinkedList SelectNode(0) : 100#LinkedList Delete Node(0) :  [ 1, 5, 15, 6 ]#LinkedList Delete Node(1) :  [ 1, 15, 6 ]    예시코드 출처 : 링크"
  },
  
  {
    "title": "연결리스트(linked list) VS 배열(array)",
    "url": "/posts/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8(linked-list)_VS_%EB%B0%B0%EC%97%B4(array)/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Linked List, Array",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "차이점1. Search(검색)  Array      Arrary는 Random Access를 지원하므로 element들을 index를 통해 직접적으로 접근 가능    특정 element 접근하는 시간 복잡도 O(1)    Linked List      Linked List는 Sequential Access를 지원하므로 element/node에 접근할 ...",
    "content": "차이점1. Search(검색)  Array      Arrary는 Random Access를 지원하므로 element들을 index를 통해 직접적으로 접근 가능    특정 element 접근하는 시간 복잡도 O(1)    Linked List      Linked List는 Sequential Access를 지원하므로 element/node에 접근할 때 처음부터 순차적으로 접근하여 찾아야함    특정 element 접근하는 시간 복잡도 O(n)  2. Insert(삽입)  Array      Array는 데이터들이 순차적으로 저장되어있으므로 맨 처음이나 그 이후에 데이터가 추가될 경우 그 뒤에 있는 데이터들을 모두 한 칸씩 뒤로 미뤄야함    추가하려는 데이터가 맨뒤가 아니라면 O(n)의 시간복잡도    추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남는다면 O(1)의 시간복잡도    Linked List      데이터를 추가하는 행위 자체의 시간복잡도는 O(1)    데이터의 위치가 맨 처음이 아닌 그 이후라면 순차적으로 탐색하여 해당위치  까지가 가야함    추가하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간복잡도    추가하려는 데이터의 위치가 맨 앞 그 이후라면 O(n)의 시간복잡도  3. Deletion(삭제)  Array      Array는 데이터들이 순차적으로 저장되어있으므로 맨 처음이나 그 이후에 데이터가 삭제될 경우 그 뒤에 있는 데이터들을 모두 한 칸씩 앞으로 당겨야함    삭제하려는 데이터가 맨뒤가 아니라면 O(n)의 시간복잡도    삭제하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남는다면 O(1)의 시간복잡도    Linked List      데이터를 삭제하는 행위 자체의 시간복잡도는 O(1)    데이터의 위치가 맨 처음이 아닌 그 이후라면 순차적으로 탐색하여 해당위치 까지가 가야함삭제하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간복잡도삭제하려는 데이터의 위치가 맨 앞 그 이후라면 O(n)의 시간복잡도  4. 저장 방식  Array      Array에서 element들은 인접한 memory 위치에 저장되거나 memory에 연이어 저장    Linked List      Linked List에서 새로운 element/node들은 memory 어딘가에 저장    새로운 element/node에 할당된 memory 위치 주소는 linked list의 이전 node에 저장  5. Memory Allocation(메모리 할당)  Array      Stack section에 메모리 할당이 이루어짐    Memory는 Array가 선언되자마자 Compile time에 할당    Static Memory Allocation이라고 부름    Linked List      Heap section에 메모리 할당이 이루어짐    Memory는 새로운 node가 추가될 때 runtime에 할당    Dynamic Memory Allocation이라고 부름  6. Size(크기)  Array      Array의 size는 array 선언 시점에 지정    Linked List      Linked List의 size는 다양할 수 있음✅ node들이 추가될 때 runtime 시점에서 size가 커질 수 있기 때문  결론데이터 접근이 중요하다면 Array데이터 수정(삽입 및 삭제)이 중요하다면 Linked List*출처https://velog.io/@alsrn7590/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-ArrayLinked-List"
  },
  
  {
    "title": "Stack & Queue with Python",
    "url": "/posts/stack&queue_with_python/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Stack, Queue",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "1. stack | 스택스택스택이란?스택(stack)은 ‘마른 풀을 쌓은 더미’, ‘겹겹이 쌓음’을 뜻함빠르다? 왜?크기를 미리 지정해서 메모리에 고정된 할당 값을 가지고 연산처리를 하기 때문이다.데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO)방식 혹은 FILO : First In Last Out  LIF...",
    "content": "1. stack | 스택스택스택이란?스택(stack)은 ‘마른 풀을 쌓은 더미’, ‘겹겹이 쌓음’을 뜻함빠르다? 왜?크기를 미리 지정해서 메모리에 고정된 할당 값을 가지고 연산처리를 하기 때문이다.데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO)방식 혹은 FILO : First In Last Out  LIFO(last in first out)란 가장 나중에 넣은 데이터를 가정 먼저 꺼낸다는 뜻python에는 stack 모듈이 있다.!그런데 이미 파이썬에는 stack을 쓰지 않아도 구현이 되어있다?!바로 list []append()pop()len()하지만 클래스로 stack을 만들어 볼 수도 있다.알고리즘 문제를 풀기위해서는 클래스를 만들어서 사용하기에는 시간도 많이 걸리므로 그저 구조를 파악하기 위해서 만들어 보는것을 추천한다.2. Queue | 큐큐는 스택과 같이 데이터를 임시 저장하는 자료구조이다. 스택과는 반대로 FIFO(First In First Out)이다. 즉, 먼저 push 된게 먼저 pop 된다.  인큐 (enqueue) : 큐에 데이터를 추가하는 작업      디큐 (dequeue) : 큐에서 데이터를 꺼내는 작업    프런트 (front) : 데이터를 꺼내는 쪽  리어 (rear) : 데이터를 집어넣는 쪽, back이라고도 함장 / 단점  장점          삽입, 삭제가 빠르다        단점          탐색이 비효율 적이다. 다 꺼내보면서 탐색해야 하기 때문.      정책에 따라 가장 위쪽의 원소만 접근이 가능하다.      큐를 사용하면 좋은 경우  맛집 예약 시스템  OS 프로세스 스케쥴링 시스템 (Priority Queue)  최근에 방문한 사이트 주소 기록 (Dequeue)  문서 작성 툴에서 undo 기록 (Dequeue)배열로 큐 구현하기  enqueue : 데이터를 추가하는 과정  dequeue : 데이터를 꺼내는 과정  peek : front에 있는 값을 꺼내지 않고 어떤 값인지만 returnclass Queue:    def __init__(self):        self.queue = []    def isEmpty(self):        if not self.queue:            return True        else:            return False    def enqueue(self, data):        self.queue.append(data)        def dequeue(self):        if self.isEmpty():            return \"Queue is Empty\"        else:            dequeued   = self.queue[0]            del self.queue[0]                        return dequeued    def peek(self):        if self.isEmpty():            return \"Queue is Empty\"                    return self.queue[0]시간 복잡도  enqueue : O(1)  dequeue : O(n)우선순위 큐인큐 시 데이터에 우선순위를 부여하여 추가하고, 디큐 시 우선순위가 가장 높은 데이터를 꺼내는 방식.  enqueue : 데이터를 추가하는 과정  dequeue : 데이터를 꺼내는 과정# path : chap04/priority_queue.pyfrom collections import namedtupleclass PriorityQueue:    Element = namedtuple(\"element\", [\"priority\", \"data\"])    def __init__(self):        self.queue = []    def isEmpty(self):        if not self.queue:            return True        else:            return False        def enqueue(self, priority, data):        return self.queue.append(PriorityQueue.Element(priority, data))    def dequeue(self):        if self.isEmpty():            return \"Queue is Empty\"                data = self.queue[0]        idx  = 0        for i in range(1, len(self.queue)):            if data.priority &lt; self.queue[i].priority:                data = self.queue[i]                idx  = i                del self.queue[idx]                return data  우선순위 큐파이썬에서 우선순위를 부여하는 큐는 heapq 모듈에서 제공한다.  heap에서 data의 인큐는 heapq.heqppush(heap,data) 로 수행하고, 디큐는 heapq.heapop(heap)으로 수행한다.  참고 : https://docs.python.org/ko/3/library/heapq.html링 버퍼로 큐 구현하기링버퍼 : 배열 맨 끝의 원소 뒤에 맨 앞의 원소가 연결되는 자료 구조  front : 배열의 맨 앞 원소  rear : 배열의 맨 끝 원소출처 : https://namu.moe/w/%ED%81%90(%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)기존의 큐는 공간이  꽉 차게 되면 더이상 요소를 추가할 수 없다. 앞쪽에 공간이 남아있다면 동그랗게 연결해 앞쪽으로 추가할 수 있도록 재활용 가능한 큐가 링 버퍼큐(원형 큐)이다.# path : chap04/fixed_queue.pyfrom typing import Anyclass FixedQueue:    class Empty(Exception):        pass    class Full(Exception):        pass    def __init__(self, capacity: int) -&gt; None:        self.no       = 0                   # 현재 데이터 개수        self.front    = 0                   # 맨 앞 원소 커서        self.rear     = 0                   # 맨 끝 원소 커서        self.capacity = capacity            # 큐의 크기        self.que      = [None] * capacity   # 큐의 본체    def __len__(self) -&gt; int:        '''큐에 있는 모든 데이터 개수를 반환'''        return self.no        def isEmpty(self) -&gt; bool:        '''큐가 비어있는지 판단'''        return self.no &lt;= 0    def isFull(self) -&gt; bool:        '''큐가 가득 차 있는지 판단'''        return self.no &gt;= self.capacity    def enqueue(self, x: Any) -&gt; None:        '''데이터 x를 인큐'''        if self.isFull():            raise FixedQueue.Full        self.que[self.rear] = x        self.rear += 1        self.no   += 1        if self.rear == self.capacity: # 큐가 가득 찰 경우            self.rear = 0        def dequeue(self) -&gt; Any:        '''데이터를 디큐'''        if  self.isEmpty():            raise FixedQueue.Empty        x = self.que[self.front]        self.front +=1        self.no    -=1        if self.front == self.capacity: # 큐 배열의 한계를 넘어설경우            self.front = 0              # front값을 배열 맨 앞 인덱스인 0으로 되돌림        return x        def peek(self) -&gt; Any:        '''큐의 맨 앞 데이터를 확인'''        if  self.isEmpty():            raise FixedQueue.Empty        return self.que(self.front)    def find(self, value: Any) -&gt; Any:        '''큐에서 value를 찾아 인덱스 반환 (없으면 -1)'''        for i in range(self.no):            idx = (i + self.front) % self.capacity            if self.que[idx] == value:                return idx        return -1    def count(self, value: Any) -&gt; Any:        '''큐에 있는 value의 개수를 반환'''        c = 0        for i in range(self.no):            idx = (i + self.front) % self.capacity            if self.que[idx] == value:                c += 1        return c    def __contains__(self, value: Any) -&gt; Any:        '''큐에 value가 있는지 판단'''        return self.count(value)    def clear(self) -&gt; None:        '''큐 초기화'''        self.no = self.front = self.rear = 0    def dump(self) -&gt; None:        '''모든 데이터를 맨 앞부터 맨 끝 순으로 출력'''        if self.isEmpty():            print(\"Queue is Empty\")                else:            for i in range(self.no):                print(self.que[(i + self.front) % self.capacity], end='')                print()  que : 큐의 배열로서 밀어 넣는 데이터를 저장하는 list형 배열  capacity : 큐의 최대 크기를 나타내는 int 형 정수. 배열 queue 원소 수와 일치한다.  front, rear : 맨 앞 원소, 맨끝 원소.  no : 큐에 쌓여있는 데이터 개수를 나타내는 int형 정수. 변수 front와 rear값이 같을 경우 큐가 비어있는지, 가득 차 있는지 구별하기 위해 필요하다. 큐가 비어있다면 no 는 0이고, 가득 차있다면 no는 capacity 값과 같다."
  },
  
  {
    "title": "Set with Python",
    "url": "/posts/SET_with_python/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Set, Python",
    "date": "2022-02-01 11:00:00 +0900",
    





    
    "snippet": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dic...",
    "content": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dict'&gt;c = set()print(type(c)) #&lt;class 'set'&gt;2. 추가&amp;삭제#추가a = {1, 2, 3}a.add(4)print(a)&gt;&gt;&gt; {1, 2, 3, 4}#여러 값 추가a = {1, 2, 3}a.update({4, 5, 6})print(a)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6}#삭제a = {1, 2, 3}a.remove(2)print(a)&gt;&gt;&gt; {1, 3}3. 교집합&amp;합집합&amp;차집합  메서드나 연산자를 사용하여 구할 수 있다.set1 = {1, 2, 3, 4, 5, 6}set2 = {4, 5, 6, 7, 8, 9}#교집합print(set1 &amp; set2)&gt;&gt;&gt; {4, 5, 6}print(set1.intersection(set2))&gt;&gt;&gt; {4, 5, 6}#합집합print(set1 | set2)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}print(set1.union(set2))&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}#차집합print(set1 - set2)&gt;&gt;&gt; {1, 2, 3}print(set1.difference(set2))&gt;&gt;&gt; {1, 2, 3}4. list VS set (in 연산 시간복잡도 비교)  List 자료형에서는 in 연산자의 시간 복잡도는 O(n)이고,  set 자료형에서는 in 연산자의 시간 복잡도는 O(1)이다.import timeits = set(range(0, 1000000))l = list(range(0, 1000000))# setstart = timeit.default_timer()print(999999 in s)print(timeit.default_timer() - start) # liststart = timeit.default_timer()print(999999 in l)print(timeit.default_timer() - start)  print('-----------------------------------')#setstart = timeit.default_timer()for i in range(1000):    i+1000 in sprint(timeit.default_timer() - start) #list start = timeit.default_timer()for i in range(1000):    i+1000 in lprint(timeit.default_timer() - start) &gt;&gt;&gt;True0.00001733399403747171True0.010281834998750128-----------------------------------0.000097908006864599880.015224540999042802"
  },
  
  {
    "title": "배열과 리스트",
    "url": "/posts/%EB%B0%B0%EC%97%B4%EA%B3%BC_%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Array, List, Data Structure",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2 ...",
    "content": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2        값 3        값 4            배열의 특징  인덱스를 사용하여 값에 바로 접근 가능  새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.          값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요        배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 변경할 수 없다.리스트리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 구조리스트의 특징  인덱스가 없으므로 값에 접근하려면 Head 포인터로부터 순서대로 접근          즉, 값에 접근하는 속도가 느림        포인터로 연결되어 있으므로 데이터를 삽인하거나 삭제하는 연산 속도가 빠름  선언할 때 크기를 별도로 지정하지 않아도 된다.          리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.        포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡  ✅ 파이썬에서는 배열과 리스트를 구분하지 않는다.파이썬의 list는 리스트의 특징과 배열의 특징까지 모두 가지도록 구현되어 있다.Reference책 - Do it! 알고리즘 코딩 테스트 파이썬 편"
  },
  
  {
    "title": "객체 지향 프로그램 OOP",
    "url": "/posts/OOP/",
    "categories": "CS",
    "tags": "Computer Science, OOP",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 ...",
    "content": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 통하여 객체들이 서로 상호작용을 하는 구조로 전체 프로그램이 구현될 수 있도록 하는 것      로직에 구조를 더하기 위해 OOP를 사용      2. 사용이유  절차 지향 방식 -&gt; 데이터를 중심으로 함수 구현, 순차적인 처리 중요, C언어  객체 지향 방식 -&gt; 기능을 중심으로 함수 구현  OOP 사용의 핵심 이유 : 코드의 구조화          유지보수 용이 : 기능별로 구현되어 있기 때문에 일부가 고장나도 그 해당 부분만 고치면 됨      재활용 용이 : 정의한 class를 상속하고 확장하여 재사용할 수 있음      가독성 좋아짐      3. Class &amp; Object &amp; Instance1. 클래스(class)1) 개념  객체를 생성하기 위한 설계도  클래스를 잘 이해하는 것이 OOP의 기본  ex) Car라는 부류가 클래스(큰 개념, 범주) Car의 instance(실체)가 렉서스, bmw, 벤츠, 현대라는 객체인 것2) 구성  Class = Property + Method  Property(속성) : 해당 entity를 표현하는 data = 변수 = 명사  Method(기능) : 해당 entity가 가지고 있는 기능들 = 함수 = 동사2. 객체(Object)  클래스를 통해 정의된 설계도로 만들어진 프로그램  객체는 고유한 성격을 지니기 때문에 동일한 클래스로 만들어진 객체라도 다른 객체의 영향을 받지 않는다  객체는 클래스의 constructor 메소드로 생성된다.3. 인스턴스(Instance)  클래스로 만든 객체를 인스턴스라고도 함  객체가 개념이라면 인스턴스는 실체  인스턴스라는 말은 특정 객체가 어떤 클래스의 객체인지 관계를 위주로 설명할 때 사용  ex) 현대는 그 자체로는 인스턴스라기 보다는 객체이고,  class와의 관계에서 보면 Car의 객체라고 말하기보단 Car의 인스턴스라고 함4. The Four Pilars of OOP1. Encapsulation (캡슐화)  관련있는 변수와 함수를 하나의 단위로 묶는 것  자동차와 관련된 변수와 함수가 묶여있는 클래스 자체가 캡슐화의 예시class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"Information Hiding(정보 은닉)  속성이나 메소드같이 객체가 소유하는 것들을 다른 객체에 공개하지 않고 숨기는 것  외부 객체가 특정 객체의 데이터화 함수를 직접 접근하여 사용하거나 변경하지 못하므로 유지 보수와 소프트 웨어 확장시 오류를 최소화  속성과 메소드의 공개 범위를 access modifier(접근 제어자) 로 결정          public : 공개                  해당 클래스의 객체, 상속받는 클래스의 객체, 그리고 외부 객체 모두 다 접근 가능                    private : 숨김                  Private으로 지정된 property나 메소드는 해당 클래스의 객체 내부에서만 접근 가능          외부 객체는 접근이 막혀있음          상속받는 sub class도 직접적인 접근은 할 수 없고 상속받지 아니한다.                    protected : 숨김                  외부 객체는 접근이 막혀있음          상속받는 sub class는 접근 할 수 있고 상속 받는다.                    2. Abstraction (추상화)  객체들의 공통 특징(property, method)을 뽑아 하나의 클래스로 표현하는 것  객체의 관점에서 클래스를 정의하는 것  사자, 곰, 말 -&gt; 각각 객체이 객체들을 공통된 특징인 동물이나 생물로 묶는 것이 추상화3. Inheritance (상속성)  자식클래스(Sub Class)가 부모클래스(Base Class, Super Class)로부터 Property와 Method들을 상속받을 수 있는 특성class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"class Taxi(Car):    def take_passengers(self, passengers):        if passengers &gt; 4:            return \"5명 이상 못 탐\"        else:            return \"출발~\"taxi1 = Taxi(\"기아\", \"3,000만원\", \"orange\")print(taxi1.take_passengers(7)) # 5명 이상 못 탐print(taxi1.drive(120))# SPEEDING VIOLATION 🔵  Taxi 클래스는 자신의 고유 Method를 사용할 수 있는 것은 물론 Car 클래스를 상속받았기 때문에 Car 클래스 안의 Property(model, price, color) 와 Method(drive) 모두를 사용할 수 있다🔵  상속성을 사용하면 자식클래스에서 불필요하게 다시 정의할 일 없이 부모클래스의 코드를 재사용가능하기 때문에 중복을 방지할 수 있다  Overriding : 부모클래스의 메소드를 그대로 상속받지 않고 재정의해서 사용할 수 있는 기능4. Polymorphism (다형성)  하나의 형태가 다양한 유형으로 나타날 수 있는 특성  Overriding처럼 부모클래스의 메소드가 자식클래스에서 다양한 기능으로 나타날 수 있는 것도 한 예시  Overloading : 메소드의 이름은 같지만 매개변수가 다름          python 과 javascript는 overloading 함수를 지원하지 않음      ex) sum 이라는 같은 이름의 함수가 매개변수의 개수와 타입에 따라 각기 다른 3개의 메소드로 구현되고 있다      public class Math {      public int sum(int x, int y)    {        return (x + y);    }      public int sum(int x, int y, int z)    {        return (x + y + z);    }      public double sum(double x, double y)    {        return (x + y);    }      public static void main(String args[])    {        Math math = new Math();        System.out.println(math.sum(1, 2));        System.out.println(math.sum(3, 4, 5));        System.out.println(math.sum(7.7, 8.8));    }}  Duck Typing : “만약 어떤 것이 오리처럼 생겼고, 오리처럼 헤엄치고, 오리처럼 꽥꽥거린다면 그건 오리라고 봐야 한다”라는 오리 실험에서 유래된 것으로 동일한 변수와 메소드를 가지고 있는 객체는 동일한 타입으로 간주하는 typing 방법  서로 아무 상관없는 세 클라스 Truck, Bus, RaceCar는 모두 drive 메소드를 제공하기 때문에 Duck Typing 개념에 의하여 drive_car 함수 입장에서는 동일한 객체로 간주될 수 있다는 것이다.class Truck:  def drive(self):    print(\"Driving Truck\")  def stop(self):    print(\"Stoping Truck\")class Bus:\tdef drive(self):\t\tprint(\"Driving Bus\")\tdef stop(self):\t\tprint(\"Stoping Bus\")class RaceCar:\tdef drive(self):\t\tprint(\"Driving RaceCar\")\tdef stop(self):\t\tprint(\"Stoping RaceCar\")def drive_car(car):\tcar.drive()truck = Truck()bus = Bus()race_car = RaceCar()drive_car(truck) # Driving Truckdrive_car(bus) # Driving Busdrive_car(race_car) # Driving RaceCar  Polymorphism(다형성) 이 중요한 이유 polymorphism을 통해서 포괄적인(generic) 인터페이스 제공이 가능해지기 때문이다. 위 duck typing 코드 예제에세도, drive_car 함수는 실제 input으로 들어오는 객체의 타입이나 구현 내용이나 실행 로직에 대해서 확인하거나 인지할 필요가 없다. drive 메소드만 가지고 있다면 실행이 가능하기 때문이다. 그러므로 polymorphism을 통해 굉장히 유연하고 간단한 인터페이스 및 로직 구현이 가능해진다."
  },
  
  {
    "title": "Kream 사이트 클론 프로젝트",
    "url": "/posts/kream_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-06 10:00:00 +0900",
    





    
    "snippet": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 ...",
    "content": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 서비스 수준으로 개발할 수 있도록 2주간 고군분투 하였습니다.프로젝트 선정이유  조사결과, 해당 사이트의 경매 입찰 기능과 결제 플로우, 차트 구현, 상품리스트 필터 구현 등 배울 점이 많다고 판단하여 선정하게 되었습니다.📅 개발 기간 및 개발 인원  개발 기간 : 2021/10/18 ~ 2021/10/29  개발 인원  👨‍👧‍👦 Front-End 4명 : 김현진, 박산성, 이선호, 하상영 👨‍👧‍👦 Back-End 3명 : 박치훈, 양가현, 송영록  Back-end github 링크🎬 프로젝트 구현 영상  🔗 [구현영상] : https://youtu.be/N63MUdDmDFI⛓️ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia⚙️ 데이터베이스 Diagram💻 구현 기능Endpoint documentation - Postman APIBACKEND  로그인 구현import jwtimport requestsfrom json.decoder import JSONDecodeErrorfrom django.http  import JsonResponsefrom django.views import Viewfrom users.models import Userfrom my_settings  import SECRET_KEY, ALGORITHMSclass KakaoLogin(View):    def get(self, request):        try:             token = request.headers.get('Authorization')            if token == None:                return JsonResponse({'messsage': 'INVALID_TOKEN'}, status=401)            kakao_account = requests.get('https://kapi.kakao.com/v2/user/me', headers = {'Authorization': f'Bearer {token}'}).json()            print('::::kakao_account:', kakao_account)            if not User.objects.filter(kakao_id=kakao_account['id']).exists():                user = User.objects.create(                    kakao_id = kakao_account['id'],                    email    = kakao_account['kakao_account']['email'],                    name     = kakao_account['kakao_account']['profile']['nickname']                )            user = User.objects.get(kakao_id=kakao_account['id'])            access_token = jwt.encode({'user_id': user.id}, SECRET_KEY, algorithm=ALGORITHMS)            return JsonResponse({'access_token': access_token}, status=201)        except KeyError:            return JsonResponse({'message': 'KEY_ERROR'}, status=400)                except JSONDecodeError:            return JsonResponse({'message': 'JSON_DECODE_ERROR'}, status=400)        except jwt.DecodeError:            return JsonResponse({'message': 'JWT_DECODE_ERROR'}, status=400)        except ConnectionError:            return JsonResponse({'message': 'CONNECTION_ERROR'}, status=400)  카카오 연동 로그인 구현  Authorization 헤더에서 카카오 엑세스 토큰을 받아옴  request.get() 함수를 통해 카카오 API 엔드포인트로 사용자 정보 요청, json 형식으로 받아옴  카카오 아이디로 사용자 조회, 없으면 새로운 유저 생성  사용자 정보에서 user모델의 id를 이용하여 jwt 토큰 발급  jwt.encode()함수에 SECRET_KEY와 ALGORITHMS를 활용하여 JWT 토큰 생성 후 반환  프론트엔드에 발상할 오류의 종류를 예외처리하여 명확히 명시  로그인 데코레이터 구현import jsonimport jwtfrom django.http  import JsonResponsefrom my_settings  import SECRET_KEY, ALGORITHMSfrom users.models import Userdef login_decorator(func):    def wrapper(self, request, *args, **kwargs):        if 'Authorization' not in request.headers :             return JsonResponse ({'message' : 'UNAUTHORIZED'}, status=401)        access_token = request.headers.get('Authorization')                try:            payload      = jwt.decode(access_token, SECRET_KEY, algorithms=ALGORITHMS)            user         = User.objects.get(id=payload['user_id'])            request.user = user        except jwt.exceptions.DecodeError:            return JsonResponse({'MESSAGE': 'INVALID_TOKEN'}, status=401)        except User.DoesNotExist:            return JsonResponse({'MESSAGE': 'INVALID_USER'}, status=401)        return func(self, request,  *args, **kwargs)    return wrapper  python decorator 활용  로그인 성공 시 토큰 발급(jwt)  로그인 실패 시 예외처리  jwt.decode() 함수를 통해 토큰 검증  디코딩한 토큰에서 user_id 추출, user모델에서 해당 user_id 조회 후 가져옴  추출한 사용자를 request.user에 저장, 이후 로그인 상태 유지  상세 페이지class DetailProductView(View) :    def get(self, request, product_id) :        try :                           buy_price_filter  = (Q(productsize__bidding__bidding_position_id = 2) &amp; Q(productsize__bidding__bidding_status_id = 1))            sell_price_filter = (Q(productsize__bidding__bidding_position_id = 1) &amp; Q(productsize__bidding__bidding_status_id = 1))            if not Product.objects.filter(id = product_id).exists():                return JsonResponse({'MESSAGE':'product_id_not_exist'}, status = 404)                        product  = Product.objects\\                                    .annotate(buy_price = Min('productsize__bidding__price', filter = buy_price_filter),                                             sell_price = Max('productsize__bidding__price', filter = sell_price_filter))\\                                    .get(id = product_id)                                                                orders   = Order.objects.\\                                    filter(bidding__product_size__product_id = product_id).\\                                    order_by('-created_at')            wishlist = len(Wishlist.objects.filter(id=product_id).all())                        product_detail = [{                                'product_id'      : product.id,                                'name'            : product.name,                                'brand_name'      : product.brand.name,                                'release_price'   : product.release_price,                                'model_number'    : product.model_number,                                'image_list'      : [image.image_url for image in product.productimage_set.all()],                                'recent_price'    : orders.first().bidding.price if orders.exists() else None,                                'buy_price'       : product.buy_price,                                'sell_price'      : product.sell_price,                                'total_wishlist'  : wishlist,                            }]            return JsonResponse({'product_detail' : product_detail}, status=200)        except AttributeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)                except TypeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)  필터 조건 정의: 구매 입찰 정보중 입찰 상태가 유효한 조건(입찰 포지션 2, 상태가 1인 경우)과 판매 입찰 정보 중 입찰 상태가 유효한 조건(입찰 포지션 1, 상태가 1인 경우)  효율적인 데이터 처리와 코드의 간결성을 위하여 annotate()함수 활용  데이터베이스 단계서 집계 함수(Min, Max)를 활용하여 필요한 값을 미리 계산    상품 리스트 출력 API(ProductView)  브랜드 리스트 출력 API(BrandView)```pythonclass BrandView(View):    def get(self, request):            brands = Brand.objects.all()        brand_list = [{                    'brand_id'   : brand.id,                    'brand_name' : brand.name,                } for brand in brands]        return JsonResponse({'brand_list' : brand_list}, status = 200) ``` - 메인 페이지, 제품 페이지 상단 브랜드 출력을 위하여 API 작성❗ Reference  이 프로젝트는 KREAM 사이트를 참조하여 학습목적으로 만들었습니다.  실무수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제될 수 있습니다.  이 프로젝트에서 사용하고 있는 사진 모두는 copyright free 사이트들의 이미지들을 취합 및 canva 에서 직접 제작한 이미지들로 제작되었습니다."
  },
  
  {
    "title": "Spao 사이트 클론 프로젝트",
    "url": "/posts/Spao_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-05 10:00:00 +0900",
    





    
    "snippet": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획...",
    "content": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획 과정 없이 짧은 기간 안에 기술 습득 및 기본 기능 구현에 집중하기 위해서 SPAO 사이트를 참고.📅 개발 기간 및 개발 인원  개발 기간 : 2021-10-05 ~ 2021-10-15 (공휴일 포함)  개발 인원  👨‍👧‍👦 Front-End 3명 : 강성구, 김현진, 정경훈  👨‍👧‍👦 Back-End 3명 : 김주현, 이기용, 송영록⚙ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia🗜 데이터베이스 Diagram(클릭 시 해당 링크로 이동합니다)💻 구현 기능BACKEND  회원가입 API  jwt와 bcrpyt를 이용한 로그인 API  장바구니 상품 추가, 수정, 삭제 API⌨ EndPoint  POST/users/signup (회원가입)  POST/users/signin (로그인)  POST/orders/cart (장바구니 생성)  GET/orders/cart (장바구니 조회)  PATCH/orders/cart (장바구니 수정)  DEL/orders/cart (장바구니 삭제)  POST/postings  (후기 등록)  POST/postings/comments (댓글 등록)  POST/postings/ (댓글 삭제)  POST/products/menus (메뉴 항목 추가)  GET/products/menus (메뉴 항목 리스트 조회)  POST/products/categories (카테고리 항목 추가)  GET/products// (특정 메뉴별 카테고리 항목 리스트 조회)  POST/products (상품 등록)  GET/products// (특정 메뉴-카테고리별 상품 리스트 조회)  GET/products/ (특정 상품에 대한 상세페이지)❗ Reference  이 프로젝트는 SPAO 사이트를 참조하여 학습목적으로 만들었습니다.  실무 수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다.🙏 help  프로젝트 상품 이미지 출처원 : MIDEOCK-미덕 , SARNO-사르노 *이미지 사용을 허가해주신 대표님들께 감사합니다.  해당 프로젝트의 이미지를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다."
  },
  
  {
    "title": "Django project 초기세팅",
    "url": "/posts/Django_Project_%EC%B4%88%EA%B8%B0%EC%84%B8%ED%8C%85/",
    "categories": "Django",
    "tags": "Django",
    "date": "2022-01-04 10:00:00 +0900",
    





    
    "snippet": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 ...",
    "content": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 후 mysql로 전환# 데이터베이스 생성mysql&gt; create database NAME character set utf8mb4 collate utf*mb4_general_ci; Project Python Package 설치$ pip install django# 이후에 MySQL server에 접속하기 위한 package$ pip install mysqlclient  (중요) mysql 설치되어 있는지 먼저 확인# 맥북은 mysqlclient를 다운받으려면 오류가 난다 그러므로 PyMySQL을 다운받자$ pip install PyMySQL#!밑글에 pymysql 세팅법을 적어놓음Django Project 생성$ django-admin startproject westarbucks$ cd westarbucksSettings.py 설정. IP허용\tALLOWED_HOSTS = ['*']. 추가로 westarbucks/urls.py를 아래와 같이 수정from django.urls import pathurlpatterns = []. 주석처리(admin, csrf, auth)my_settings.py 생성(DATABASES,SECRET_KEY). django 설정에 존재하는 내용 중 SECRET_KEY, DATABASE 등은 절대 settings.py에 두면 안됩니다.. 그대로 깃이나 오픈클라우드에 올려버리면 해킹을 당하기가 쉽습니다. 아니 당합니다!. 그래서 별도의 참조용 파이썬 파일(my_settings.py)을 생성해서, 참조하는 방법으로 진행cd '생성한 프로젝트 폴더명'touch my_settings.py. 파일에 실제 쓰여지는 내용#예시DATABASES = {    'default' : {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'DATABASE 명',        'USER': 'DB접속 계정명',        'PASSWORD': 'DB접속용 비밀번호',        'HOST': '127.0.0.1',        'PORT': '3306',    }}SECRET_KEY = '시크릿키' #settings.py에 있는 secret_key 를 사용합니다.settings.py &lt;-&gt; my_settings.py 연동#intel 맥북from pathlib\t\timport Path #기존에 settings.py에 있는 코드from my_settings\timport DATABASES, SECRET_KEYDATABASES = DATABASESSECRET_KEY = SECRET_KEY#### m1 맥북!!# $ pip install PyMySQL# 으로 PyMySQL을 다운받는거 잊지말자from pathlib        import Path #기존에 settings.py 에 있는 코드from my_settings import DATABASES, SECRET_KEYimport pymysqlpymysql.install_as_MySQLdb().corsheaderspip install django-cors-headers. 설치했다면 settings.py에 INSTALLED_APPS 안에 추가INSTALLED_APPS = [...\t\t'corsheaders']. middleware 추가MIDDLEWARE = [\t...\t\t'corsheaders.middleware.CorsMiddleware',\t...]. CORS 추가 설정##CORSCORS_ORIGIN_ALLOW_ALL=TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = (    'DELETE',    'GET',    'OPTIONS',    'PATCH',    'POST',    'PUT',)CORS_ALLOW_HEADERS = (    'accept',    'accept-encoding',    'authorization',    'content-type',    'dnt',    'origin',    'user-agent',    'x-csrftoken',    'x-requested-with',)서버 정상 동작 확인. 서버 동작(Runserver)을 통한 오류 검증python manage.py runserver. 정상 동작 예시이제 프로젝트를 위한 초기 세팅은 끝났다~프로젝트를 진행해보자!"
  }
  
]

