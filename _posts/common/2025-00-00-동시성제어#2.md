---
title: "#2 동시성 제어 그리고 Django"
description: "Django에서는 동시성 제어를 어떻게 해야할까?"
date: 2025-06-04 10:00:00 +0900
categories: [CS, Common]
tags: [CS, Common, Concurrency, Database, Multithreading, Transaction, Lock, Django]
---

# Django에서는 동시성(Concurrency)을 어떻게 제어할까?

## 1. 데이터베이스 동시성 제어 (DB Concurrency Control)
DJnago의 ORM을 활용한 데이터베이스 락(Lock) 방식을 주로 사용한다.

- **select_for_update()**: 데이터 조회 시 행 단위의 락을 걸어, 특정 데이터를 다른 트랜잭션이 수정하지 못하도록 제어. 즉, 트랜잭션 종료 시까지 다른 트랜잭션의 접근을 막는다. 
- 트랜잭션 범위(transaction.atomic) 내에서만 유효하며, 트랜잭션이 끝나면 자동으로 해제된다.

```python
from django.db import transaction
from shop.models import Inventory

# 재고 감소 처리 (트랜잭션 내 동시 접근 제한)
with transaction.atomic():
    inventory_item = Inventory.objects.select_for_update().get(product_id=1001)
    if inventory_item.quantity > 0:
        inventory_item.quantity -= 1
        inventory_item.save()

이 코드가 실행 되는 동안 동일한 상품의 재고 데이터는 다른 트랜잭션에서 변경할 수 없으며, 변경이 완료된 후에야 다른 트랜잭션에서 접근이 가능하다.
```
- select_for_update()를 통해 다른 트랜잭션이 데이터를 읽거나 수정하는 것을 방지해 동시성 문제를 해결
- 주로 금융 거래나 재고 관리와 같은 민감한 데이터 처리에 적합

## 2. 낙관적 잠금(Optimistic Locking)
데이터 변경 충돌이 발생했을 때만 충돌 여부를 검사하여 처리

버전 필드(version field)를 사용해 변경이 발생할 때마다 버전을 체크하고, 충돌 시 다시 시도하거나 예외처리한다.

