---
title: "Django API 멱등성 테스트와 트러블슈팅"
description: "Django REST API의 멱등성 처리, 테스트 코드, 그리고 실전 트러블슈팅 경험 정리"
date: 2025-08-01 10:00:00 +0900
categories: [Django, Testing]
tags: [django, drf, api, idempotency, test]
---



루트 url

```python
#config/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("v1/", include("coupons.urls")),  # ← coupons 앱의 라우트
]

```

DB 모델

```python
#config/models.py
from django.db import models
from django.utils import timezone
from datetime import timedelta

def idempotency_default_expiry():
    return timezone.now() + timedelta(hours=24)

class CouponBatch(models.Model):
    DISCOUNT_FIXED = "fixed"
    DISCOUNT_PERCENT = "percent"
    DISCOUNT_CHOICES = [(DISCOUNT_FIXED, "fixed"), (DISCOUNT_PERCENT, "percent")]

    name = models.CharField(max_length=80)
    discount_type = models.CharField(max_length=10, choices=DISCOUNT_CHOICES)
    amount = models.IntegerField(null=True, blank=True)   # fixed일 때 사용
    percent = models.IntegerField(null=True, blank=True)  # percent일 때 1..100
    per_user_limit = models.IntegerField(default=1)
    total_limit = models.IntegerField()
    expires_at = models.DateTimeField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.name} ({self.discount_type})"

class Coupon(models.Model):
    STATUS_ISSUED = "issued"
    STATUS_REDEEMED = "redeemed"
    STATUS_CANCELLED = "cancelled"
    STATUS_EXPIRED = "expired"
    STATUS_CHOICES = [
        (STATUS_ISSUED, "issued"),
        (STATUS_REDEEMED, "redeemed"),
        (STATUS_CANCELLED, "cancelled"),
        (STATUS_EXPIRED, "expired"),
    ]

    batch = models.ForeignKey(CouponBatch, on_delete=models.PROTECT, related_name="coupons")
    code = models.CharField(max_length=16, unique=True)
    issued_to = models.CharField(max_length=64, null=True, blank=True)
    issued_at = models.DateTimeField(null=True, blank=True)
    status = models.CharField(max_length=12, choices=STATUS_CHOICES, default=STATUS_ISSUED)
    redeemed_by = models.CharField(max_length=64, null=True, blank=True)
    redeemed_at = models.DateTimeField(null=True, blank=True)
    order_id = models.CharField(max_length=64, null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.code} [{self.status}]"

class IdempotencyKey(models.Model):
    key = models.CharField(max_length=64, unique=True)
    user_id = models.CharField(max_length=64)
    request_fingerprint = models.CharField(max_length=128, null=True, blank=True)
    response_status = models.IntegerField(null=True, blank=True)
    response_body = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(default=idempotency_default_expiry)

```

시리얼라이저
```python
#config/serializers.py
from rest_framework import serializers
from .models import CouponBatch, Coupon

class CouponBatchCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = CouponBatch
        fields = ["id", "name", "discount_type", "amount", "percent",
                  "per_user_limit", "total_limit", "expires_at"]

    def validate(self, attrs):
        dt = attrs.get("discount_type")
        if dt == CouponBatch.DISCOUNT_FIXED:
            if attrs.get("amount") is None:
                raise serializers.ValidationError("amount is required for fixed discount_type")
        elif dt == CouponBatch.DISCOUNT_PERCENT:
            p = attrs.get("percent")
            if p is None or not (1 <= p <= 100):
                raise serializers.ValidationError("percent must be 1..100 for percent discount_type")
        else:
            raise serializers.ValidationError("invalid discount_type")
        return attrs

class CouponSerializer(serializers.ModelSerializer):
    class Meta:
        model = Coupon
        fields = ["id", "code", "status", "issued_to", "issued_at",
                  "redeemed_by", "redeemed_at", "order_id"]

```

서비스로직
```python
#config/services.py
import secrets, string
from django.db import transaction
from django.utils import timezone
from .models import Coupon, CouponBatch

CODE_ALPHABET = string.ascii_uppercase + string.digits

def _gen_code(length: int = 10) -> str:
    return "".join(secrets.choice(CODE_ALPHABET) for _ in range(length))

@transaction.atomic
def issue_coupon(*, batch_id: int, user_id: str) -> Coupon:
    batch = CouponBatch.objects.select_for_update().get(id=batch_id)

    if batch.expires_at <= timezone.now():
        raise ValueError("BATCH_EXPIRED")
    if Coupon.objects.filter(batch=batch, issued_to=user_id).count() >= batch.per_user_limit:
        raise ValueError("PER_USER_LIMIT_REACHED")
    if Coupon.objects.filter(batch=batch).count() >= batch.total_limit:
        raise ValueError("BATCH_LIMIT_REACHED")

    # 코드 충돌 대비 재시도
    for _ in range(5):
        code = _gen_code()
        if not Coupon.objects.filter(code=code).exists():
            break
    else:
        raise RuntimeError("CODE_GENERATION_FAILED")

    return Coupon.objects.create(
        batch=batch,
        code=code,
        issued_to=user_id,
        issued_at=timezone.now(),
        status=Coupon.STATUS_ISSUED,
    )

@transaction.atomic
def redeem_coupon(*, code: str, user_id: str, order_id: str) -> Coupon:
    coupon = Coupon.objects.select_for_update().select_related("batch").get(code=code)

    if coupon.batch.expires_at <= timezone.now():
        raise ValueError("COUPON_EXPIRED")
    if coupon.status == Coupon.STATUS_REDEEMED:
        raise ValueError("COUPON_ALREADY_REDEEMED")
    # 본인만 사용 정책이면 주석 해제
    # if coupon.issued_to and coupon.issued_to != user_id:
    #     raise ValueError("COUPON_OWNERSHIP_MISMATCH")

    coupon.status = Coupon.STATUS_REDEEMED
    coupon.redeemed_by = user_id
    coupon.redeemed_at = timezone.now()
    coupon.order_id = order_id
    coupon.save(update_fields=["status", "redeemed_by", "redeemed_at", "order_id"])
    return coupon

```

멱등성 데코레이터
```python
#config/idempotency.py
# coupons/idempotency.py
import hashlib, json
from functools import wraps
from django.db import transaction
from rest_framework.response import Response
from .models import IdempotencyKey

def _fingerprint(path: str, body: dict):
    data = json.dumps({"path": path, "body": body}, sort_keys=True, separators=(",", ":")).encode()
    return hashlib.sha256(data).hexdigest()

def _get_idempotency_key(request):
    req = getattr(request, "_request", request)
    return (
        getattr(request, "headers", {}).get("Idempotency-Key")
        or getattr(req, "META", {}).get("HTTP_IDEMPOTENCY_KEY")
        or getattr(req, "META", {}).get("Idempotency-Key")
        or getattr(req, "META", {}).get("HTTP_IDEMPOTENCYKEY")
    )

def idempotent_view(view_func):
    @wraps(view_func)
    def wrapper(self, request, *args, **kwargs):
        key = _get_idempotency_key(request)
        if not key:
            return Response(
                {"error": {"code": "IDEMPOTENCY_KEY_REQUIRED", "message": "Provide Idempotency-Key"}},
                status=400,
            )

        body = getattr(request, "data", {}) or {}
        fp = _fingerprint(request.path, body)

        # 선점/재사용: 트랜잭션에서 get_or_create 사용
        with transaction.atomic():
            obj, created = IdempotencyKey.objects.get_or_create(
                key=key,
                defaults={
                    "user_id": str(getattr(request.user, "id", "anon")),
                    "request_fingerprint": fp,
                },
            )
            if not created:
                if obj.request_fingerprint and obj.request_fingerprint != fp:
                    return Response(
                        {"error": {
                            "code": "IDEMPOTENCY_KEY_BODY_MISMATCH",
                            "message": "Idempotency-Key reused with different body",
                        }},
                        status=409,
                    )
                if obj.response_status is not None:
                    # ✅ 항상 DRF Response로 반환
                    return Response(obj.response_body or {}, status=obj.response_status)
                # (희귀) 선행 요청 처리 중
                return Response(
                    {"error": {"code": "REQUEST_IN_PROGRESS", "message": "Try again shortly."}},
                    status=409,
                )

        # 최초 처리
        response = view_func(self, request, *args, **kwargs)

        # 응답 저장 (분리된 트랜잭션)
        with transaction.atomic():
            IdempotencyKey.objects.filter(key=key).update(
                response_status=response.status_code,
                response_body=(getattr(response, "data", None) or {}),
            )

        return response
    return wrapper

```

view
```python
#config/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Q
from .serializers import CouponBatchCreateSerializer, CouponSerializer
from .models import Coupon, CouponBatch
from .services import issue_coupon, redeem_coupon
from .idempotency import idempotent_view

class CouponBatchCreate(APIView):
    @idempotent_view
    def post(self, request):
        ser = CouponBatchCreateSerializer(data=request.data)
        ser.is_valid(raise_exception=True)
        batch = ser.save()
        return Response(CouponBatchCreateSerializer(batch).data, status=status.HTTP_201_CREATED)

class CouponIssue(APIView):
    @idempotent_view
    def post(self, request):
        batch_id = request.data.get("batch_id")
        user_id = request.data.get("user_id")
        if not batch_id or not user_id:
            return Response({"error":{"code":"VALIDATION","message":"batch_id and user_id are required"}}, status=400)
        try:
            coupon = issue_coupon(batch_id=batch_id, user_id=user_id)
        except CouponBatch.DoesNotExist:
            return Response({"error":{"code":"BATCH_NOT_FOUND"}}, status=404)
        except ValueError as e:
            return Response({"error":{"code":str(e)}}, status=409)
        return Response(CouponSerializer(coupon).data, status=200)

class CouponRedeem(APIView):
    @idempotent_view
    def post(self, request):
        code = request.data.get("code")
        order_id = request.data.get("order_id")
        user_id = request.data.get("user_id")
        if not code or not order_id or not user_id:
            return Response({"error":{"code":"VALIDATION","message":"code, order_id, user_id are required"}}, status=400)
        try:
            coupon = redeem_coupon(code=code, user_id=user_id, order_id=order_id)
        except Coupon.DoesNotExist:
            return Response({"error":{"code":"COUPON_NOT_FOUND"}}, status=404)
        except ValueError as e:
            return Response({"error":{"code":str(e)}}, status=409)
        return Response(CouponSerializer(coupon).data, status=200)

class CouponList(APIView):
    def get(self, request):
        user_id = request.GET.get("user_id")
        status_q = request.GET.get("status")
        qs = Coupon.objects.all().order_by("-created_at")
        if user_id:
            qs = qs.filter(Q(issued_to=user_id) | Q(redeemed_by=user_id))
        if status_q:
            qs = qs.filter(status=status_q)
        return Response({"items": CouponSerializer(qs[:50], many=True).data})

```

coupons URL
```python
#coupons/urls.py
from django.urls import path
from .views import CouponBatchCreate, CouponIssue, CouponRedeem, CouponList

urlpatterns = [
    path("coupon-batches/", CouponBatchCreate.as_view()),
    path("coupons/issue/",   CouponIssue.as_view()),
    path("coupons/redeem/",  CouponRedeem.as_view()),
    path("coupons/",         CouponList.as_view()),
]

```

pytest
```python
#coupons/tests.py
import pytest
from django.utils import timezone
from rest_framework.test import APIClient
from coupons.models import CouponBatch

pytestmark = pytest.mark.django_db

def _mk_batch(**kwargs):
    defaults = dict(
        name="Welcome 10%",
        discount_type="percent",
        percent=10,
        per_user_limit=1,
        total_limit=1000,
        expires_at=timezone.now() + timezone.timedelta(days=365),
    )
    defaults.update(kwargs)
    return CouponBatch.objects.create(**defaults)

def test_issue_and_redeem_idempotent_flow():
    c = APIClient()
    batch = _mk_batch()

    r1 = c.post("/v1/coupons/issue/", {"batch_id": batch.id, "user_id": "u1"}, format="json",
                HTTP_IDEMPOTENCY_KEY="iss-1")
    assert r1.status_code == 200
    code = r1.data["code"]

    r2 = c.post("/v1/coupons/issue/", {"batch_id": batch.id, "user_id": "u1"}, format="json",
                HTTP_IDEMPOTENCY_KEY="iss-1")
    assert r2.status_code == 200 and r2.data["code"] == code

    r3 = c.post("/v1/coupons/issue/", {"batch_id": batch.id, "user_id": "u1"}, format="json",
                HTTP_IDEMPOTENCY_KEY="iss-2")
    assert r3.status_code == 409 and r3.data["error"]["code"] == "PER_USER_LIMIT_REACHED"

    rr1 = c.post("/v1/coupons/redeem/", {"code": code, "order_id": "ord_1", "user_id": "u1"}, format="json",
                 HTTP_IDEMPOTENCY_KEY="red-1")
    assert rr1.status_code == 200 and rr1.data["status"] == "redeemed"

    rr2 = c.post("/v1/coupons/redeem/", {"code": code, "order_id": "ord_1", "user_id": "u1"}, format="json",
                 HTTP_IDEMPOTENCY_KEY="red-1")
    assert rr2.status_code == 200 and rr2.data["code"] == code

    rr3 = c.post("/v1/coupons/redeem/", {"code": code, "order_id": "ord_1", "user_id": "u1"}, format="json",
                 HTTP_IDEMPOTENCY_KEY="red-2")
    assert rr3.status_code == 409 and rr3.data["error"]["code"] == "COUPON_ALREADY_REDEEMED"

```



---

# 1) `REST_FRAMEWORK` 설정 못 찾음 (settings 미로드)

**증상**
`ImproperlyConfigured: Requested setting REST_FRAMEWORK, but settings are not configured.`

**원인**
Django 설정이 로드되기 전에 DRF가 import됨. (`DJANGO_SETTINGS_MODULE` 미설정)

**해결**

* 루트에 `pytest.ini` 추가:

  ```ini
  [pytest]
  DJANGO_SETTINGS_MODULE = config.settings
  ```
* 또는 테스트 파일 최상단에:

  ```python
  import os, django
  os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
  django.setup()
  ```

---

# 2) 첫 요청이 400(Bad Request)

**증상**
`assert r1.status_code == 200` 실패 (400 반환)

**원인**
멱등성 데코레이터가 `Idempotency-Key` 헤더를 못 읽음. DRF/테스트 환경마다 헤더가 `request.headers` 또는 `request.META['HTTP_IDEMPOTENCY_KEY']`로 들어올 수 있는데, 한 쪽만 읽고 있었다.

**해결**
헤더 추출 유틸을 만들어 **모든 경로에서 안전하게** 읽도록 보강:

```python
def _get_idempotency_key(request):
    req = getattr(request, "_request", request)  # DRF Request -> WSGIRequest
    return (
        getattr(request, "headers", {}).get("Idempotency-Key")
        or getattr(req, "META", {}).get("HTTP_IDEMPOTENCY_KEY")
        or getattr(req, "META", {}).get("Idempotency-Key")
        or getattr(req, "META", {}).get("HTTP_IDEMPOTENCYKEY")
    )
```

테스트에서는 항상 `HTTP_IDEMPOTENCY_KEY="..."`로 전달 ✅

---

# 3) APIView 데코레이터 시그니처 문제

**증상**
여전히 400 / 기대와 다른 동작

**원인**
메서드 데코레이터가 `self`를 받지 않도록 구현됨 → `request` 자리에 `self`가 들어가 버려 내부 로직이 꼬임.

**해결**
데코레이터 래퍼 시그니처를 **메서드 형태**로:

```python
def wrapper(self, request, *args, **kwargs):
    # ...
    response = view_func(self, request, *args, **kwargs)
```

---

# 4) `IntegrityError` → `TransactionManagementError`

**증상**
`UNIQUE constraint failed: coupons_idempotencykey.key` 이후
`TransactionManagementError: You can't execute queries until the end of the 'atomic' block.`

**원인**
`atomic()` 블록 안에서 `IdempotencyKey`를 `create()`하다가 **유니크 충돌**이 나면 트랜잭션이 “깨진 상태”가 됨. 그 상태로 계속 쿼리를 해서 2차 에러 발생.

**해결**
\*\*`get_or_create`\*\*로 전환해 유니크 레이스를 한 번에 처리.
또한 “최초 생성/재사용” 분기 후, **뷰 실행은 트랜잭션 밖**, 응답 저장은 **별도의 트랜잭션**에서 수행:

```python
with transaction.atomic():
    obj, created = IdempotencyKey.objects.get_or_create(key=key, defaults={...})
    if not created:
        # body mismatch → 409
        # response 저장돼 있으면 그대로 반환
# 트랜잭션 밖에서 뷰 실행
response = view_func(self, request, *args, **kwargs)
# 응답 저장은 다시 atomic
with transaction.atomic():
    IdempotencyKey.objects.filter(key=key).update(...)
```

---

# 5) `AttributeError: 'JsonResponse' object has no attribute 'data'`

**증상**
두 번째 요청(r2)에서 `.data` 접근 시 크래시

**원인**
캐시된 응답을 돌려줄 때 `JsonResponse`를 반환해서, DRF 테스트 클라이언트가 기대하는 `.data` 속성이 없음.

**해결**
**항상 DRF `Response`** 를 반환:

```python
from rest_framework.response import Response
# ...
return Response(obj.response_body or {}, status=obj.response_status)
```

---

## 최종 정리: 멱등성 데코레이터 핵심 형태

* 메서드 시그니처: `wrapper(self, request, *args, **kwargs)`
* 헤더 안전 추출: `_get_idempotency_key(request)`
* 레이스 처리: `get_or_create`
* 트랜잭션 경계: 선점은 atomic, 뷰는 밖, 응답 저장은 다시 atomic
* 반환 타입 통일: DRF `Response`

이렇게 정리하고 나니 테스트 **PASS**
