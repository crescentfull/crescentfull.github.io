---
title: "I/O Bound와 CPU Bound"
description: "I/O Bound와 CPU Bound에 대한 설명, 컴퓨터 공학적으로의 주요 관점, 간단한 예"
date: 2023-03-07 10:00:00 +0900
categories: [CS, Common]
tags: [Computer Science, I/O Bound, CPU Bound]
---

# **I/O Bound와 CPU Bound**

I/O Bound와 CPU Bound는 컴퓨터 성능의 병목(bottleneck)이 어디에 존재하는지에 따라 구분하는 개념이다. 이는 시스템에서 작업을 수행할 때 무엇이 작업 속도를 결정하는 주요 요인인지 파악하는 데 사용된다.

---

### **1. I/O Bound**
- **정의**  
  작업의 속도가 I/O(입출력) 작업, 즉 **디스크, 네트워크, 메모리 접근**과 같은 데이터 전송 작업에 의해 제한되는 경우를 의미한다.
- **특징**
  - CPU는 상대적으로 할 일이 적어 작업의 대부분 시간을 **I/O가 완료되기를 기다리는 데 소모**한다.
  - 예:
    - 네트워크에서 데이터를 다운로드하는 작업.
    - 대량의 데이터를 디스크에서 읽고 쓰는 작업.
    - 데이터베이스에서 정보를 가져오는 작업.
  - 병목 현상이 발생하는 원인은 느린 I/O 장치이다.
- **해결 방법**
  - **비동기(Asynchronous) 처리**: I/O 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행.
  - **캐싱(Caching)**: 자주 접근하는 데이터를 메모리에 저장해 접근 속도를 높임.
  - **병렬 처리**: 여러 I/O 작업을 동시에 수행.

---

### **2. CPU Bound**
- **정의**  
  작업의 속도가 CPU 계산 작업에 의해 제한되는 경우를 의미한다. 즉, I/O 작업은 충분히 빠르지만 CPU가 작업을 처리하는 데 시간이 많이 걸린다.
- **특징**
  - 작업 대부분의 시간이 **복잡한 계산 또는 알고리즘 실행**에 소비된다.
  - 예:
    - 대규모 행렬 연산.
    - 머신러닝 모델 훈련.
    - 복잡한 시뮬레이션 계산.
  - 병목 현상이 발생하는 원인은 CPU의 처리 능력 한계이다.
- **해결 방법**
  - **코드 최적화**: 알고리즘 개선, 컴파일러 최적화 등을 통해 연산 속도를 높임.
  - **병렬 처리**: 멀티코어 프로세서를 활용해 계산을 분산.
  - **GPU 활용**: 병렬 계산에 특화된 GPU를 활용해 연산 속도를 높임.

---

### **I/O Bound vs CPU Bound 비교**

| 구분          | I/O Bound                            | CPU Bound                              |
|---------------|--------------------------------------|---------------------------------------|
| **병목 원인** | 디스크, 네트워크, 메모리 등 I/O 속도 | CPU 연산 속도                         |
| **작업 특징** | I/O 작업 대기 시간이 길다            | 복잡한 연산이나 알고리즘 수행 시간이 길다 |
| **해결 방법** | 비동기 처리, 캐싱, 병렬 I/O          | 코드 최적화, 멀티코어 활용, GPU 사용  |
| **예시**      | 파일 읽기/쓰기, 데이터베이스 쿼리    | 머신러닝, 시뮬레이션 계산             |

---

### **컴퓨터 공학적으로의 주요 관점**
1. **멀티태스킹과 효율성**  
   - **I/O Bound** 작업은 CPU가 놀고 있을 가능성이 크므로, 멀티스레딩이나 비동기 프로그래밍을 활용해 **CPU 활용률**을 높일 수 있다.
   - **CPU Bound** 작업은 반대로 CPU가 항상 바쁘므로 연산 병렬화가 중요하다.

2. **프로파일링**  
   - 프로그램이 I/O Bound인지 CPU Bound인지 확인하려면 **프로파일러**를 사용해 병목이 발생하는 부분을 분석해야 한다.

3. **운영체제와 스케줄링**  
   - 운영체제는 I/O Bound 프로세스에 대해 **입출력 완료를 기다리는 동안** 다른 프로세스에게 CPU를 양보하는 방식으로 효율성을 높인다.
   - CPU Bound 프로세스는 스케줄러에 의해 CPU 점유 시간을 할당받는다.

---

### **간단한 예**
#### **I/O Bound 코드**
```python
import time

# 네트워크 호출 시뮬레이션 (느린 I/O)
def fetch_data():
    time.sleep(2)  # I/O 대기 시간
    return "data"

start = time.time()
data = fetch_data()  # 작업 대기
end = time.time()
print(f"Time taken: {end - start}s")  # 느린 I/O 대기 때문에 지연
```

#### **CPU Bound 코드**
```python
import math

# 대규모 계산 작업
def calculate():
    result = 0
    for i in range(10**7):
        result += math.sqrt(i)
    return result

start = time.time()
result = calculate()  # CPU 계산에 시간 소모
end = time.time()
print(f"Time taken: {end - start}s")  # CPU 연산 때문에 지연
```

---

### **결론**
- **I/O Bound** 작업은 CPU가 충분히 빠르지만 느린 입출력 장치가 병목이다.
- **CPU Bound** 작업은 입출력이 충분히 빠르지만 CPU가 병목이다.
- 문제의 성격에 따라 비동기 처리, 병렬 처리, GPU 활용 등의 최적화 기법을 적절히 적용해야 한다.