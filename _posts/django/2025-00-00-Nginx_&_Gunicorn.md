---
title: "macOS에서 Nginx·Gunicorn으로 Django 배포하기 #1"
description: "Nginx·Gunicorn 개념 설명"
date: 2025-05-01 10:00:00 +0900
categories: [Django, Deployment]
tags: [Django, Nginx, Gunicorn, macOS]
---

이번에 새롭게 토이프로젝트를 진행하면서 실제 사용자들을 위해서 서버 배포를 해야할 일이 생겼다.
비용 문제로 pythonanywhere나 render 같은 호스팅 사이트를 알아보는 중에,
일단 배포를 하기 전, nginx 와 gunicorn에 대해 제대로 짚고 넘어가야할 것 같아서 포스팅을 한다.

*Django 프로젝트이기 때문에 Django중심으로 

# Django 프로덕션 배포: Nginx와 Gunicorn을 함께 사용하는 이유

## 1. Nginx와 Gunicorn의 역할 (개발 서버와의 차이)

Django 애플리케이션을 운영 환경에 배포할 때는 **Nginx**와 **Gunicorn**을 조합하는 것이 일반적이다. 이 둘은 서로 보완적인 역할을 맡는다. **Nginx**는 클라이언트의 HTTP 요청을 가장 앞단에서 받아들이는 **웹 서버(리버스 프록시)** 로서, 기본적으로 80번 포트(HTTP)와 443번 포트(HTTPS)를 수신하며, URL에 따른 리다이렉트나 인증, SSL/TLS 인증서 관리 등을 처리한 뒤 최종적으로 해당 요청을 어디로 보낼지 결정한다. 

- 예를 들어, 정적 파일 요청은 Nginx가 직접 처리하고, `/api`로 시작하는 요청은 Node.js 백엔드로 보내며, 그 외 대부분의 요청은 Django 애플리케이션을 구동하는 Gunicorn으로 전달하는 식이다. 이러한 **역방향 프록시(reverse proxy)** 기능을 통해 Nginx는 여러 백엔드 서비스(Gunicorn을 포함)에 트래픽을 분배한다.

한편 **Gunicorn**(Green Unicorn)은 Python WSGI(Web Server Gateway Interface) 서버로, **HTTP 요청을 Python 애플리케이션이 이해할 수 있는 형태로 변환**해주는 역할을 한다. 

Django 애플리케이션은 일반적으로 WSGI 프로토콜을 통해 웹 서버와 소통하는데, Gunicorn이 이러한 WSGI 서버 역할을 담당하여, 들어온 HTTP 요청의 헤더나 데이터를 파이썬 객체로 변환한 뒤 Django의 `wsgi.py` 어플리케이션에 전달하고 응답을 받아 다시 HTTP 응답으로 반환한다. 

> 개발 단계에서 자주 사용하는 `python manage.py runserver` 명령이 실행하는 **내장 개발용 서버**도 기본적으로 WSGI 요청 처리 기능을 갖추고 있지만, 이는 **자동 리로드** 등 개발 편의를 위해 만들어진 것으로 **오로지 개발 환경에서만 쓰도록 설계**되었다.   
> 즉, Django 프레임워크 자체는 웹 서버 기능을 간단히 제공할 뿐, **실제 운영 환경에서 사용될 견고한 웹 서버**를 지향하지 않는다. Django 공식 문서에서도 내장 서버는 **보안 검증이나 성능 최적화가 되어 있지 않으므로 절대 운영 환경에서 사용하지 말라**고 명시하고 있다. 

따라서 **Gunicorn과 같은 별도의 WSGI 서버**가 필요하며, 여기에 **Nginx를 조합**하여 외부 요청 처리와 애플리케이션 실행을 역할 분담하는 것이 표준적인 배포 방식이다.

| 구성 요소        | 역할                                                                                                 |
| ------------ | -------------------------------------------------------------------------------------------------- |
| **Nginx**    | • 리버스 프록시(80/443 포트)로 외부 요청 수신<br>• SSL/TLS 종료(HTTPS)<br>• 정적·미디어 파일 직접 서빙<br>• 방화벽, 요청 필터링, 로드밸런싱 |
| **Gunicorn** | • WSGI 애플리케이션 서버<br>• 멀티 워커 프로세스로 동적 요청 처리<br>• Django `wsgi.py` 호출하여 HTTP 요청 ↔ 파이썬 객체 변환          |

---

## 2. 성능 차이: Django 개발 서버 vs Gunicorn

Django 내장 개발 서버(`runserver`)와 Gunicorn 사이에는 **구조적인 차이**로 인한 **처리 성능** 격차가 크다. 가장 큰 차이는 **동시 요청 처리 능력**이다. Gunicorn은 **프리 포크(pre-fork) 방식**으로 여러 개의 **워커 프로세스**를 미리 실행하여 각각의 요청을 병렬로 처리할 수 있다. 

- 예를 들어 CPU 코어 수에 맞춰 3개, 5개 등의 워커를 띄워 두면 동시에 들어오는 여러 요청을 각기 다른 프로세스가 병렬 처리하므로 멀티코어 자원을 효율적으로 활용할 수 있다. 반면 Django 개발용 서버는 기본적으로 단일 프로세스(또는 스레드)로 동작하여 **한 번에 하나의 요청만 처리**한다.  
 즉, 한 사용자의 요청을 처리하는 동안 다른 요청은 대기해야 하므로, 동시 접속자가 둘만 되어도 응답 지연이 발생하게 된다. 

실제로 Reddit의 Django 학습 포럼 답변에서도 "Gunicorn은 여러 워커로 병렬 요청 처리가 가능하지만, Django 개발 서버는 **동시에 하나의 요청**밖에 처리하지 못한다"며, 따라서 둘 이상의 사용자가 있을 경우 개발 서버로는 **심각한 성능 저하**가 발생한다고 지적하고 있다. 정적 파일 서비스도 마찬가지여서, Nginx는 다수의 정적 요청을 비동기로 빠르게 처리할 수 있지만 Django 개발 서버는 정적 파일 요청조차 직렬 처리하므로 병목이 되는 것이다.

성능 측면에서 **Gunicorn은 운영 환경에 맞게 다양한 최적화가 적용**되어 있다. Gunicorn은 [C10k문제](https://en.wikipedia.org/wiki/C10k_problem)를 고려한 효율적인 네트워크 처리와 멀티프로세싱으로 **속도 면에서 최적화**되어 있고, 상황에 맞춰 워커의 수나 타입 등을 **세밀하게 조정할 수 있는 설정 옵션**들을 제공한다.

- 예를 들어, 워커 프로세스 수를 조절하여 CPU 사용률을 극대화하거나 요청당 타임아웃을 지정할 수 있고, sync 모드 이외에 gevent와 같은 비동기 워커를 선택해 동시 처리 성능을 높일 수도 있다.   
반면 Django의 `runserver`는 이러한 설정이 제한적이며 코드 변경 시 자동 재시작 등 **개발 편의성에 초점**이 맞춰져 있어, **성능이나 안정성 면에서는 검증이 부족**하다. 또한 Gunicorn은 **보다 풍부한 로깅 기능**을 제공하여 운영 중 애플리케이션의 성능 모니터링과 문제 분석에 도움이 된다.   

요약하자면, **Gunicorn은 멀티코어를 활용한 병렬 처리와 최적화된 실행으로 고부하 트래픽을 소화**할 수 있지만, **개발용 서버는 단순 구현으로 동시 처리 성능이 매우 낮아** 운영 환경에는 적합하지 않다.

* **개발 서버 (`runserver`)**

  * 단일 프로세스 혹은 스레드
  * 동시 요청 1개 처리 → 다중 사용자 동시 접속 시 병목

* **Gunicorn**

  * 프리 포크(pre-fork) 워커 수 (예: `CPU코어*2+1`)
  * 멀티코어 활용한 병렬 처리
  * gevent, 쓰레드 등 워커 타입 조정 가능

## 3. 보안 및 안정성: HTTPS, 요청 필터링, 오류 격리, 프로세스 관리

Nginx와 Gunicorn 조합은 보안과 안정성 측면에서도 **개발 서버 대비 월등한 이점**을 제공한다.  
**Nginx는 외부에 직접 노출되는 프런트 웹 서버**로서, 들어온 요청을 한 단계 거쳐줌으로써 Django/Gunicorn 애플리케이션을 **외부로부터 한층 격리**시켜준다. 

- 예를 들어, Nginx가 없을 때는 Gunicorn 프로세스가 인터넷에 직접 노출되어 DDoS 공격이나 취약점 스캔 등에 바로 노출될 수 있지만, Nginx를 앞단에 두면 **모든 요청을 선별적으로 수용**하고 **필요한 경우 차단**할 수 있다. 
- Nginx는 IP 접근 제한, 요청 URL 패턴 필터링, HTTP 메서드 제한 등의 **방화벽 역할**도 일부 수행할 수 있어 악의적인 트래픽을 애플리케이션 레벨까지 도달하기 전에 차단할 수 있다. 또한 HTTPS 적용 시, **SSL/TLS 종단점**을 Nginx에서 담당하게 함으로써 Gunicorn은 **평문 HTTP 통신**만 처리하도록 구성하는 것이 일반적.
  - Nginx는 고성능 C로 구현되어 대량의 SSL 암복호화 처리를 효율적으로 수행할 수 있고, Let’s Encrypt 등의 인증서 자동 갱신 도구와도 연동이 쉽기 때문이다. Gunicorn 자체로도 HTTPS를 처리하는 옵션이 있긴 하지만, 일반적으로 권장되지 않으며 Nginx가 이 역할을 대신함으로써 **인증서 및 암호화 통신 관리**를 중앙에서 안정적으로 처리하게 된다.

**요청 필터링과 오류 처리** 측면에서도 Nginx는 추가적인 안정성을 제공한다. 예를 들어, 클라이언트가 아주 느린 속도로 요청을 보내거나 응답을 받을 때, Gunicorn의 기본 동기 워커들은 그 동안 해당 워커를 점유한 채 대기해야 하므로 효율이 떨어지고 이로 인해 **서비스 거부(DoS) 공격**에 취약해질 수 있다. 

**Nginx는 기본적으로 클라이언트로부터 요청 본문을 모두 받아 버퍼링한 후 백엔드(Gunicorn)에 전달**하고, Gunicorn이 보내는 응답도 클라이언트에게 보내기 전에 자체적으로 버퍼링하여 **느린 클라이언트와 백엔드 사이에서 완충지대 역할**을 한다. Gunicorn 공식 문서에서도 "**반드시 Nginx와 같은 프록시 서버 뒤에서 Gunicorn을 구동하라**"고 강력히 권고하면서, 그 **주된 이유**로 

*"Nginx가 느린 클라이언트를 대신 버퍼링해주지 않을 경우 Gunicorn 워커들이 쉽게 고갈되어 서비스 거부 공격에 노출된다"*

는 점을 들고 있다. 즉, Nginx가 있어야 **Slowloris와 같은 느린 요청 공격에 대비**할 수 있다는 것이다. 

또한 Nginx는 업스트림(Gunicorn)으로부터 오류 응답이 돌아오면 자체적으로 지정된 **커스텀 오류 페이지**를 보여주거나, 일정 횟수 재시도를 시도하는 등의 동작을 설정할 수도 있습니다. 
- 예를 들어 Gunicorn 워커들이 모두 죽어있다면 Nginx는 즉시 502 Bad Gateway로 응답하지만, 웹 서버(Nginx) 자체는 살아있기 때문에 필요하면 정적 서비스는 지속하거나, 관리자가 내려둔 공지 페이지를 보여주는 식으로 **부분적인 서비스 유지**가 가능하다.  
- 이러한 구조는 **애플리케이션 서버(Gunicorn/Django)의 오류가 웹 서버(Nginx)와 격리**되어 전반적인 서비스 가용성을 높여준다.

**Gunicorn의 프로세스 관리 능력**도 안정성에 기여한다. Gunicorn은 **마스터-워커 다중 프로세스 구조**로 동작하기 때문에, 개별 워커 프로세스에서 문제가 발생해도 마스터 프로세스가 남아있어 새로운 워커를 띄우고 서비스를 지속할 수 있다. 

- 예를 들어 어떤 요청 처리 중 코드 버그로 워커가 죽더라도, Gunicorn 마스터는 해당 워커를 종료 로그에 남기고 즉시 새로운 워커 프로세스를 생성하여 **프로세스 풀을 복구**한다. 이 덕분에 **단일 프로세스인 Django 개발 서버와 달리** 부분적인 오류가 전체 서비스 중단으로 이어지지 않는다. 

- 또한 **worker timeout** 설정을 통해 응답이 없는 워커를 강제로 재시작하고, `--max-requests` 설정을 통해 일정 요청을 처리한 워커를 재시작함으로써 메모리 누수 같은 문제가 누적되지 않도록 **방어 기제**를 제공하기도 한다. 

Gunicorn은 이러한 **프로세스 제어 및 재시작(daemonizing, graceful restart)** 기능이 잘 갖춰져 있어서 코드 배포 시에도 `HUP` 시그널 등을 보내 **무중단으로 워커들을 재기동(graceful reload)** 할 수 있다. 아울러 Gunicorn과 Nginx 모두 **상세한 로그 기능**을 지원하여 (Gunicorn의 애플리케이션 로그와 Nginx의 접근/오류 로그) 운영 중 발생하는 에러를 추적하고 분석하기 쉽다.

 결과적으로 Nginx + Gunicorn 환경은 **보안 측면에서 HTTPS 지원과 외부 공격 차단을 강화**하고, **안정성 측면에서 프로세스 격리와 자동 복구로 견고한 서비스 운영**이 가능하다.

* **Nginx**

  * SSL/TLS 인증서 관리 → 안전한 HTTPS
  * IP/URL 필터링 → 악성 트래픽 차단
  * 느린 요청 버퍼링 → Slowloris 등 방어
  * 커스텀 에러 페이지, 헬스체크
  
* **Gunicorn**

  * 마스터-워커 구조 → 워커 장애 시 자동 재시작
  * `--max-requests`, `timeout` 등으로 메모리 누수·응답 지연 방지
  * 무중단 재시작(graceful reload

## 4. 트래픽 처리 및 확장성

Django 서비스를 운영하다 보면 **트래픽 규모**가 커질 수 있는데, Nginx와 Gunicorn 조합은 이러한 상황에서 유연한 **확장성**을 제공한다.  
**Nginx는 가볍고 빠른 이벤트 기반 아키텍처**로 개발되어 **수천 개의 동시 연결 요청도 단일 서버에서 처리할 수 있도록(scale-out)** 최적화되어 있다. Nginx는 비동기식으로 동작하며 다수의 클라이언트 접속을 소켓 상태로 유지하면서도 적은 쓰레드/프로세스로 높은 처리량을 낼 수 있는 것 이다. 

- 예를 들어 Keep-Alive 연결을 맺은 많은 클라이언트가 있어도 Nginx는 효율적으로 I/O 이벤트를 처리하여 각 요청을 빠르게 Gunicorn에 넘기거나 정적 파일을 전달할 수 있다. 또한 정적 파일 요청의 경우 Nginx가 직접 처리하므로 Gunicorn에 불필요한 부하를 주지 않고, 동적 요청에 Gunicorn의 자원을 집중시킬 수 있다.

 **Gunicorn** 역시 앞서 언급한 것처럼 다중 워커를 통해 **여러 요청을 병렬 처리**할 수 있으므로, Nginx와 함께 사용하면 **웹 서버 레벨(Nginx)과 애플리케이션 레벨(Gunicorn)** 모두에서 **동시 처리 성능을 극대화**할 수 있다. 

 >실제로 Gunicorn은 **높은 동시성(high concurrency)** 을 요구하는 애플리케이션에 잘 맞도록 설계되어 **대량의 요청을 동시에 처리**할 수 있으며, 마스터 프로세스가 내부적으로 **Round Robin**으로 워커들에게 요청을 분배하는 등 간단한 **로드밸런싱**도 수행한다. 예를 들어 5개의 Gunicorn 워커가 있다면 들어온 요청들을 5개 프로세스에 고르게 분배하여 과부하를 방지하는 것이다.

**수평·수직 확장** 측면에서 이 구성은 매우 융통성이 높다. **수직 확장(Scale-up)** 은 서버의 하드웨어 자원을 늘리거나 설정 변경을 통해 이루어진다. Gunicorn의 워커 프로세스 수를 서버 CPU 코어 수에 맞게 증가시키거나(`workers` 파라미터) 필요에 따라 쓰레드 모드(worker class `gthread`)로 전환하여 한 워커가 다중 쓰레드를 처리하게 하는 식으로 **한 대의 머신에서 처리량을 극대화**할 수도 있다.  
> 일반적으로 권장되는 워커 수는 `CPU코어 * 2 + 1` 개 등의 공식으로 산정하며, 이는 Gunicorn 설정 파일이나 systemd 서비스 파일에 미리 지정해 둘 수 있다. Nginx도 기본적으로 CPU 코어 수만큼 워커 프로세스를 띄우도록 (`worker_processes auto;`) 설정하여 서버 성능을 최대한 활용한다.  

**수평 확장(Scale-out)** 은 애플리케이션 인스턴스를 여러 대로 늘리는 것으로, Nginx가 **로드 밸런서** 역할을 할 수 있기 때문에 비교적 간단하다. 예를 들어 하나의 물리 서버에서 감당하기 어려운 트래픽이 온다면, 동일한 Django+Gunicorn 환경을 다른 서버에 추가로 배포하고 Nginx 설정의 업스트림에 그 서버들을 나열함으로써 요청을 분산 처리할 수 있다.

Nginx는 **라운드 로빈**이나 **IP 해시** 등 다양한 부하 분산 알고리즘을 지원하여 여러 Gunicorn 백엔드 인스턴스에 트래픽을 고르게 나눠줄 수 있고, 한 인스턴스에 장애가 생기면 자동으로 해당 노드를 제외(remove)하는 health-check 설정도 가능하다. 이러한 구조를 통해 트래픽이 증가해도 물리 서버나 Gunicorn 프로세스를 추가하여 쉽게 확장할 수 있고, 반대로 트래픽이 줄면 인스턴스를 줄이는 식으로 **탄력적인 운영**이 가능하다. (클라우드 환경에서는 로드밸런서(AWS ELB 등) + 여러 서버에 Nginx/Gunicorn 조합을 두는 방식으로 확장하기도 하지만, 원리는 동일) 

요약하면, **Nginx+Gunicorn 조합은 적은 자원으로도 높은 동시 접속을 처리**할 수 있으며, **필요시 설정 튜닝이나 서버 증설을 통해 규모에 맞게 확장**할 수 있는 구조이다.

* **수직 확장 (Scale-Up)**

  * 워커 수 조정, 쓰레드 모드 전환
  * Nginx `worker_processes auto;`
  
* **수평 확장 (Scale-Out)**

  * Nginx 업스트림에 여러 Gunicorn 인스턴스 등록
  * 라운드로빈/IP 해시 로드밸런싱
  * 장애 서버 자동 제외(헬스체크)

## 5. Nginx + Gunicorn 조합의 장단점 요약

**장점:**

* **높은 성능과 효율성:** Nginx의 이벤트 기반 구조 덕분에 
  - **가벼운 메모리 사용으로도 다수의 동시 접속을 처리**할 수 있고, 
  - Gunicorn이 **여러 워커 프로세스로 멀티코어 활용**을 함으로써 Django 앱의 **처리량을 극대화**할 수 있다. 
  - 정적 파일은 Nginx가 담당하고 동적 로직은 Gunicorn이 처리하여 **각자 역할에 특화된 최적화**를 이끌어낸다.

* **보안 강화:** Nginx가 앞단에서 **리버스 프록시 및 방화벽 역할**을 수행함으로써 Django/Gunicorn 앱 서버를 외부 위협으로부터 한 겹 보호해준다. 또한 **SSL 종료(HTTPS)** 를 Nginx에서 처리하여 인증서 관리와 암호화 통신을 안전하고 손쉽게 구현할 수 있으며, Gunicorn 프로세스가 직접 외부 노출되지 않아 **애플리케이션 레벨의 취약점 공격 면적을 감소**시킨다.
* **안정성 및 신뢰성:** Gunicorn의 **마스터-워커 프로세스 모델**은 한 워커의 장애가 전체 다운으로 이어지지 않도록 하고, 필요시 워커를 교체하며 지속적으로 서비스가 유지되게 한다. 이는 **프로세스 격리로 오류를 국한**하고 **자동 재시작** 등의 매커니즘으로 **self-healing**하는 효과가 있다. 또한 Nginx는 백엔드 오류 시 빠르게 감지하여 에러 페이지를 제공하고, 느린 요청을 버퍼링하여 백엔드를 지켜주는 등 **서비스의 지속성**을 높여준다.
* **확장성과 유연성:** 이 조합은 작은 서비스부터 대규모 서비스까지 두루 사용될 만큼 **확장성이 입증**되었다. **수평 확장**(여러 서버 혹은 프로세스 간 부하분산)과 **수직 확장**(하드웨어 업그레이드 및 워커 증설)이 모두 용이하며, 컨테이너화나 오토스케일링 환경에도 쉽게 적용할 수 있다. 필요하다면 Memcached, Redis 캐시나 CDN과도 Nginx 레벨에서 연계가 가능해 성능 튜닝에 유연하다.
* **성숙한 생태계와 기능:** Nginx와 Gunicorn 모두 **대규모 커뮤니티와 풍부한 문서**를 가진 성숙한 소프트웨어로서, 다양한 튜토리얼과 사례가 축적되어 있다. Logging, 모니터링, 접속 통계 등 운영에 필요한 기능도 잘 지원되며 (예: Nginx 접근 로그, Gunicorn 에러 로그 등), 장애 발생 시 인터넷에 해결책을 찾기도 수월하다. 또한 필요에 따라 기타 WSGI 서버(uWSGI 등)나 웹 서버(Apache 등)로 교체도 비교적 쉬워 표준적인 아키텍처로 인정받고 있다.

**단점:**

* **설정 복잡도 증가:** Django의 `runserver`로 실행하는 개발 환경에 비해 Nginx와 Gunicorn을 설정하는 것은 초기 러닝 커브가 있다. 별도의 설정 파일 작성, 권한 관리, 소켓/포트 관리, 프로세스 데몬화(systemd) 등 **구성이 복잡**하며, 구성 요소가 늘어난 만큼 배포 자동화나 설정 관리에 신경 써야 한다. 초보자에게는 설정 오류로 인한 **502 Bad Gateway** 등의 문제를 처음에 겪을 수 있고, 모두 올바르게 설정할 때까지 시간이 필요하다. 그러나 이러한 초기 설정만 완비되면 이후에는 비교적 안정적으로 운영할 수 있다.
* **리소스 사용 부담:** Nginx와 Gunicorn 조합은 경량화되어 있긴 하지만, 개발 서버 하나만 돌리는 것보다 **추가적인 프로세스들과 메모리 사용**이 발생한다. 예를 들어 워커 프로세스 여러 개를 띄우면 그만큼 메모리가 필요하고, Nginx도 마스터/워커 프로세스를 별도로 사용한다. 저사양 시스템에서 테스트할 때는 runserver 하나만으로 돌리는 것보다 약간 부담이 있을 수 있다. 하지만 현대적인 서버 환경에서는 이 정도 오버헤드는 감내할 수준이며, **성능 향상으로 얻는 이득이 훨씬 크므로** 큰 단점으로 고려되지는 않는다.
* **개발과 운영 환경 차이:** 개발 단계에서는 편의상 `runserver`를 쓰고 운영환경에서는 Gunicorn+Nginx를 쓰게 되므로, 환경 차이에 따른 이슈가 있을 수 있다. (예를 들어 정적 파일이 개발 서버에서는 DEBUG 모드로 서빙되지만, 운영 환경에서는 Nginx 설정을 따로 맞춰야 하는 등.) 따라서 배포 전에 운영 환경과 최대한 비슷하게 테스트해보는 것이 좋다. 이 또한 CI/CD 파이프라인이나 Docker 컨테이너 이용으로 극복 가능한 부분이지만, 개발자에게 **운영환경에 대한 추가 지식**이 요구된다.
* **기술 한계:** Gunicorn은 WSGI 서버이므로 **웹소켓** 같은 **비동기 프로토콜**을 직접 지원하지 않는다. Django Channels와 같은 실시간 기능을 도입하려면 Gunicorn 대신 ASGI 서버(Uvicorn, Daphne 등)를 사용하거나 별도 설정이 필요하다. 또한 장기 연결이나 서버 푸시 등의 시나리오에서는 Nginx의 기본 버퍼링을 끄고 Gunicorn을 async 모드로 돌려야 하는 등 추가 튜닝이 필요할 수 있다. 그러나 이러한 경우에도 Nginx를 프록시로 두는 설계 자체는 유지되며, Gunicorn을 다른 전문 서버로 교체하는 정도이므로 **아키텍처의 기본 틀은 동일**하다. 결국 Nginx+Gunicorn 조합은 일반적인 요청/응답 기반 웹 서비스에 최적화되어 있고, 특별한 실시간 요구사항이 없는 한 거의 모든 Django 웹사이트에 무난한 선택이 된다.


| 구분  | 장점                                                   | 단점                      |
| --- | ---------------------------------------------------- | ----------------------- |
| 성능  | • 다중 워커·멀티코어 활용으로 고부하 처리<br>• Nginx 정적 파일 최적 서빙      | • 개발 서버 대비 설정 복잡        |
| 보안  | • HTTPS/방화벽/버퍼링 → 외부 공격 차단<br>• 애플리케이션 격리로 취약점 범위 축소 | • 리소스(메모리·프로세스) 추가      |
| 안정성 | • 워커 자동 복구·그레이스풀 리로드<br>• 커스텀 에러 처리 및 서비스 지속성 보장     | • 개발↔운영 환경 차이 주의 필요     |
| 확장성 | • Nginx+Gunicorn 양단에서 동시성 극대화<br>• 수평·수직 확장 용이       | • 실시간(웹소켓)용은 별도 ASGI 필요 |

