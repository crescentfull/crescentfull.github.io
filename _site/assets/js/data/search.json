[
  
  {
    "title": "Jekyll로 블로그 시작하기: 테스트 포스팅",
    "url": "/posts/jekyll/",
    "categories": "Blogging, Jekyll",
    "tags": "jekyll, blogging, tutorial",
    "date": "2023-10-15 10:00:00 +0900",
    





    
    "snippet": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게...",
    "content": "Jekyll이란?Jekyll은 정적 사이트 생성기로, 블로그나 웹사이트를 쉽게 만들 수 있도록 도와줍니다. 특히 GitHub Pages와 잘 연동되어 많은 개발자들이 사용하고 있습니다.Jekyll의 장점  간편한 설정: Jekyll은 간단한 설정 파일을 통해 사이트의 구조를 정의할 수 있습니다.  Markdown 지원: Markdown을 사용하여 쉽게 글을 작성할 수 있습니다.  빠른 속도: 정적 사이트이기 때문에 로딩 속도가 빠릅니다.테스트 포스팅 작성하기이 포스팅은 Jekyll을 사용하여 작성한 테스트 포스팅입니다. Jekyll의 기본적인 사용법을 익히고, 블로그를 시작하는 데 도움이 되기를 바랍니다.1. 파일 생성먼저 _posts 디렉토리에 새로운 파일을 생성합니다. 파일명은 YYYY-MM-DD-title.md 형식으로 작성합니다.2. Front Matter 설정파일의 맨 위에 YAML 형식의 Front Matter를 추가하여 포스트의 메타데이터를 설정합니다.---title: \"Jekyll로 블로그 시작하기: 테스트 포스팅\"date: 2023-10-15 10:00:00 +0900categories: [Blogging, Jekyll]tags: [jekyll, blogging, tutorial]---3. 포스트 내용 작성Markdown을 사용하여 포스트의 내용을 작성합니다. 예를 들어, Jekyll의 장점이나 사용법에 대해 설명할 수 있습니다.결론Jekyll을 사용하면 블로그를 쉽게 시작할 수 있습니다. 이 포스팅이 Jekyll을 이해하는 데 도움이 되었기를 바랍니다. 앞으로 더 많은 포스팅을 통해 Jekyll의 다양한 기능을 탐구해보세요!"
  },
  
  {
    "title": "Set with Python",
    "url": "/posts/SET_with_python/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Set, Python",
    "date": "2022-02-03 11:00:00 +0900",
    





    
    "snippet": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dic...",
    "content": "what is the SET ?!set특징  집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다.  중복을 허용하지 않는다.      순서가 없어 인덱스로 값을 얻을 수 없다.  1. 생성a = {1, 2, 3, 4, 5}print(type(a)) #&lt;class 'set'&gt;b = {}print(type(b)) #&lt;class 'dict'&gt;c = set()print(type(c)) #&lt;class 'set'&gt;2. 추가&amp;삭제#추가a = {1, 2, 3}a.add(4)print(a)&gt;&gt;&gt; {1, 2, 3, 4}#여러 값 추가a = {1, 2, 3}a.update({4, 5, 6})print(a)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6}#삭제a = {1, 2, 3}a.remove(2)print(a)&gt;&gt;&gt; {1, 3}3. 교집합&amp;합집합&amp;차집합  메서드나 연산자를 사용하여 구할 수 있다.set1 = {1, 2, 3, 4, 5, 6}set2 = {4, 5, 6, 7, 8, 9}#교집합print(set1 &amp; set2)&gt;&gt;&gt; {4, 5, 6}print(set1.intersection(set2))&gt;&gt;&gt; {4, 5, 6}#합집합print(set1 | set2)&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}print(set1.union(set2))&gt;&gt;&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}#차집합print(set1 - set2)&gt;&gt;&gt; {1, 2, 3}print(set1.difference(set2))&gt;&gt;&gt; {1, 2, 3}4. list VS set (in 연산 시간복잡도 비교)  List 자료형에서는 in 연산자의 시간 복잡도는 O(n)이고,  set 자료형에서는 in 연산자의 시간 복잡도는 O(1)이다.import timeits = set(range(0, 1000000))l = list(range(0, 1000000))# setstart = timeit.default_timer()print(999999 in s)print(timeit.default_timer() - start) # liststart = timeit.default_timer()print(999999 in l)print(timeit.default_timer() - start)  print('-----------------------------------')#setstart = timeit.default_timer()for i in range(1000):    i+1000 in sprint(timeit.default_timer() - start) #list start = timeit.default_timer()for i in range(1000):    i+1000 in lprint(timeit.default_timer() - start) &gt;&gt;&gt;True0.00001733399403747171True0.010281834998750128-----------------------------------0.000097908006864599880.015224540999042802"
  },
  
  {
    "title": "Hash 테이블",
    "url": "/posts/%ED%95%B4%EC%89%AC%ED%85%8C%EC%9D%B4%EB%B8%94/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Hash Table",
    "date": "2022-02-03 10:00:00 +0900",
    





    
    "snippet": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열...",
    "content": "What is the Hash Table?Hash Table은 key-value system을 이용하여, 자료를 정리한다.key: valuedictionary를 생각하면 된다.프로그래밍에서 같은 함수가 각기 다른 프로그래밍 언어에서 존재한다.  JS에서는 ObjectPython에서는 DictionaryGo에서는 map 기타등등그렇다면 해쉬테이블과 배열(Array)의 비교해보자.예를 들어 레스토랑의 메뉴를 배열에 저장한다면?menu = [\t{ name: \"coffee\",price: 10},\t{ name: \"burger\",price: 15},    \t{ name: \"tea\",price: 15}    ]이 중에서 tea의 값을 알고 싶다면 linear Search(선형검색)을 통해서 순차적으로 찾을 것이다. =&gt; 시간이 많이 걸린다!순차적으로 하나하나 쓰고 싶지 않을때 어떻게 써야할까?같은 메뉴를 해쉬테이블로 만들어보자menu = \t{ \tcoffee : 10,\tburger : 15,    \ttea : 15    ]이 경우 tea를 알고 싶으면 tea = key가 될것이고 hash tables는 가격을 Value로 제공한다.시간 복잡도를 비교해 본다면?처음 했던 방법은 O(N)이라 할 수 있다. Linear Time(선형 시간)아이템이 많을수록 찾는 시간도 오래 걸린다.그렇다면 해쉬테이블은? O(1) 즉, Constant Time(상수 시간)이다.해쉬테이블에서 어떤 값을 찾더라도 소요되는 건 오직 하나의 단계이기 때문에 배열에 비해서 굉장히 빠르다. 삭제 했을때도 마찬가지이다.value만 쓰고 싶다면?conturies = [\t\t\"🇬🇷\",\t\t\"🇬🇱\",\t\t\"🇬🇳\",\t\t\"🇳🇦\",\t\t\"🇳🇷\",\t\t\"🇦🇶\"\t]key 값이 없는데 어떻게 찾냐?conturies = {\t\t\"🇬🇷\": true,\t\t\"🇬🇱\": true,\t\t\"🇬🇳\": true,\t\t\"🇳🇦\": true,\t\t\"🇳🇷\": true,\t\t\"🇦🇶\": true\t}   #key가 국기가 되고, value는 그저 true 이다..!이렇게 되면 한 스텝만에 원하는 값을 찾을수(검색) 있다.해쉬테이블은 어떻게 작동하고 왜 “Hash”테이블이라고 할까?Hash Tables에는 array 구조가 있다.인덱스 값을 던져 주었을 때 key의 value값을 찾게 해주는 방법은 무엇이 있을까? 바로 Hash function(해시 함수)가 그것을 가능하게 해준다.key_2의 값이 해시 함수를 지나면서 index가 0인 값을 자동으로 찾아주게 된다. 조금 더 쉽게 가보자pizza의 알파벳 숫자를 5라고 했을 때 해시함수는 인덱스 5를 찾는다고 가정한다면 인덱스가 5번인 곳에 10을 넣어준다.cake는 알파벳이 4이기 때문에 4에 value값을 넣어준다. 그런데 taco도 4이기 때문에 오류가 일어나는데 이것을 Hash Collision(해시 충돌)라고 한다.이를 해결하기 위한 하나의 방법은 인덱스 4의 값에 cake와 taco 두개의 값을  가지고 있는 list를 만드는 것이다.따라서 우리는 Hash Tables에 cake가격을 물으면, Cake = key라는 해시함수에 넣고 이는 ‘4’라는 숫자를 줄 것이고, 리스트의 4로 이동하여 선형검색을 할 것이다.  바로 이러한 이유 때문에 Hash Table은 언제나 상수 시간(0(1))은 아니다.!왜냐하면 충돌이 있을 수 있고, 그 경우 선형검색을 해야하기 때문이다.참고 자료 : 노마드코더 유튜브"
  },
  
  {
    "title": "연결리스트, 근데 포인터를 곁들인",
    "url": "/posts/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%A5%BC_%EA%B3%81%EB%93%A4%EC%9D%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Data Structure, Linked List, Pointer",
    "date": "2022-02-02 10:00:00 +0900",
    





    
    "snippet": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 ...",
    "content": "포인터를 이용한 연결 리스트노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트를 알아보자  연결리스트는 대부분의 알고리즘에서 사용하는 기본 자료구조이다. 알고리즘에서 사용하는 데이터와 다음 노드를 가리키는 링크를 묶어서 노드로 정의하여 사용한다. c/c++에서는 포인터(pointer) 개념으로 링크를 사용하지만 파이썬은 포인터라는 개념이 없다.class Node:    def __init__(self, data):        self.data = data        self.next = None        # 파이썬에서 노드는 위와같이 구현하였다. # 위 구조에서 현재 노드에서 다음 노드를 어떻게 참조 시킬 수 있을까?head = Node(5)next_node = Node(12)head.next = next_node# 위와같이 구현하여 참조시킬 수 있다. # 이제 위와같이 노드를 생성하고 관리하는 클래스를 구현하여 사용할 것이다.출처 : 링크포인터로 연결 리스트 만들기연결 리스트에 데이터를 삽일할 때 노드용 인스턴스를 생성하고, 데이터를 삭제할 때 노드용 인스턴스를 없애면 앞에서 제시한 데이터를 옮기는 문제를 해결할 수 있다.      Node : 데이터와 다음 데이터를 가리키는 주소(포인터)로 이루어져 있다.        Pointer : 각 노드에서 다음 데이터를 가리키는 주소값을 가진다.        Head : 링크드리스트에서 가장 시작점인 데이터를 의미한다.        Tail : 링크드리스트에서 가장 마지막 데이터를 의미        Next=None(또는 Null) : 다음 데이터가 없을 경우 포인터의 주소값은 None(또는 Null)이다.  출처: https://ybworld.tistory.com/85 [투손플레이스]링크드 리스트 만들기  노드 생성    class Node: \"\"\"연결 리스트용 노드 클래스\"\"\" def __init__(self, data: Any = None, next: Node = None):     \"\"\"초기화\"\"\"     self.data = data  # 데이터     self.next = next  # 뒤쪽 포인터            Node 연결리스트 클래스 생성```pythonclass LinkedList: “\"”연결 리스트 클래스”””    def init(self) -&gt; None:     “\"”초기화”””     self.no = 0          # 노드의 개수     self.head = None     # 머리 노드     self.current = None  # 주목 노드    def len(self) -&gt; int:     “\"”연결 리스트의 노드 개수를 반환”””     return self.no  3. search() / 검색에 성공하면 발견할 수 있는 노드```pythondef search(self, data: Any) -&gt; int:        \"\"\"data와 값이 같은 노드를 검색\"\"\"        cnt = 0        ptr = self.head        while ptr is not None:            if ptr.data == data:                self.current = ptr                return cnt            cnt += 1            ptr = ptr.next        return -1    def __contains__(self, data: Any) -&gt; bool:        \"\"\"연결 리스트에 data가 포함되어 있는가?\"\"\"        return self.search(data) &gt;= 0  add_first() / 삽입한 머리 노드     def add_first(self, data: Any) -&gt; None:     \"\"\"맨 앞에 노드를 삽입\"\"\"     ptr = self.head  # 삽입 전의 머리 노드     self.head = self.current = Node(data, ptr)     self.no += 1        add_last() / 삽입한 꼬리 노드     def add_last(self, data: Any):     \"\"\"맨 끝에 노드를 삽입\"\"\"     if self.head is None :    # 리스트가 비어 있으면         self.add_first(data)  # 맨앞에 노드 삽입     else:         ptr = self.head         while ptr.next is not None:             ptr = ptr.next  # while문을 종료할 때 ptr은 꼬리 노드를 참조         ptr.next = self.current = Node(data, None)         self.no += 1        remove_first() / 삭제한 뒤 머리노드(리스트가 비어 있으면 None)     def remove_first(self) -&gt; None:     \"\"\"머리 노드를 삭제\"\"\"     if self.head is not None:  # 리스트가 비어 있으면         self.head = self.current = self.head.next     self.no -= 1        remove_last() / 삭제한 뒤 꼬리녿(리스트가 비어 있으면 None)     def remove_last(self):     \"\"\"꼬리 노드 삭제\"\"\"     if self.head is not None:         if self.head.next is None :  # 노드가 1개 뿐이라면             self.remove_first()      # 머리 노드를 삭제         else:             ptr = self.head  # 스캔 중인 노드             pre = self.head  # 스캔 중인 노드의 앞쪽 노드             while ptr.next is not None:                 pre = ptr                 ptr = ptr.next # while문 종료시 ptr은 꼬리 노드를 참조하고 pre는 맨끝에서 두 번째 노드를 참조             pre.next = None  # pre는 삭제 뒤 꼬리 노드             self.current = pre             self.no -= 1        remove() / 삭제한 노드의 앞쪽 노드    def remove(self, p: Node) -&gt; None:     \"\"\"노드 p를 삭제\"\"\"     if self.head is not None:         if p is self.head:       # p가 머리 ​​노드이면             self.remove_first()  # 머리 노드를 삭제         else:             ptr = self.head             while ptr.next is not p:                 ptr = ptr.next                 if ptr is None:                     return  # ptr은 리스트에 존재하지 않음             ptr.next = p.next             self.current = ptr             self.no -= 1        remove_current_node() / 삭제한 노드의 앞쪽 노드     def remove_current_node(self) -&gt; None:     \"\"\"주목 노드를 삭제\"\"\"     self.remove(self.current)        clear()    def clear(self) -&gt; None:    \"\"\"전체 노드를 삭제\"\"\"    while self.head is not None:  # 전체가 비어 있게 될 때까지        self.remove_first()       # 머리 노드를 삭제    self.current = None    self.no = 0        next()    def next(self) -&gt; bool:    \"\"\"주목 노드를 한 칸 뒤로 진행\"\"\"    if self.current is None or self.current.next is None:        return False  # 진행할 수 없음    self.current = self.current.next    return True        print_current_node() &amp; print()    def print_current_node(self) -&gt; None:    \"\"\"주목 노드를 출력\"\"\"    if self.current is None:        print('주목 노드가 존재하지 않습니다.')    else:        print(self.current.data)def print(self) -&gt; None:    \"\"\"모든 노드를 출력\"\"\"    ptr = self.head    while ptr is not None:        print(ptr.data)        ptr = ptr.next      다른 예시코드class Node:    def __init__(self, data):        self.data = data        self.next = None    def __str__(self):        return str(self.data)class SingleLinkedList:    def __init__(self, data):        new_node = Node(data)        self.head = new_node        self.list_size = 1    def __str__(self):        print_list = '[ '        node = self.head        while True:            print_list += str(node)            if node.next == None:                break            node = node.next            print_list += ', '        print_list += ' ]'        return print_list    def insertFirst(self, data):        new_node = Node(data)        temp_node = self.head        self.head = new_node        self.head.next = temp_node        self.list_size += 1    def insertMiddle(self, num, data):        if self.head.next == None:            insertLast(data)            return        node = self.selectNode(num)        new_node = Node(data)        temp_next = node.next        node.next = new_node        new_node.next = temp_next        self.list_size += 1    def insertLast(self, data):        node = self.head        while True:            if node.next == None:                break            node = node.next        new_node = Node(data)        node.next = new_node        self.list_size += 1    def selectNode(self, num):        if self.list_size &lt; num:            print(\"Overflow\")            return        node = self.head        count = 0        while count &lt; num:            node = node.next            count += 1        return node    def deleteNode(self, num):        if self.list_size &lt; 1:            return # Underflow        elif self.list_size &lt; num:            return # Overflow        if num == 0:            self.deleteHead()            return        node = self.selectNode(num - 1)        node.next = node.next.next        del_node = node.next        del del_node    def deleteHead(self):        node = self.head        self.head = node.next        del node    def size(self):        return str(self.list_size)if __name__ == \"__main__\":    m_list = SingleLinkedList(1)    m_list.insertLast(5)    m_list.insertLast(6)    print('LinkedList :', m_list)    print('LinkedList Size() :', m_list.size())    print('LinkedList SelectNode(1) :', m_list.selectNode(1))    m_list.insertMiddle(1, 15)    print('LinkedList Insert Middle(1, 15) :', m_list)    m_list.insertFirst(100)    print('LinkedList Insert First(100) : ', m_list)    print('LinkedList SelectNode(0) :', m_list.selectNode(0))    m_list.deleteNode(0)    print('LinkedList Delete Node(0) : ', m_list)    m_list.deleteNode(1)    print('LinkedList Delete Node(1) : ', m_list)    #LinkedList : [ 1, 5, 6 ]#LinkedList Size() : 3#LinkedList SelectNode(1) : 5#LinkedList Insert Middle(1, 15) : [ 1, 5, 15, 6 ]#LinkedList Insert First(100) :  [ 100, 1, 5, 15, 6 ]#LinkedList SelectNode(0) : 100#LinkedList Delete Node(0) :  [ 1, 5, 15, 6 ]#LinkedList Delete Node(1) :  [ 1, 15, 6 ]    예시코드 출처 : 링크"
  },
  
  {
    "title": "배열과 리스트",
    "url": "/posts/%EB%B0%B0%EC%97%B4%EA%B3%BC_%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
    "categories": "CS, Data Structure",
    "tags": "Computer Science, Array, List, Data Structure",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2 ...",
    "content": "배열배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조배열의 값은 인덱스를 통해 참조할 수 있다.선언한 자료형의 값만 저장 가능하다.배열의 구조                    인덱스        0        1        2        3                            값        값 1        값 2        값 3        값 4            배열의 특징  인덱스를 사용하여 값에 바로 접근 가능  새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.          값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요        배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 변경할 수 없다.리스트리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 구조리스트의 특징  인덱스가 없으므로 값에 접근하려면 Head 포인터로부터 순서대로 접근          즉, 값에 접근하는 속도가 느림        포인터로 연결되어 있으므로 데이터를 삽인하거나 삭제하는 연산 속도가 빠름  선언할 때 크기를 별도로 지정하지 않아도 된다.          리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.        포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡  ✅ 파이썬에서는 배열과 리스트를 구분하지 않는다.파이썬의 list는 리스트의 특징과 배열의 특징까지 모두 가지도록 구현되어 있다.Reference책 - Do it! 알고리즘 코딩 테스트 파이썬 편"
  },
  
  {
    "title": "객체 지향 프로그램 OOP",
    "url": "/posts/OOP/",
    "categories": "CS",
    "tags": "Computer Science, OOP",
    "date": "2022-02-01 10:00:00 +0900",
    





    
    "snippet": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 ...",
    "content": "객체 지향 프로그램(Objects Oriented Programming)1. 개념  객체 지향 프로그램(Objects Oriented Programming)  비교개념은 절차 지향 프로그래밍  프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식  Key Point          독립적인 객체들의 집합을 통하여 객체들이 서로 상호작용을 하는 구조로 전체 프로그램이 구현될 수 있도록 하는 것      로직에 구조를 더하기 위해 OOP를 사용      2. 사용이유  절차 지향 방식 -&gt; 데이터를 중심으로 함수 구현, 순차적인 처리 중요, C언어  객체 지향 방식 -&gt; 기능을 중심으로 함수 구현  OOP 사용의 핵심 이유 : 코드의 구조화          유지보수 용이 : 기능별로 구현되어 있기 때문에 일부가 고장나도 그 해당 부분만 고치면 됨      재활용 용이 : 정의한 class를 상속하고 확장하여 재사용할 수 있음      가독성 좋아짐      3. Class &amp; Object &amp; Instance1. 클래스(class)1) 개념  객체를 생성하기 위한 설계도  클래스를 잘 이해하는 것이 OOP의 기본  ex) Car라는 부류가 클래스(큰 개념, 범주) Car의 instance(실체)가 렉서스, bmw, 벤츠, 현대라는 객체인 것2) 구성  Class = Property + Method  Property(속성) : 해당 entity를 표현하는 data = 변수 = 명사  Method(기능) : 해당 entity가 가지고 있는 기능들 = 함수 = 동사2. 객체(Object)  클래스를 통해 정의된 설계도로 만들어진 프로그램  객체는 고유한 성격을 지니기 때문에 동일한 클래스로 만들어진 객체라도 다른 객체의 영향을 받지 않는다  객체는 클래스의 constructor 메소드로 생성된다.3. 인스턴스(Instance)  클래스로 만든 객체를 인스턴스라고도 함  객체가 개념이라면 인스턴스는 실체  인스턴스라는 말은 특정 객체가 어떤 클래스의 객체인지 관계를 위주로 설명할 때 사용  ex) 현대는 그 자체로는 인스턴스라기 보다는 객체이고,  class와의 관계에서 보면 Car의 객체라고 말하기보단 Car의 인스턴스라고 함4. The Four Pilars of OOP1. Encapsulation (캡슐화)  관련있는 변수와 함수를 하나의 단위로 묶는 것  자동차와 관련된 변수와 함수가 묶여있는 클래스 자체가 캡슐화의 예시class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"Information Hiding(정보 은닉)  속성이나 메소드같이 객체가 소유하는 것들을 다른 객체에 공개하지 않고 숨기는 것  외부 객체가 특정 객체의 데이터화 함수를 직접 접근하여 사용하거나 변경하지 못하므로 유지 보수와 소프트 웨어 확장시 오류를 최소화  속성과 메소드의 공개 범위를 access modifier(접근 제어자) 로 결정          public : 공개                  해당 클래스의 객체, 상속받는 클래스의 객체, 그리고 외부 객체 모두 다 접근 가능                    private : 숨김                  Private으로 지정된 property나 메소드는 해당 클래스의 객체 내부에서만 접근 가능          외부 객체는 접근이 막혀있음          상속받는 sub class도 직접적인 접근은 할 수 없고 상속받지 아니한다.                    protected : 숨김                  외부 객체는 접근이 막혀있음          상속받는 sub class는 접근 할 수 있고 상속 받는다.                    2. Abstraction (추상화)  객체들의 공통 특징(property, method)을 뽑아 하나의 클래스로 표현하는 것  객체의 관점에서 클래스를 정의하는 것  사자, 곰, 말 -&gt; 각각 객체이 객체들을 공통된 특징인 동물이나 생물로 묶는 것이 추상화3. Inheritance (상속성)  자식클래스(Sub Class)가 부모클래스(Base Class, Super Class)로부터 Property와 Method들을 상속받을 수 있는 특성class Car:    def __init__(self, model, price, color):        self.model = model        self.price = price        self.color = color    def drive(self, speed):        if speed &gt; 100:            return \"SPEEDING VIOLATION\"        else:            return \"DRIVE CAREFULLY\"class Taxi(Car):    def take_passengers(self, passengers):        if passengers &gt; 4:            return \"5명 이상 못 탐\"        else:            return \"출발~\"taxi1 = Taxi(\"기아\", \"3,000만원\", \"orange\")print(taxi1.take_passengers(7)) # 5명 이상 못 탐print(taxi1.drive(120))# SPEEDING VIOLATION 🔵  Taxi 클래스는 자신의 고유 Method를 사용할 수 있는 것은 물론 Car 클래스를 상속받았기 때문에 Car 클래스 안의 Property(model, price, color) 와 Method(drive) 모두를 사용할 수 있다🔵  상속성을 사용하면 자식클래스에서 불필요하게 다시 정의할 일 없이 부모클래스의 코드를 재사용가능하기 때문에 중복을 방지할 수 있다  Overriding : 부모클래스의 메소드를 그대로 상속받지 않고 재정의해서 사용할 수 있는 기능4. Polymorphism (다형성)  하나의 형태가 다양한 유형으로 나타날 수 있는 특성  Overriding처럼 부모클래스의 메소드가 자식클래스에서 다양한 기능으로 나타날 수 있는 것도 한 예시  Overloading : 메소드의 이름은 같지만 매개변수가 다름          python 과 javascript는 overloading 함수를 지원하지 않음      ex) sum 이라는 같은 이름의 함수가 매개변수의 개수와 타입에 따라 각기 다른 3개의 메소드로 구현되고 있다      public class Math {      public int sum(int x, int y)    {        return (x + y);    }      public int sum(int x, int y, int z)    {        return (x + y + z);    }      public double sum(double x, double y)    {        return (x + y);    }      public static void main(String args[])    {        Math math = new Math();        System.out.println(math.sum(1, 2));        System.out.println(math.sum(3, 4, 5));        System.out.println(math.sum(7.7, 8.8));    }}  Duck Typing : “만약 어떤 것이 오리처럼 생겼고, 오리처럼 헤엄치고, 오리처럼 꽥꽥거린다면 그건 오리라고 봐야 한다”라는 오리 실험에서 유래된 것으로 동일한 변수와 메소드를 가지고 있는 객체는 동일한 타입으로 간주하는 typing 방법  서로 아무 상관없는 세 클라스 Truck, Bus, RaceCar는 모두 drive 메소드를 제공하기 때문에 Duck Typing 개념에 의하여 drive_car 함수 입장에서는 동일한 객체로 간주될 수 있다는 것이다.class Truck:  def drive(self):    print(\"Driving Truck\")  def stop(self):    print(\"Stoping Truck\")class Bus:\tdef drive(self):\t\tprint(\"Driving Bus\")\tdef stop(self):\t\tprint(\"Stoping Bus\")class RaceCar:\tdef drive(self):\t\tprint(\"Driving RaceCar\")\tdef stop(self):\t\tprint(\"Stoping RaceCar\")def drive_car(car):\tcar.drive()truck = Truck()bus = Bus()race_car = RaceCar()drive_car(truck) # Driving Truckdrive_car(bus) # Driving Busdrive_car(race_car) # Driving RaceCar  Polymorphism(다형성) 이 중요한 이유 polymorphism을 통해서 포괄적인(generic) 인터페이스 제공이 가능해지기 때문이다. 위 duck typing 코드 예제에세도, drive_car 함수는 실제 input으로 들어오는 객체의 타입이나 구현 내용이나 실행 로직에 대해서 확인하거나 인지할 필요가 없다. drive 메소드만 가지고 있다면 실행이 가능하기 때문이다. 그러므로 polymorphism을 통해 굉장히 유연하고 간단한 인터페이스 및 로직 구현이 가능해진다."
  },
  
  {
    "title": "Kream 사이트 클론 프로젝트",
    "url": "/posts/kream_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-06 10:00:00 +0900",
    





    
    "snippet": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 ...",
    "content": "SHOEKREAM Project🎇 팀명 : shoekream - 슈크림  의류 경매 서비스를 제공하는 KREAM을 모티브로 제작하게 된 SHOE-KREAM 팀의 프론트엔드 레포지토리 입니다.짧은 프로젝트 기간동안 개발에 집중해야 하므로 디자인/기획 부분만 클론했습니다.개발은 초기 세팅부터 전부 직접 구현했으며, 백앤드와 연결하여 실제 사용할 수 있는 서비스 수준으로 개발할 수 있도록 2주간 고군분투 하였습니다.프로젝트 선정이유  조사결과, 해당 사이트의 경매 입찰 기능과 결제 플로우, 차트 구현, 상품리스트 필터 구현 등 배울 점이 많다고 판단하여 선정하게 되었습니다.📅 개발 기간 및 개발 인원  개발 기간 : 2021/10/18 ~ 2021/10/29  개발 인원  👨‍👧‍👦 Front-End 4명 : 김현진, 박산성, 이선호, 하상영 👨‍👧‍👦 Back-End 3명 : 박치훈, 양가현, 송영록  Back-end github 링크🎬 프로젝트 구현 영상  🔗 [구현영상] : https://youtu.be/N63MUdDmDFI⛓️ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia⚙️ 데이터베이스 Diagram💻 구현 기능Endpoint documentation - Postman APIBACKEND  로그인 구현import jwtimport requestsfrom json.decoder import JSONDecodeErrorfrom django.http  import JsonResponsefrom django.views import Viewfrom users.models import Userfrom my_settings  import SECRET_KEY, ALGORITHMSclass KakaoLogin(View):    def get(self, request):        try:             token = request.headers.get('Authorization')            if token == None:                return JsonResponse({'messsage': 'INVALID_TOKEN'}, status=401)            kakao_account = requests.get('https://kapi.kakao.com/v2/user/me', headers = {'Authorization': f'Bearer {token}'}).json()            print('::::kakao_account:', kakao_account)            if not User.objects.filter(kakao_id=kakao_account['id']).exists():                user = User.objects.create(                    kakao_id = kakao_account['id'],                    email    = kakao_account['kakao_account']['email'],                    name     = kakao_account['kakao_account']['profile']['nickname']                )            user = User.objects.get(kakao_id=kakao_account['id'])            access_token = jwt.encode({'user_id': user.id}, SECRET_KEY, algorithm=ALGORITHMS)            return JsonResponse({'access_token': access_token}, status=201)        except KeyError:            return JsonResponse({'message': 'KEY_ERROR'}, status=400)                except JSONDecodeError:            return JsonResponse({'message': 'JSON_DECODE_ERROR'}, status=400)        except jwt.DecodeError:            return JsonResponse({'message': 'JWT_DECODE_ERROR'}, status=400)        except ConnectionError:            return JsonResponse({'message': 'CONNECTION_ERROR'}, status=400)  카카오 연동 로그인 구현  Authorization 헤더에서 카카오 엑세스 토큰을 받아옴  request.get() 함수를 통해 카카오 API 엔드포인트로 사용자 정보 요청, json 형식으로 받아옴  카카오 아이디로 사용자 조회, 없으면 새로운 유저 생성  사용자 정보에서 user모델의 id를 이용하여 jwt 토큰 발급  jwt.encode()함수에 SECRET_KEY와 ALGORITHMS를 활용하여 JWT 토큰 생성 후 반환  프론트엔드에 발상할 오류의 종류를 예외처리하여 명확히 명시  로그인 데코레이터 구현import jsonimport jwtfrom django.http  import JsonResponsefrom my_settings  import SECRET_KEY, ALGORITHMSfrom users.models import Userdef login_decorator(func):    def wrapper(self, request, *args, **kwargs):        if 'Authorization' not in request.headers :             return JsonResponse ({'message' : 'UNAUTHORIZED'}, status=401)        access_token = request.headers.get('Authorization')                try:            payload      = jwt.decode(access_token, SECRET_KEY, algorithms=ALGORITHMS)            user         = User.objects.get(id=payload['user_id'])            request.user = user        except jwt.exceptions.DecodeError:            return JsonResponse({'MESSAGE': 'INVALID_TOKEN'}, status=401)        except User.DoesNotExist:            return JsonResponse({'MESSAGE': 'INVALID_USER'}, status=401)        return func(self, request,  *args, **kwargs)    return wrapper  python decorator 활용  로그인 성공 시 토큰 발급(jwt)  로그인 실패 시 예외처리  jwt.decode() 함수를 통해 토큰 검증  디코딩한 토큰에서 user_id 추출, user모델에서 해당 user_id 조회 후 가져옴  추출한 사용자를 request.user에 저장, 이후 로그인 상태 유지  상세 페이지class DetailProductView(View) :    def get(self, request, product_id) :        try :                           buy_price_filter  = (Q(productsize__bidding__bidding_position_id = 2) &amp; Q(productsize__bidding__bidding_status_id = 1))            sell_price_filter = (Q(productsize__bidding__bidding_position_id = 1) &amp; Q(productsize__bidding__bidding_status_id = 1))            if not Product.objects.filter(id = product_id).exists():                return JsonResponse({'MESSAGE':'product_id_not_exist'}, status = 404)                        product  = Product.objects\\                                    .annotate(buy_price = Min('productsize__bidding__price', filter = buy_price_filter),                                             sell_price = Max('productsize__bidding__price', filter = sell_price_filter))\\                                    .get(id = product_id)                                                                orders   = Order.objects.\\                                    filter(bidding__product_size__product_id = product_id).\\                                    order_by('-created_at')            wishlist = len(Wishlist.objects.filter(id=product_id).all())                        product_detail = [{                                'product_id'      : product.id,                                'name'            : product.name,                                'brand_name'      : product.brand.name,                                'release_price'   : product.release_price,                                'model_number'    : product.model_number,                                'image_list'      : [image.image_url for image in product.productimage_set.all()],                                'recent_price'    : orders.first().bidding.price if orders.exists() else None,                                'buy_price'       : product.buy_price,                                'sell_price'      : product.sell_price,                                'total_wishlist'  : wishlist,                            }]            return JsonResponse({'product_detail' : product_detail}, status=200)        except AttributeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)                except TypeError as e :            return JsonResponse({'message' : f'{e}'}, status=400)  필터 조건 정의: 구매 입찰 정보중 입찰 상태가 유효한 조건(입찰 포지션 2, 상태가 1인 경우)과 판매 입찰 정보 중 입찰 상태가 유효한 조건(입찰 포지션 1, 상태가 1인 경우)  효율적인 데이터 처리와 코드의 간결성을 위하여 annotate()함수 활용  데이터베이스 단계서 집계 함수(Min, Max)를 활용하여 필요한 값을 미리 계산    상품 리스트 출력 API(ProductView)  브랜드 리스트 출력 API(BrandView)```pythonclass BrandView(View):    def get(self, request):            brands = Brand.objects.all()        brand_list = [{                    'brand_id'   : brand.id,                    'brand_name' : brand.name,                } for brand in brands]        return JsonResponse({'brand_list' : brand_list}, status = 200) ``` - 메인 페이지, 제품 페이지 상단 브랜드 출력을 위하여 API 작성❗ Reference  이 프로젝트는 KREAM 사이트를 참조하여 학습목적으로 만들었습니다.  실무수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제될 수 있습니다.  이 프로젝트에서 사용하고 있는 사진 모두는 copyright free 사이트들의 이미지들을 취합 및 canva 에서 직접 제작한 이미지들로 제작되었습니다."
  },
  
  {
    "title": "Spao 사이트 클론 프로젝트",
    "url": "/posts/Spao_clone_project/",
    "categories": "Project",
    "tags": "Django, project, python, mysql, git, backend, frontend",
    "date": "2022-01-05 10:00:00 +0900",
    





    
    "snippet": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획...",
    "content": "  Trends meet Basic Be Transic! - 스파오(SPAO) 사이트 클론.🎇 팀명 : SPAOGAME - 스파오게임  팀원들 각자의 기술에 익숙해지는 것을 목표로 하여, 페이지 단위로 개발.  팀원들 수준별로 적절한 역할 분담과 애자일한 스크럼 방식의 미팅, 그리고 규칙적이고 능동적인 의사소통으로 프로젝트를 성공적으로 마무리.  기획 과정 없이 짧은 기간 안에 기술 습득 및 기본 기능 구현에 집중하기 위해서 SPAO 사이트를 참고.📅 개발 기간 및 개발 인원  개발 기간 : 2021-10-05 ~ 2021-10-15 (공휴일 포함)  개발 인원  👨‍👧‍👦 Front-End 3명 : 강성구, 김현진, 정경훈  👨‍👧‍👦 Back-End 3명 : 김주현, 이기용, 송영록⚙ 적용 기술  Front-End : HTML5, CSS3, React, SASS, JSX  Back-End : Python, Django, MySQL, jwt, bcypt, AWS RDS, AWS EC2  Common : Git, Github, Slack, Trello, Postman or Insomnia🗜 데이터베이스 Diagram(클릭 시 해당 링크로 이동합니다)💻 구현 기능BACKEND  회원가입 API  jwt와 bcrpyt를 이용한 로그인 API  장바구니 상품 추가, 수정, 삭제 API⌨ EndPoint  POST/users/signup (회원가입)  POST/users/signin (로그인)  POST/orders/cart (장바구니 생성)  GET/orders/cart (장바구니 조회)  PATCH/orders/cart (장바구니 수정)  DEL/orders/cart (장바구니 삭제)  POST/postings  (후기 등록)  POST/postings/comments (댓글 등록)  POST/postings/ (댓글 삭제)  POST/products/menus (메뉴 항목 추가)  GET/products/menus (메뉴 항목 리스트 조회)  POST/products/categories (카테고리 항목 추가)  GET/products// (특정 메뉴별 카테고리 항목 리스트 조회)  POST/products (상품 등록)  GET/products// (특정 메뉴-카테고리별 상품 리스트 조회)  GET/products/ (특정 상품에 대한 상세페이지)❗ Reference  이 프로젝트는 SPAO 사이트를 참조하여 학습목적으로 만들었습니다.  실무 수준의 프로젝트이지만 학습용으로 만들었기 때문에 이 코드를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다.🙏 help  프로젝트 상품 이미지 출처원 : MIDEOCK-미덕 , SARNO-사르노 *이미지 사용을 허가해주신 대표님들께 감사합니다.  해당 프로젝트의 이미지를 활용하여 이득을 취하거나 무단 배포할 경우 법적으로 문제가 될 수 있습니다."
  },
  
  {
    "title": "Django project 초기세팅",
    "url": "/posts/Django_Project_%EC%B4%88%EA%B8%B0%EC%84%B8%ED%8C%85/",
    "categories": "Django",
    "tags": "Django",
    "date": "2022-01-04 10:00:00 +0900",
    





    
    "snippet": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 ...",
    "content": "Django Project를 위한 초기세팅가상환경 생성프로젝트 마다 독립적인 패키지의 관리를 위해 새로운 가상환경을 생성해서 사용!#가상환경 생성conda create -n \"가상환경 이름\" python=3.8conda activate \"가상환경 이름\"Database 생성mysql을 미리 설치해야 한다$ mysql -u root -p # 명령어 입력 후 mysql로 전환# 데이터베이스 생성mysql&gt; create database NAME character set utf8mb4 collate utf*mb4_general_ci; Project Python Package 설치$ pip install django# 이후에 MySQL server에 접속하기 위한 package$ pip install mysqlclient  (중요) mysql 설치되어 있는지 먼저 확인# 맥북은 mysqlclient를 다운받으려면 오류가 난다 그러므로 PyMySQL을 다운받자$ pip install PyMySQL#!밑글에 pymysql 세팅법을 적어놓음Django Project 생성$ django-admin startproject westarbucks$ cd westarbucksSettings.py 설정. IP허용\tALLOWED_HOSTS = ['*']. 추가로 westarbucks/urls.py를 아래와 같이 수정from django.urls import pathurlpatterns = []. 주석처리(admin, csrf, auth)my_settings.py 생성(DATABASES,SECRET_KEY). django 설정에 존재하는 내용 중 SECRET_KEY, DATABASE 등은 절대 settings.py에 두면 안됩니다.. 그대로 깃이나 오픈클라우드에 올려버리면 해킹을 당하기가 쉽습니다. 아니 당합니다!. 그래서 별도의 참조용 파이썬 파일(my_settings.py)을 생성해서, 참조하는 방법으로 진행cd '생성한 프로젝트 폴더명'touch my_settings.py. 파일에 실제 쓰여지는 내용#예시DATABASES = {    'default' : {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'DATABASE 명',        'USER': 'DB접속 계정명',        'PASSWORD': 'DB접속용 비밀번호',        'HOST': '127.0.0.1',        'PORT': '3306',    }}SECRET_KEY = '시크릿키' #settings.py에 있는 secret_key 를 사용합니다.settings.py &lt;-&gt; my_settings.py 연동#intel 맥북from pathlib\t\timport Path #기존에 settings.py에 있는 코드from my_settings\timport DATABASES, SECRET_KEYDATABASES = DATABASESSECRET_KEY = SECRET_KEY#### m1 맥북!!# $ pip install PyMySQL# 으로 PyMySQL을 다운받는거 잊지말자from pathlib        import Path #기존에 settings.py 에 있는 코드from my_settings import DATABASES, SECRET_KEYimport pymysqlpymysql.install_as_MySQLdb().corsheaderspip install django-cors-headers. 설치했다면 settings.py에 INSTALLED_APPS 안에 추가INSTALLED_APPS = [...\t\t'corsheaders']. middleware 추가MIDDLEWARE = [\t...\t\t'corsheaders.middleware.CorsMiddleware',\t...]. CORS 추가 설정##CORSCORS_ORIGIN_ALLOW_ALL=TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = (    'DELETE',    'GET',    'OPTIONS',    'PATCH',    'POST',    'PUT',)CORS_ALLOW_HEADERS = (    'accept',    'accept-encoding',    'authorization',    'content-type',    'dnt',    'origin',    'user-agent',    'x-csrftoken',    'x-requested-with',)서버 정상 동작 확인. 서버 동작(Runserver)을 통한 오류 검증python manage.py runserver. 정상 동작 예시이제 프로젝트를 위한 초기 세팅은 끝났다~프로젝트를 진행해보자!"
  }
  
]

